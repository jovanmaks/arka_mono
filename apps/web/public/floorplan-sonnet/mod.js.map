{
  "version": 3,
  "sources": ["../../../../packages/floorplan-sonnet/skeletonize.ts", "../../../../packages/floorplan-sonnet/point-classifier.ts", "../../../../packages/floorplan-sonnet/line-detector.ts"],
  "sourcesContent": ["/**\n * Skeletonize Module\n * \n * This module provides functions to process floorplan images and extract skeletons\n * using OpenCV.js. It mimics the Python implementation's functionality but uses\n * browser-compatible image processing.\n */\n\n// Types for our image processing functions\nexport interface ProcessedImage {\n  /** The skeletonized image data */\n  skeleton: ImageData;\n  /** The original image width */\n  originalWidth: number;\n  /** The original image height */\n  originalHeight: number;\n  /** Debug information */\n  debugInfo: Record<string, any>;\n}\n\n/**\n * Convert an HTML Image element to a canvas and get its ImageData\n */\nexport function imageToImageData(img: HTMLImageElement): ImageData {\n  const canvas = document.createElement('canvas');\n  canvas.width = img.width;\n  canvas.height = img.height;\n  const ctx = canvas.getContext('2d');\n  \n  if (!ctx) {\n    throw new Error('Could not get canvas context');\n  }\n  \n  ctx.drawImage(img, 0, 0);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\n\n/**\n * Convert an ImageData object to grayscale\n */\nexport function convertToGrayscale(imageData: ImageData): ImageData {\n  const { data, width, height } = imageData;\n  const grayscaleData = new Uint8ClampedArray(width * height * 4);\n  \n  for (let i = 0; i < data.length; i += 4) {\n    // Standard grayscale conversion: 0.299*R + 0.587*G + 0.114*B\n    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];\n    grayscaleData[i] = gray;     // R\n    grayscaleData[i + 1] = gray; // G\n    grayscaleData[i + 2] = gray; // B\n    grayscaleData[i + 3] = data[i + 3]; // A\n  }\n  \n  return new ImageData(grayscaleData, width, height);\n}\n\n/**\n * Threshold an image (convert to binary)\n * @param imageData The image data to threshold\n * @param threshold Threshold value (0-255)\n * @param inverse If true, will invert the threshold (THRESH_BINARY_INV)\n */\nexport function threshold(imageData: ImageData, threshold: number, inverse: boolean = true): ImageData {\n  const { data, width, height } = imageData;\n  const resultData = new Uint8ClampedArray(width * height * 4);\n  \n  for (let i = 0; i < data.length; i += 4) {\n    // For each pixel, check if it's above or below threshold\n    const gray = data[i]; // We assume it's already grayscale\n    const value = inverse ? (gray < threshold ? 255 : 0) : (gray > threshold ? 255 : 0);\n    \n    resultData[i] = value;     // R\n    resultData[i + 1] = value; // G\n    resultData[i + 2] = value; // B\n    resultData[i + 3] = data[i + 3]; // A\n  }\n  \n  return new ImageData(resultData, width, height);\n}\n\n/**\n * Apply morphological erosion to an image\n * Similar to cv2.erode\n */\nexport function erode(imageData: ImageData, kernelSize: number = 3): ImageData {\n  const { width, height } = imageData;\n  const result = new Uint8ClampedArray(width * height * 4);\n  \n  // First, create a copy of the input\n  result.set(imageData.data);\n  \n  const halfKernel = Math.floor(kernelSize / 2);\n  const tempCanvas = document.createElement('canvas');\n  tempCanvas.width = width;\n  tempCanvas.height = height;\n  const tempCtx = tempCanvas.getContext('2d');\n  \n  if (!tempCtx) {\n    throw new Error('Failed to get temporary canvas context');\n  }\n  \n  tempCtx.putImageData(imageData, 0, 0);\n  const sourceImageData = tempCtx.getImageData(0, 0, width, height);\n  \n  // Apply erosion: for each pixel, take the minimum value in the neighborhood\n  for (let y = halfKernel; y < height - halfKernel; y++) {\n    for (let x = halfKernel; x < width - halfKernel; x++) {\n      let minValue = 255;\n      \n      // Check all pixels in the kernel\n      for (let ky = -halfKernel; ky <= halfKernel; ky++) {\n        for (let kx = -halfKernel; kx <= halfKernel; kx++) {\n          const pos = ((y + ky) * width + (x + kx)) * 4;\n          // Take minimum value in the kernel\n          minValue = Math.min(minValue, sourceImageData.data[pos]);\n        }\n      }\n      \n      const pos = (y * width + x) * 4;\n      result[pos] = minValue;\n      result[pos + 1] = minValue;\n      result[pos + 2] = minValue;\n      // Keep alpha unchanged\n    }\n  }\n  \n  return new ImageData(result, width, height);\n}\n\n/**\n * Apply morphological dilation to an image\n * Similar to cv2.dilate\n */\nexport function dilate(imageData: ImageData, kernelSize: number = 3): ImageData {\n  const { width, height } = imageData;\n  const result = new Uint8ClampedArray(width * height * 4);\n  \n  // First, create a copy of the input\n  result.set(imageData.data);\n  \n  const halfKernel = Math.floor(kernelSize / 2);\n  const tempCanvas = document.createElement('canvas');\n  tempCanvas.width = width;\n  tempCanvas.height = height;\n  const tempCtx = tempCanvas.getContext('2d');\n  \n  if (!tempCtx) {\n    throw new Error('Failed to get temporary canvas context');\n  }\n  \n  tempCtx.putImageData(imageData, 0, 0);\n  const sourceImageData = tempCtx.getImageData(0, 0, width, height);\n  \n  // Apply dilation: for each pixel, take the maximum value in the neighborhood\n  for (let y = halfKernel; y < height - halfKernel; y++) {\n    for (let x = halfKernel; x < width - halfKernel; x++) {\n      let maxValue = 0;\n      \n      // Check all pixels in the kernel\n      for (let ky = -halfKernel; ky <= halfKernel; ky++) {\n        for (let kx = -halfKernel; kx <= halfKernel; kx++) {\n          const pos = ((y + ky) * width + (x + kx)) * 4;\n          // Take maximum value in the kernel\n          maxValue = Math.max(maxValue, sourceImageData.data[pos]);\n        }\n      }\n      \n      const pos = (y * width + x) * 4;\n      result[pos] = maxValue;\n      result[pos + 1] = maxValue;\n      result[pos + 2] = maxValue;\n      // Keep alpha unchanged\n    }\n  }\n  \n  return new ImageData(result, width, height);\n}\n\n/**\n * Apply morphological opening (erosion followed by dilation)\n * Similar to cv2.morphologyEx with MORPH_OPEN\n */\nexport function morphologicalOpen(imageData: ImageData, kernelSize: number = 3): ImageData {\n  // Opening = Erosion followed by dilation\n  const eroded = erode(imageData, kernelSize);\n  return dilate(eroded, kernelSize);\n}\n\n/**\n * Apply morphological closing (dilation followed by erosion)\n * Similar to cv2.morphologyEx with MORPH_CLOSE\n */\nexport function morphologicalClose(imageData: ImageData, kernelSize: number = 3): ImageData {\n  // Closing = Dilation followed by erosion\n  const dilated = dilate(imageData, kernelSize);\n  return erode(dilated, kernelSize);\n}\n\n/**\n * Skeletonize a binary image using morphological operations\n * This is an implementation of the Zhang-Suen thinning algorithm,\n * which is similar to what OpenCV's ximgproc.thinning uses\n */\nexport function morphologicalThinning(imageData: ImageData): ImageData {\n  const { width, height } = imageData;\n  const result = new Uint8ClampedArray(width * height * 4);\n  \n  // Copy the original image data\n  let current = new Uint8ClampedArray(imageData.data);\n  let changed = true;\n  \n  // Convert to binary (0 and 1)\n  for (let i = 0; i < current.length; i += 4) {\n    current[i] = current[i] > 128 ? 1 : 0;\n    current[i + 1] = current[i];\n    current[i + 2] = current[i];\n    current[i + 3] = 255; // Full alpha\n  }\n  \n  const iterations = 0; // Safety counter to prevent infinite loops\n  const maxIterations = 100;\n  \n  // Zhang-Suen thinning algorithm\n  while (changed && iterations < maxIterations) {\n    changed = false;\n    \n    // First sub-iteration\n    const markedPoints: number[] = [];\n    \n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        const p = (y * width + x) * 4;\n        \n        // Skip if not a foreground pixel\n        if (current[p] === 0) continue;\n        \n        // Get 8-neighbors (clockwise)\n        const p2 = ((y-1) * width + x) * 4;\n        const p3 = ((y-1) * width + (x+1)) * 4;\n        const p4 = (y * width + (x+1)) * 4;\n        const p5 = ((y+1) * width + (x+1)) * 4;\n        const p6 = ((y+1) * width + x) * 4;\n        const p7 = ((y+1) * width + (x-1)) * 4;\n        const p8 = (y * width + (x-1)) * 4;\n        const p9 = ((y-1) * width + (x-1)) * 4;\n        \n        const values = [\n          current[p2], current[p3], current[p4], current[p5],\n          current[p6], current[p7], current[p8], current[p9]\n        ];\n        \n        // Count non-zero neighbors\n        const nonZeroNeighbors = values.reduce((a, b) => a + b, 0);\n        \n        if (nonZeroNeighbors < 2 || nonZeroNeighbors > 6) continue;\n        \n        // Count transitions from 0 to 1 in the ordered sequence\n        let transitions = 0;\n        for (let i = 0; i < values.length; i++) {\n          if (values[i] === 0 && values[(i+1) % values.length] === 1) {\n            transitions++;\n          }\n        }\n        \n        if (transitions !== 1) continue;\n        \n        // Check if p2 * p4 * p6 == 0\n        if (current[p2] * current[p4] * current[p6] !== 0) continue;\n        \n        // Check if p4 * p6 * p8 == 0\n        if (current[p4] * current[p6] * current[p8] !== 0) continue;\n        \n        // Mark for deletion\n        markedPoints.push(p);\n        changed = true;\n      }\n    }\n    \n    // Delete marked points\n    for (const p of markedPoints) {\n      current[p] = 0;\n      current[p + 1] = 0;\n      current[p + 2] = 0;\n    }\n    \n    // Second sub-iteration\n    markedPoints.length = 0;\n    \n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        const p = (y * width + x) * 4;\n        \n        // Skip if not a foreground pixel\n        if (current[p] === 0) continue;\n        \n        // Get 8-neighbors (clockwise)\n        const p2 = ((y-1) * width + x) * 4;\n        const p3 = ((y-1) * width + (x+1)) * 4;\n        const p4 = (y * width + (x+1)) * 4;\n        const p5 = ((y+1) * width + (x+1)) * 4;\n        const p6 = ((y+1) * width + x) * 4;\n        const p7 = ((y+1) * width + (x-1)) * 4;\n        const p8 = (y * width + (x-1)) * 4;\n        const p9 = ((y-1) * width + (x-1)) * 4;\n        \n        const values = [\n          current[p2], current[p3], current[p4], current[p5],\n          current[p6], current[p7], current[p8], current[p9]\n        ];\n        \n        // Count non-zero neighbors\n        const nonZeroNeighbors = values.reduce((a, b) => a + b, 0);\n        \n        if (nonZeroNeighbors < 2 || nonZeroNeighbors > 6) continue;\n        \n        // Count transitions from 0 to 1 in the ordered sequence\n        let transitions = 0;\n        for (let i = 0; i < values.length; i++) {\n          if (values[i] === 0 && values[(i+1) % values.length] === 1) {\n            transitions++;\n          }\n        }\n        \n        if (transitions !== 1) continue;\n        \n        // Check if p2 * p4 * p8 == 0\n        if (current[p2] * current[p4] * current[p8] !== 0) continue;\n        \n        // Check if p2 * p6 * p8 == 0\n        if (current[p2] * current[p6] * current[p8] !== 0) continue;\n        \n        // Mark for deletion\n        markedPoints.push(p);\n        changed = true;\n      }\n    }\n    \n    // Delete marked points\n    for (const p of markedPoints) {\n      current[p] = 0;\n      current[p + 1] = 0;\n      current[p + 2] = 0;\n    }\n  }\n  \n  // Convert binary back to 0 and 255\n  for (let i = 0; i < current.length; i += 4) {\n    const val = current[i] === 1 ? 255 : 0;\n    result[i] = val;\n    result[i + 1] = val;\n    result[i + 2] = val;\n    result[i + 3] = 255; // Full alpha\n  }\n  \n  return new ImageData(result, width, height);\n}\n\n/**\n * Skeletonize an image\n * This is the main function that processes an image into a skeleton,\n * similar to the Python skeletonize_image function\n */\nexport async function skeletonizeImage(\n  imageSource: HTMLImageElement | string | Blob,\n  threshVal: number = 100\n): Promise<ProcessedImage> {\n  // Load the image if it's a string URL or blob\n  const img = imageSource instanceof HTMLImageElement \n    ? imageSource \n    : await loadImage(imageSource);\n  \n  const originalWidth = img.width;\n  const originalHeight = img.height;\n  \n  console.log(`[DEBUG] Original (H\u00D7W): ${originalHeight} \u00D7 ${originalWidth}`);\n  \n  // 1. Convert to ImageData\n  const imageData = imageToImageData(img);\n  \n  // 2. Convert to grayscale\n  const grayImageData = convertToGrayscale(imageData);\n  console.log('[DEBUG] After grayscale conversion');\n  \n  // 3. Threshold\n  const binaryImageData = threshold(grayImageData, threshVal, true);\n  console.log('[DEBUG] After threshold');\n  \n  // 4. Morphological opening/closing\n  const openedImageData = morphologicalOpen(binaryImageData, 3);\n  console.log('[DEBUG] After open');\n  const closedImageData = morphologicalClose(openedImageData, 3);\n  console.log('[DEBUG] After close');\n  \n  // 5. Thinning (skeletonization)\n  const skelImageData = morphologicalThinning(closedImageData);\n  console.log('[DEBUG] After thinning');\n  \n  // 6. Return the processed image with metadata\n  return {\n    skeleton: skelImageData,\n    originalWidth,\n    originalHeight,\n    debugInfo: {\n      thresholdValue: threshVal\n    }\n  };\n}\n\n/**\n * Helper function to load an image from URL or Blob\n */\nexport function loadImage(src: string | Blob): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    \n    img.onload = () => resolve(img);\n    img.onerror = () => reject(new Error('Failed to load image'));\n    \n    if (typeof src === 'string') {\n      img.src = src;\n    } else {\n      img.src = URL.createObjectURL(src);\n    }\n  });\n}\n\n/**\n * Helper function to render an ImageData to a canvas\n */\nexport function renderImageDataToCanvas(\n  imageData: ImageData, \n  canvas: HTMLCanvasElement\n): void {\n  canvas.width = imageData.width;\n  canvas.height = imageData.height;\n  \n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    throw new Error('Could not get canvas context');\n  }\n  \n  ctx.putImageData(imageData, 0, 0);\n}", "/**\n * Point Classifier Module\n * \n * This module provides functions to identify key points in a skeletonized image,\n * such as corners, endpoints, and T-junctions, similar to the Python implementation.\n */\n\n// Define point types\nexport type PointType = 'endpoint' | 'corner' | 't_junction' | 'none';\n\nexport interface Point {\n  x: number;\n  y: number;\n  type?: PointType;\n}\n\n/**\n * Classifies a point based on its 3x3 neighborhood pattern\n * Enhanced version to better detect junctions and corners\n * \n * @param neighborhood A 3x3 array of pixel values (0 or 255)\n * @returns The point type: 'endpoint', 'corner', 't_junction', or 'none'\n */\nexport function classifyPoint(neighborhood: Uint8ClampedArray | number[][]): PointType {\n  // Convert to binary pattern (0 or 1)\n  let pattern: number[];\n  \n  if (Array.isArray(neighborhood)) {\n    // Handle 2D array input\n    if (neighborhood.length !== 3 || neighborhood[0].length !== 3) {\n      throw new Error('Neighborhood must be a 3x3 array');\n    }\n    \n    // Extract center value\n    const center = neighborhood[1][1] > 0 ? 1 : 0;\n    if (center === 0) return 'none';\n    \n    // Convert to 1D array of 8 neighbors in clockwise order\n    pattern = [\n      neighborhood[0][1] > 0 ? 1 : 0, // Top (P2)\n      neighborhood[0][2] > 0 ? 1 : 0, // Top-right (P3)\n      neighborhood[1][2] > 0 ? 1 : 0, // Right (P4)\n      neighborhood[2][2] > 0 ? 1 : 0, // Bottom-right (P5)\n      neighborhood[2][1] > 0 ? 1 : 0, // Bottom (P6)\n      neighborhood[2][0] > 0 ? 1 : 0, // Bottom-left (P7)\n      neighborhood[1][0] > 0 ? 1 : 0, // Left (P8)\n      neighborhood[0][0] > 0 ? 1 : 0  // Top-left (P9)\n    ];\n  } else {\n    // Handle Uint8ClampedArray input (assuming RGBA format)\n    if (neighborhood.length !== 36) { // 3x3 neighborhood with 4 channels\n      throw new Error('Neighborhood must contain 9 pixels (36 values in RGBA format)');\n    }\n    \n    // Extract center value\n    const center = neighborhood[4 * 4 + 0] > 0 ? 1 : 0; // Center pixel's R value\n    if (center === 0) return 'none';\n    \n    // Convert to 1D array of 8 neighbors in clockwise order\n    pattern = [\n      neighborhood[4 * 1 + 0] > 0 ? 1 : 0, // Top (P2)\n      neighborhood[4 * 2 + 0] > 0 ? 1 : 0, // Top-right (P3)\n      neighborhood[4 * 5 + 0] > 0 ? 1 : 0, // Right (P4)\n      neighborhood[4 * 8 + 0] > 0 ? 1 : 0, // Bottom-right (P5)\n      neighborhood[4 * 7 + 0] > 0 ? 1 : 0, // Bottom (P6)\n      neighborhood[4 * 6 + 0] > 0 ? 1 : 0, // Bottom-left (P7)\n      neighborhood[4 * 3 + 0] > 0 ? 1 : 0, // Left (P8)\n      neighborhood[4 * 0 + 0] > 0 ? 1 : 0  // Top-left (P9)\n    ];\n  }\n  \n  // Count total foreground neighbors\n  const neighbors = pattern.reduce((sum, val) => sum + val, 0);\n  \n  // Count transitions from 0 to 1\n  let transitions = 0;\n  for (let i = 0; i < pattern.length; i++) {\n    if (pattern[i] === 0 && pattern[(i + 1) % pattern.length] === 1) {\n      transitions++;\n    }\n  }\n\n  // Extended connectivity analysis for junctions\n  // Create a continuous pattern string for easier pattern matching\n  const patternString = pattern.join('') + pattern[0]; // Add first element to end for circular pattern\n\n  // Basic endpoint detection\n  if (neighbors === 1) {\n    return 'endpoint';\n  }\n\n  // Enhanced T-junction detection\n  // A T-junction has 3 branches extending from it\n  if (neighbors === 3) {\n    // Check if branches form a T shape\n    // We look for specific patterns that indicate T-junctions\n    if (transitions === 2) {\n      return 't_junction';\n    }\n    \n    // Check for additional T-junction patterns that might be missed by the transition count\n    // These are patterns where 3 branches extend from the center but don't perfectly match\n    // the normal T-junction pattern\n    \n    // Pattern with 3 connected pixels where two form a line and one branches off\n    const tPatterns = [\n      '10001000', // \u252C pattern\n      '01000100', // \u2524 pattern\n      '00100010', // \u2534 pattern\n      '00010001'  // \u251C pattern\n    ];\n\n    if (tPatterns.some(p => patternString.includes(p))) {\n      return 't_junction';\n    }\n  }\n\n  // Enhanced corner detection\n  // A corner has 2 branches extending from it at approximately 90 degrees\n  if (neighbors === 2) {\n    if (transitions === 2) {\n      // Check if the two branches are adjacent for a real corner\n      // Non-adjacent branches indicate a straight line segment, not a corner\n      for (let i = 0; i < pattern.length; i++) {\n        if (pattern[i] === 1 && pattern[(i + 1) % 8] === 1) {\n          return 'none'; // Adjacent branches indicate a potential line segment\n        }\n      }\n\n      // Two non-adjacent branches with transition count 2 is a corner\n      return 'corner';\n    }\n    \n    // Check for additional corner patterns\n    // Look for two branches that are approximately 90\u00B0 apart\n    const cornerPatterns = [\n      '10000100', // \u250C pattern\n      '01000010', // \u2510 pattern  \n      '00100001', // \u2514 pattern\n      '00010001'  // \u2518 pattern\n    ];\n\n    if (cornerPatterns.some(p => patternString.includes(p))) {\n      return 'corner';\n    }\n  }\n\n  // Handle complex junctions with 4 or more branches\n  if (neighbors >= 4 && transitions >= 2) {\n    return 't_junction'; // Treat as complex junction point\n  }\n  \n  return 'none';\n}\n\n/**\n * Extract a 3x3 neighborhood from an ImageData at position (x,y)\n */\nfunction getNeighborhood(imageData: ImageData, x: number, y: number): Uint8ClampedArray | null {\n  const { width, height, data } = imageData;\n  \n  // Check bounds\n  if (x < 1 || y < 1 || x >= width - 1 || y >= height - 1) {\n    return null;\n  }\n  \n  // Extract 3x3 neighborhood\n  const neighborhood = new Uint8ClampedArray(36); // 3x3 with 4 channels\n  \n  for (let dy = -1; dy <= 1; dy++) {\n    for (let dx = -1; dx <= 1; dx++) {\n      const srcIdx = ((y + dy) * width + (x + dx)) * 4;\n      const dstIdx = ((dy + 1) * 3 + (dx + 1)) * 4;\n      \n      neighborhood[dstIdx] = data[srcIdx];         // R\n      neighborhood[dstIdx + 1] = data[srcIdx + 1]; // G\n      neighborhood[dstIdx + 2] = data[srcIdx + 2]; // B\n      neighborhood[dstIdx + 3] = data[srcIdx + 3]; // A\n    }\n  }\n  \n  return neighborhood;\n}\n\n/**\n * Detect corners, endpoints and T-junctions in a skeletonized image\n * Similar to the Python detect_corners function\n */\nexport function detectCorners(\n  skelImageData: ImageData,\n  maxCorners: number = 3000,\n  qualityLevel: number = 0.001,\n  minDistance: number = 3\n): Point[] {\n  const { width, height, data } = skelImageData;\n  const importantPoints: Point[] = [];\n  \n  // First pass: look for corners (we don't have goodFeaturesToTrack in JS)\n  // So we'll use a simpler approach - scan the entire skeleton\n  for (let y = 1; y < height - 1; y++) {\n    for (let x = 1; x < width - 1; x++) {\n      const idx = (y * width + x) * 4;\n      \n      // Skip background pixels\n      if (data[idx] === 0) continue;\n      \n      // Get neighborhood\n      const neighborhood = getNeighborhood(skelImageData, x, y);\n      if (!neighborhood) continue;\n      \n      // Classify point\n      const pointType = classifyPoint(neighborhood);\n      \n      // Add important points\n      if (pointType !== 'none') {\n        // More lenient duplicate checking - only check exact matches or very close points\n        const isDuplicate = importantPoints.some(p => {\n          const dx = Math.abs(p.x - x);\n          const dy = Math.abs(p.y - y);\n          // Points must be very close and of the same type to be considered duplicates\n          return dx <= minDistance && dy <= minDistance && p.type === pointType;\n        });\n        \n        if (!isDuplicate) {\n          importantPoints.push({ x, y, type: pointType });\n        }\n      }\n    }\n  }\n  \n  // Limit to maxCorners\n  return importantPoints.slice(0, maxCorners);\n}\n\n/**\n * Cluster points using a simple K-means implementation\n * Similar to the Python cluster_points function\n * \n * @param points Array of points to cluster\n * @param numClusters Number of clusters to form\n * @returns Array of cluster centers (points)\n */\nexport function clusterPoints(points: Point[], numClusters: number = 50): Point[] {\n  if (points.length === 0) return [];\n  \n  // Use at least 20 clusters but no more than half the points\n  const k = Math.min(Math.max(numClusters, 20), Math.floor(points.length / 2));\n  \n  // Initialize clusters with random points\n  const clusters: Point[] = [];\n  const usedIndices = new Set<number>();\n  \n  // Select k random points as initial cluster centers\n  while (clusters.length < k) {\n    const idx = Math.floor(Math.random() * points.length);\n    if (!usedIndices.has(idx)) {\n      usedIndices.add(idx);\n      clusters.push({ ...points[idx] });\n    }\n  }\n  \n  let changed = true;\n  const MAX_ITERATIONS = 100;\n  let iterations = 0;\n  \n  // Array to store cluster assignments for each point\n  const assignments: number[] = new Array(points.length).fill(-1);\n  \n  // Initialize sums array outside the loop so it's accessible for final filtering\n  const sums: { x: number; y: number; count: number }[] = clusters.map(() => ({\n    x: 0, y: 0, count: 0\n  }));\n  \n  while (changed && iterations < MAX_ITERATIONS) {\n    changed = false;\n    iterations++;\n    \n    // Assign points to nearest cluster\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      let minDist = Infinity;\n      let minIdx = -1;\n      \n      for (let j = 0; j < clusters.length; j++) {\n        const cluster = clusters[j];\n        const dist = Math.sqrt(\n          Math.pow(point.x - cluster.x, 2) + Math.pow(point.y - cluster.y, 2)\n        );\n        \n        // Use a distance threshold to prevent points too far from being clustered\n        if (dist < minDist && dist < 30) { // 30px max distance threshold\n          minDist = dist;\n          minIdx = j;\n        }\n      }\n      \n      // Check if assignment changed\n      if (assignments[i] !== minIdx) {\n        assignments[i] = minIdx;\n        changed = true;\n      }\n    }\n    \n    // Reset sums for this iteration\n    sums.forEach(sum => {\n      sum.x = 0;\n      sum.y = 0;\n      sum.count = 0;\n    });\n    \n    // Update cluster centers\n    for (let i = 0; i < points.length; i++) {\n      const clusterIdx = assignments[i];\n      if (clusterIdx !== -1) { // Only count assigned points\n        sums[clusterIdx].x += points[i].x;\n        sums[clusterIdx].y += points[i].y;\n        sums[clusterIdx].count++;\n      }\n    }\n    \n    // Calculate new cluster centers\n    for (let i = 0; i < clusters.length; i++) {\n      if (sums[i].count > 0) {\n        clusters[i].x = Math.round(sums[i].x / sums[i].count);\n        clusters[i].y = Math.round(sums[i].y / sums[i].count);\n      }\n    }\n  }\n  \n  // Filter out empty clusters\n  return clusters.filter((_, i) => sums[i].count > 0);\n}\n\n/**\n * Color-code points on an image based on their type\n * Similar to fit_line_to_clustered_points in Python\n */\nexport function drawClusteredPoints(\n  imageData: ImageData, \n  clusteredPoints: Point[], \n  draw: boolean = true\n): void {\n  if (!draw) return;\n  \n  const { width, height, data } = imageData;\n  \n  for (const point of clusteredPoints) {\n    const { x, y } = point;\n    \n    // Check bounds\n    if (x < 0 || y < 0 || x >= width || y >= height) continue;\n    \n    // Get neighborhood for classification\n    const neighborhood = getNeighborhood(imageData, x, y);\n    \n    let color: [number, number, number]; // [R, G, B]\n    \n    if (!neighborhood) {\n      color = [0, 165, 255]; // Orange\n    } else {\n      const pointType = classifyPoint(neighborhood);\n      \n      switch (pointType) {\n        case 'endpoint':\n          color = [255, 0, 0]; // Blue (BGR -> RGB)\n          break;\n        case 'corner':\n          color = [0, 0, 255]; // Red\n          break;\n        case 't_junction':\n          color = [0, 255, 0]; // Green\n          break;\n        default:\n          color = [0, 165, 255]; // Orange\n      }\n    }\n    \n    // Draw a filled circle (approximation using a 3x3 square)\n    for (let dy = -1; dy <= 1; dy++) {\n      for (let dx = -1; dx <= 1; dx++) {\n        const px = x + dx;\n        const py = y + dy;\n        \n        if (px < 0 || py < 0 || px >= width || py >= height) continue;\n        \n        const idx = (py * width + px) * 4;\n        data[idx] = color[0];\n        data[idx + 1] = color[1];\n        data[idx + 2] = color[2];\n      }\n    }\n  }\n}", "/**\n * Line Detector Module\n * \n * This module provides functions to detect lines in a skeletonized image,\n * similar to the Python implementation's detect_straight_walls_hough function.\n */\nexport interface Line {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n}\n\n// Point interface for wall detection\ninterface Point {\n  x: number;\n  y: number;\n  type?: string;\n}\n\n/**\n * Apply Canny edge detection to an image\n * Similar to cv2.Canny\n */\nexport function cannyEdgeDetection(\n  imageData: ImageData,\n  lowThreshold: number = 50,\n  highThreshold: number = 150\n): ImageData {\n  // For our purposes, the skeletonized image is already an edge map\n  // So we'll just use it directly instead of implementing the full Canny algorithm\n  \n  const { width, height, data } = imageData;\n  const result = new Uint8ClampedArray(width * height * 4);\n  \n  // Copy the image data (we're assuming it's already binary)\n  for (let i = 0; i < data.length; i += 4) {\n    const val = data[i] > 0 ? 255 : 0;\n    result[i] = val;\n    result[i + 1] = val;\n    result[i + 2] = val;\n    result[i + 3] = 255;\n  }\n  \n  return new ImageData(result, width, height);\n}\n\n/**\n * A simple implementation of Hough Transform to detect lines\n * Similar to cv2.HoughLinesP but simplified for TypeScript\n */\nexport function houghLinesP(\n  imageData: ImageData,\n  rho: number = 1,\n  theta: number = Math.PI / 180,\n  threshold: number = 50,\n  minLineLength: number = 50,\n  maxLineGap: number = 10\n): Line[] {\n  const { width, height, data } = imageData;\n  \n  // Maximum distance possible in the image\n  const maxDistance = Math.sqrt(width * width + height * height);\n  // Number of bins for rho and theta\n  const numRho = Math.ceil(maxDistance / rho);\n  const numTheta = Math.ceil(Math.PI / theta);\n  \n  // Initialize the accumulator\n  const accumulator: number[][] = Array(numRho * 2)\n    .fill(null)\n    .map(() => Array(numTheta).fill(0));\n  \n  // Scan through the image and vote in the accumulator\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const idx = (y * width + x) * 4;\n      \n      // Only process edge pixels (non-zero)\n      if (data[idx] === 0) continue;\n      \n      // For each theta, calculate rho and vote\n      for (let thetaIdx = 0; thetaIdx < numTheta; thetaIdx++) {\n        const thetaVal = thetaIdx * theta;\n        \n        // Calculate rho = x*cos(theta) + y*sin(theta)\n        const rhoVal = x * Math.cos(thetaVal) + y * Math.sin(thetaVal);\n        // Shift by maxDistance to handle negative rho\n        const rhoIdx = Math.round((rhoVal + maxDistance) / rho);\n        \n        if (rhoIdx >= 0 && rhoIdx < numRho * 2) {\n          accumulator[rhoIdx][thetaIdx]++;\n        }\n      }\n    }\n  }\n  \n  // Find local maxima in the accumulator\n  const lines: Line[] = [];\n  \n  for (let rhoIdx = 0; rhoIdx < numRho * 2; rhoIdx++) {\n    for (let thetaIdx = 0; thetaIdx < numTheta; thetaIdx++) {\n      if (accumulator[rhoIdx][thetaIdx] >= threshold) {\n        // Convert back to original space\n        const thetaVal = thetaIdx * theta;\n        const rhoVal = (rhoIdx * rho) - maxDistance;\n        \n        // Find points along this line\n        const cos = Math.cos(thetaVal);\n        const sin = Math.sin(thetaVal);\n        \n        // Find endpoints\n        // This is a simplified approach compared to HoughLinesP\n        // We'll just find two points on the line at the image boundaries\n        \n        // For vertical-ish lines\n        if (Math.abs(sin) > 0.001) {\n          // y = (rho - x*cos) / sin\n          const x1 = 0;\n          const y1 = Math.round(rhoVal / sin);\n          const x2 = width - 1;\n          const y2 = Math.round((rhoVal - x2 * cos) / sin);\n          \n          if (y1 >= 0 && y1 < height && y2 >= 0 && y2 < height) {\n            lines.push({ x1, y1, x2, y2 });\n          }\n        } \n        // For horizontal-ish lines\n        else if (Math.abs(cos) > 0.001) {\n          // x = (rho - y*sin) / cos\n          const y1 = 0;\n          const x1 = Math.round(rhoVal / cos);\n          const y2 = height - 1;\n          const x2 = Math.round((rhoVal - y2 * sin) / cos);\n          \n          if (x1 >= 0 && x1 < width && x2 >= 0 && x2 < width) {\n            lines.push({ x1, y1, x2, y2 });\n          }\n        }\n      }\n    }\n  }\n  \n  // Filter lines that are too short\n  return lines.filter(line => {\n    const dx = line.x2 - line.x1;\n    const dy = line.y2 - line.y1;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    return length >= minLineLength;\n  });\n}\n\n/**\n * Improved function to extract wall points from a skeleton image\n * Returns all foreground pixels from the image\n */\nfunction extractWallPoints(imageData: ImageData): Point[] {\n  const { width, height, data } = imageData;\n  const points: Point[] = [];\n  \n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const idx = (y * width + x) * 4;\n      if (data[idx] > 0) {\n        points.push({ x, y });\n      }\n    }\n  }\n  \n  return points;\n}\n\n/**\n * Calculate distance from point to line\n */\nfunction distToLine(point: Point, lineStart: Point, lineEnd: Point): number {\n  const { x, y } = point;\n  const { x: x1, y: y1 } = lineStart;\n  const { x: x2, y: y2 } = lineEnd;\n  \n  // Line length\n  const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n  \n  // If line is actually a point\n  if (length === 0) return Math.sqrt((x - x1) ** 2 + (y - y1) ** 2);\n  \n  // Calculate distance from point to line\n  const t = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / (length * length);\n  \n  if (t < 0) {\n    return Math.sqrt((x - x1) ** 2 + (y - y1) ** 2);\n  } else if (t > 1) {\n    return Math.sqrt((x - x2) ** 2 + (y - y2) ** 2);\n  }\n  \n  const projX = x1 + t * (x2 - x1);\n  const projY = y1 + t * (y2 - y1);\n  \n  return Math.sqrt((x - projX) ** 2 + (y - projY) ** 2);\n}\n\n/**\n * Improved function to connect wall points into line segments\n * This is a more robust version that works better with real floorplan data\n */\nexport function connectWallPoints(\n  wallPoints: Point[],\n  maxDistance: number = 5\n): Line[] {\n  if (wallPoints.length < 2) return [];\n  \n  const lines: Line[] = [];\n  const visited = new Set<number>();\n  \n  // Use a sliding neighborhood approach to find aligned points\n  for (let i = 0; i < wallPoints.length; i++) {\n    if (visited.has(i)) continue;\n    \n    const p1 = wallPoints[i];\n    visited.add(i);\n    \n    // Try each possible angle (quantized to improve performance)\n    for (let angle = 0; angle < Math.PI; angle += Math.PI / 16) {\n      const cos = Math.cos(angle);\n      const sin = Math.sin(angle);\n      \n      // Points that might belong to this line\n      const linePoints: Point[] = [p1];\n      \n      // Find points that align with this angle starting from p1\n      for (let j = 0; j < wallPoints.length; j++) {\n        if (i === j || visited.has(j)) continue;\n        \n        const p2 = wallPoints[j];\n        \n        // Calculate how well this point aligns with our angle from p1\n        const dx = p2.x - p1.x;\n        const dy = p2.y - p1.y;\n        \n        // Project the vector onto our angle direction\n        const proj = dx * cos + dy * sin;\n        \n        // Calculate perpendicular distance\n        // For a line with direction (cos, sin) passing through p1,\n        // the perpendicular distance from p2 is |dx*sin - dy*cos|\n        const perpDist = Math.abs(dx * sin - dy * cos);\n        \n        // If the point is close to our line and in the direction of our angle\n        if (perpDist <= maxDistance) {\n          linePoints.push(p2);\n        }\n      }\n      \n      // If we found enough points for a line\n      if (linePoints.length >= 3) { // minimum points for a meaningful line\n        // Sort points by their projection along the angle\n        linePoints.sort((a, b) => {\n          const projA = (a.x - p1.x) * cos + (a.y - p1.y) * sin;\n          const projB = (b.x - p1.x) * cos + (b.y - p1.y) * sin;\n          return projA - projB;\n        });\n        \n        // Take the first and last point as endpoints\n        const first = linePoints[0];\n        const last = linePoints[linePoints.length - 1];\n        \n        // Mark all these points as visited\n        for (let j = 1; j < linePoints.length - 1; j++) {\n          const pointIndex = wallPoints.findIndex(p => \n            p.x === linePoints[j].x && p.y === linePoints[j].y);\n          \n          if (pointIndex >= 0) {\n            visited.add(pointIndex);\n          }\n        }\n        \n        // Add line\n        lines.push({\n          x1: first.x,\n          y1: first.y,\n          x2: last.x,\n          y2: last.y\n        });\n        \n        // Once we find a good line with this starting point, move on\n        break;\n      }\n    }\n  }\n  \n  return lines;\n}\n\n/**\n * Detect straight walls in a skeletonized image using an improved approach\n * that better handles actual wall segments in a floorplan\n */\nexport function detectStraightWallsHough(\n  skelImageData: ImageData,\n  threshold: number = 50,\n  minLineLength: number = 50,\n  maxLineGap: number = 10,\n  cornerPoints: Point[] = []\n): Line[] {\n  // Enhanced wall detection\n  \n  // First, try the direct point-based approach if we have corner points\n  if (cornerPoints.length >= 2) {\n    // Try to connect corner points directly\n    const lines: Line[] = [];\n    const maxDist = maxLineGap * 3; // Allow for larger gaps between corner points\n    \n    // Function to check if a line between points is valid (has foreground pixels)\n    const checkValidLine = (p1: Point, p2: Point): boolean => {\n      // Sample points along the line and check if enough of them are foreground\n      const dx = p2.x - p1.x;\n      const dy = p2.y - p1.y;\n      const dist = Math.sqrt(dx*dx + dy*dy);\n      const steps = Math.max(5, Math.ceil(dist / 5)); // Sample every 5 pixels\n      \n      let foregroundCount = 0;\n      for (let i = 0; i <= steps; i++) {\n        const t = i / steps;\n        const x = Math.round(p1.x + t * dx);\n        const y = Math.round(p1.y + t * dy);\n        \n        if (x >= 0 && x < skelImageData.width && y >= 0 && y < skelImageData.height) {\n          const idx = (y * skelImageData.width + x) * 4;\n          if (skelImageData.data[idx] > 0) {\n            foregroundCount++;\n          }\n        }\n      }\n      \n      // Return true if at least 40% of sampled points are foreground\n      return foregroundCount >= (steps * 0.4);\n    };\n    \n    // Try to connect all corner point pairs that are close enough\n    for (let i = 0; i < cornerPoints.length; i++) {\n      for (let j = i + 1; j < cornerPoints.length; j++) {\n        const p1 = cornerPoints[i];\n        const p2 = cornerPoints[j];\n        \n        const dist = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);\n        \n        // Only connect points within a reasonable distance\n        if (dist <= maxDist && checkValidLine(p1, p2)) {\n          lines.push({\n            x1: p1.x,\n            y1: p1.y,\n            x2: p2.x,\n            y2: p2.y\n          });\n        }\n      }\n    }\n    \n    // If we found lines with corner points, return them\n    if (lines.length > 0) {\n      console.log(`[INFO] Generated ${lines.length} lines using corner points directly`);\n      return lines;\n    }\n  }\n\n  // Extract all wall points from the skeleton\n  const wallPoints = extractWallPoints(skelImageData);\n  \n  if (wallPoints.length > 0) {\n    // Try our enhanced point-connection approach\n    const maxDistance = Math.max(2, Math.min(5, maxLineGap / 2));\n    const lines = connectWallPoints(wallPoints, maxDistance);\n    \n    // Filter lines that are too short\n    const filteredLines = lines.filter(line => {\n      const dx = line.x2 - line.x1;\n      const dy = line.y2 - line.y1;\n      const length = Math.sqrt(dx * dx + dy * dy);\n      return length >= minLineLength;\n    });\n    \n    console.log(`[INFO] Connected ${filteredLines.length} wall lines from ${wallPoints.length} points`);\n    \n    // If we found enough lines with our enhanced approach, return them\n    if (filteredLines.length >= 3) {\n      return filteredLines;\n    }\n  }\n  \n  // Fallback to Hough transform for complex cases\n  console.log(\"[INFO] Falling back to Hough transform for line detection\");\n  \n  // First, apply edge detection (though our skeleton is already edges)\n  const edges = cannyEdgeDetection(skelImageData, 50, 150);\n  \n  // Then detect lines using Hough Transform\n  const lines = houghLinesP(\n    edges,\n    1,\n    Math.PI / 180,\n    threshold,\n    minLineLength,\n    maxLineGap\n  );\n  \n  return lines;\n}\n\n/**\n * Draw detected lines on an image\n */\nexport function drawLines(imageData: ImageData, lines: Line[], color: [number, number, number] = [0, 255, 0]): void {\n  const { width, height, data } = imageData;\n  \n  for (const line of lines) {\n    const { x1, y1, x2, y2 } = line;\n    \n    // Bresenham's line algorithm\n    let x = x1;\n    let y = y1;\n    \n    const dx = Math.abs(x2 - x1);\n    const dy = Math.abs(y2 - y1);\n    const sx = x1 < x2 ? 1 : -1;\n    const sy = y1 < y2 ? 1 : -1;\n    let err = dx - dy;\n    \n    while (true) {\n      // Check bounds\n      if (x >= 0 && x < width && y >= 0 && y < height) {\n        // Draw line pixel (make it thick - 3px wide)\n        for (let ky = -1; ky <= 1; ky++) {\n          for (let kx = -1; kx <= 1; kx++) {\n            const px = x + kx;\n            const py = y + ky;\n            \n            if (px >= 0 && px < width && py >= 0 && py < height) {\n              const idx = (py * width + px) * 4;\n              data[idx] = color[0];\n              data[idx + 1] = color[1];\n              data[idx + 2] = color[2];\n            }\n          }\n        }\n      }\n      \n      if (x === x2 && y === y2) break;\n      \n      const e2 = 2 * err;\n      if (e2 > -dy) {\n        err -= dy;\n        x += sx;\n      }\n      if (e2 < dx) {\n        err += dx;\n        y += sy;\n      }\n    }\n  }\n}"],
  "mappings": "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",
  "names": ["imageToImageData", "img", "canvas", "ctx", "convertToGrayscale", "imageData", "data", "width", "height", "grayscaleData", "i", "gray", "threshold", "inverse", "resultData", "value", "erode", "kernelSize", "result", "halfKernel", "tempCanvas", "tempCtx", "sourceImageData", "y", "x", "minValue", "ky", "kx", "pos", "dilate", "maxValue", "morphologicalOpen", "eroded", "morphologicalClose", "dilated", "morphologicalThinning", "current", "changed", "iterations", "maxIterations", "markedPoints", "p", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "values", "nonZeroNeighbors", "a", "b", "transitions", "val", "skeletonizeImage", "imageSource", "threshVal", "loadImage", "originalWidth", "originalHeight", "grayImageData", "binaryImageData", "openedImageData", "closedImageData", "skelImageData", "src", "resolve", "reject", "renderImageDataToCanvas", "classifyPoint", "neighborhood", "pattern", "neighbors", "sum", "val", "transitions", "i", "patternString", "p", "getNeighborhood", "imageData", "x", "y", "width", "height", "data", "dy", "dx", "srcIdx", "dstIdx", "detectCorners", "skelImageData", "maxCorners", "qualityLevel", "minDistance", "importantPoints", "idx", "pointType", "clusterPoints", "points", "numClusters", "k", "clusters", "usedIndices", "changed", "MAX_ITERATIONS", "iterations", "assignments", "sums", "point", "minDist", "minIdx", "j", "cluster", "dist", "clusterIdx", "_", "drawClusteredPoints", "clusteredPoints", "draw", "color", "px", "py", "cannyEdgeDetection", "imageData", "lowThreshold", "highThreshold", "width", "height", "data", "result", "i", "val", "houghLinesP", "rho", "theta", "threshold", "minLineLength", "maxLineGap", "maxDistance", "numRho", "numTheta", "accumulator", "y", "x", "idx", "thetaIdx", "thetaVal", "rhoVal", "rhoIdx", "lines", "cos", "sin", "y1", "x2", "y2", "x1", "line", "dx", "dy", "extractWallPoints", "points", "connectWallPoints", "wallPoints", "maxDistance", "lines", "visited", "i", "p1", "angle", "cos", "sin", "linePoints", "j", "p2", "dx", "dy", "proj", "a", "b", "projA", "projB", "first", "last", "pointIndex", "p", "detectStraightWallsHough", "skelImageData", "threshold", "minLineLength", "maxLineGap", "cornerPoints", "maxDist", "checkValidLine", "dist", "steps", "foregroundCount", "t", "x", "y", "idx", "extractWallPoints", "filteredLines", "line", "edges", "cannyEdgeDetection", "houghLinesP", "drawLines", "imageData", "color", "width", "height", "data", "x1", "y1", "x2", "y2", "sx", "sy", "err", "ky", "kx", "px", "py", "e2"]
}
