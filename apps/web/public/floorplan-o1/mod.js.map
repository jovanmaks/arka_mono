{
  "version": 3,
  "sources": ["../../../../packages/floorplan-o1/types.ts", "../../../../packages/floorplan-o1/image-processor.ts", "../../../../packages/floorplan-o1/skeletonize.ts", "../../../../packages/floorplan-o1/feature-detection.ts", "../../../../packages/floorplan-o1/intersection-detection.ts", "../../../../packages/floorplan-o1/visualization.ts"],
  "sourcesContent": ["/**\n * Type definitions for the Floorplan O1 processor\n */\n\n/**\n * Represents a point in 2D space\n */\nexport type Point = { \n  x: number; \n  y: number;\n  type?: PointType; \n  count?: number; // For tracking cluster sizes\n};\n\n/**\n * Represents a line segment between two points\n */\nexport type LineSegment = { \n  x1: number; \n  y1: number; \n  x2: number; \n  y2: number;\n};\n\n/**\n * Types of points based on their position in the floorplan\n */\nexport enum PointType {\n  CORNER = 'corner',\n  ENDPOINT = 'endpoint',\n  T_JUNCTION = 't_junction',\n  INTERSECTION = 'intersection',\n  UNCLASSIFIED = 'unclassified'\n}\n\n/**\n * Result of the skeletonization process\n */\nexport interface SkeletonResult {\n  skeleton: ImageData;\n  originalWidth: number;\n  originalHeight: number;\n  debugInfo: {\n    thresholdValue: number;\n    algorithm: string;\n  }\n}\n\n/**\n * Options for preprocessing and skeletonization\n */\nexport interface ProcessingOptions {\n  threshold?: number;\n  inverse?: boolean;\n  maxIterations?: number;\n}\n\n/**\n * Options for corner and feature detection\n */\nexport interface DetectionOptions {\n  minNeighbors?: number;\n  minTransitions?: number;\n  includeTypes?: PointType[]; // Types of points to include in detection\n}\n\n/**\n * Options for line detection\n */\nexport interface LineDetectionOptions {\n  threshold?: number;\n  minLineLength?: number;\n  maxLineGap?: number;\n  maxDistance?: number;\n}\n\n/**\n * Options for clustering points\n */\nexport interface ClusterOptions {\n  maxDistance?: number;\n  distanceThreshold?: number; // Maximum distance threshold for including points in clustering\n  minClusterSize?: number;   // Minimum number of points in a cluster to be considered valid\n  validateWalls?: boolean;   // Whether to validate that clusters are actually on walls\n  preserveTypes?: boolean;   // Whether to group points by type before clustering\n}", "/**\n * Image processing utilities for the Floorplan O1 implementation\n */\nimport { ProcessingOptions } from \"./types.ts\";\n\n/**\n * Convert an HTML Image element to a canvas and get its ImageData\n */\nexport function imageToImageData(img: HTMLImageElement): ImageData {\n  const canvas = document.createElement('canvas');\n  canvas.width = img.width;\n  canvas.height = img.height;\n  const ctx = canvas.getContext('2d');\n  \n  if (!ctx) {\n    throw new Error('Could not get canvas context');\n  }\n  \n  ctx.drawImage(img, 0, 0);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\n\n/**\n * Loads an image from a File or URL into an Image object\n */\nexport function loadImage(src: string | File): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = \"Anonymous\"; // Allow cross-origin images if URL\n    \n    img.onload = () => resolve(img);\n    img.onerror = () => reject(new Error('Failed to load image'));\n    \n    if (typeof src === 'string') {\n      img.src = src;\n    } else {\n      img.src = URL.createObjectURL(src);\n    }\n  });\n}\n\n/**\n * Converts an ImageData to grayscale\n */\nexport function convertToGrayscale(imageData: ImageData): ImageData {\n  const { width, height, data } = imageData;\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d')!;\n  const grayImageData = ctx.createImageData(width, height);\n  const grayData = grayImageData.data;\n  \n  // Convert to grayscale\n  for (let i = 0; i < data.length; i += 4) {\n    // Standard grayscale conversion: 0.299*R + 0.587*G + 0.114*B\n    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];\n    \n    grayData[i] = gray;     // R\n    grayData[i + 1] = gray; // G\n    grayData[i + 2] = gray; // B\n    grayData[i + 3] = data[i + 3]; // Keep original alpha\n  }\n  \n  return grayImageData;\n}\n\n/**\n * Converts an ImageData to grayscale and applies binary thresholding.\n */\nexport function thresholdImage(\n  imageData: ImageData, \n  threshold: number = 128, \n  inverse: boolean = true\n): ImageData {\n  const { width, height, data } = imageData;\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d')!;\n  const binImageData = ctx.createImageData(width, height);\n  const binData = binImageData.data;\n  \n  // Convert to grayscale and threshold\n  for (let i = 0; i < data.length; i += 4) {\n    // Get luminance if not already grayscale\n    const gray = data[i] === data[i + 1] && data[i] === data[i + 2] \n      ? data[i] \n      : 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];\n      \n    // Apply threshold (with option to invert)\n    const val = inverse ? \n      (gray < threshold ? 255 : 0) : \n      (gray > threshold ? 255 : 0);\n    \n    binData[i] = val;     // R\n    binData[i + 1] = val; // G\n    binData[i + 2] = val; // B\n    binData[i + 3] = 255; // A (fully opaque)\n  }\n  \n  return binImageData;\n}\n\n/**\n * Renders an ImageData to a canvas\n */\nexport function renderImageDataToCanvas(imageData: ImageData, canvas: HTMLCanvasElement): void {\n  canvas.width = imageData.width;\n  canvas.height = imageData.height;\n  \n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    throw new Error('Could not get canvas context');\n  }\n  \n  ctx.putImageData(imageData, 0, 0);\n}\n\n/**\n * Preprocesses an image for floorplan analysis\n * Performs grayscale conversion and thresholding\n */\nexport function preprocessImage(\n  imageData: ImageData, \n  options?: ProcessingOptions\n): ImageData {\n  const threshold = options?.threshold || 128;\n  const inverse = options?.inverse !== undefined ? options.inverse : true;\n  \n  // Apply thresholding directly\n  return thresholdImage(imageData, threshold, inverse);\n}", "/**\n * Skeletonization implementation using Zhang-Suen thinning algorithm\n */\nimport { ProcessingOptions, SkeletonResult } from \"./types.ts\";\nimport { imageToImageData, loadImage, preprocessImage } from \"./image-processor.ts\";\n\n/**\n * Performs morphological thinning (skeletonization) on a binary ImageData.\n * Uses the Zhang-Suen algorithm to reduce lines to 1-pixel thickness.\n */\nexport function zhangSuenThinning(\n  imageData: ImageData, \n  maxIterations: number = 100\n): ImageData {\n  const { width, height, data } = imageData;\n  \n  // Create a copy of the input data for processing\n  const input = new Uint8ClampedArray(data);\n  \n  // Helper: get pixel value (1 for foreground, 0 for background)\n  const getPixel = (x: number, y: number): number => {\n    if (x < 0 || y < 0 || x >= width || y >= height) return 0;\n    const idx = (y * width + x) * 4;\n    return input[idx] > 0 ? 1 : 0;\n  };\n  \n  // Helper: set pixel value\n  const setPixel = (x: number, y: number, value: number): void => {\n    const idx = (y * width + x) * 4;\n    const val = value > 0 ? 255 : 0;\n    input[idx] = input[idx + 1] = input[idx + 2] = val;\n  };\n  \n  let pixelsRemoved = true;\n  let iterations = 0;\n  \n  while (pixelsRemoved && iterations < maxIterations) {\n    pixelsRemoved = false;\n    iterations++;\n    \n    // First sub-iteration\n    const toRemove1: [number, number][] = [];\n    \n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        if (getPixel(x, y) === 0) continue; // Skip background pixels\n        \n        // Get 8 neighbors (clockwise from top)\n        const p2 = getPixel(x, y-1);   // North\n        const p3 = getPixel(x+1, y-1); // Northeast\n        const p4 = getPixel(x+1, y);   // East\n        const p5 = getPixel(x+1, y+1); // Southeast\n        const p6 = getPixel(x, y+1);   // South\n        const p7 = getPixel(x-1, y+1); // Southwest\n        const p8 = getPixel(x-1, y);   // West\n        const p9 = getPixel(x-1, y-1); // Northwest\n        \n        const neighbors = [p2, p3, p4, p5, p6, p7, p8, p9];\n        \n        // Count foreground neighbors\n        const neighborSum = neighbors.reduce((sum, val) => sum + val, 0);\n        if (neighborSum < 2 || neighborSum > 6) continue;\n        \n        // Count 0->1 transitions in the ordered sequence\n        let transitions = 0;\n        for (let i = 0; i < neighbors.length; i++) {\n          if (neighbors[i] === 0 && neighbors[(i + 1) % neighbors.length] === 1) {\n            transitions++;\n          }\n        }\n        if (transitions !== 1) continue;\n        \n        // Check first sub-iteration conditions\n        // At least one of North, East, South is background\n        if (p2 * p4 * p6 !== 0) continue;\n        \n        // At least one of East, South, West is background\n        if (p4 * p6 * p8 !== 0) continue;\n        \n        // Mark for deletion\n        toRemove1.push([x, y]);\n      }\n    }\n    \n    // Apply first sub-iteration deletions\n    for (const [x, y] of toRemove1) {\n      setPixel(x, y, 0);\n      pixelsRemoved = true;\n    }\n    \n    // Second sub-iteration\n    const toRemove2: [number, number][] = [];\n    \n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        if (getPixel(x, y) === 0) continue;\n        \n        // Get 8 neighbors (clockwise from top)\n        const p2 = getPixel(x, y-1);   // North\n        const p3 = getPixel(x+1, y-1); // Northeast\n        const p4 = getPixel(x+1, y);   // East\n        const p5 = getPixel(x+1, y+1); // Southeast\n        const p6 = getPixel(x, y+1);   // South\n        const p7 = getPixel(x-1, y+1); // Southwest\n        const p8 = getPixel(x-1, y);   // West\n        const p9 = getPixel(x-1, y-1); // Northwest\n        \n        const neighbors = [p2, p3, p4, p5, p6, p7, p8, p9];\n        \n        // Count foreground neighbors\n        const neighborSum = neighbors.reduce((sum, val) => sum + val, 0);\n        if (neighborSum < 2 || neighborSum > 6) continue;\n        \n        // Count 0->1 transitions in the ordered sequence\n        let transitions = 0;\n        for (let i = 0; i < neighbors.length; i++) {\n          if (neighbors[i] === 0 && neighbors[(i + 1) % neighbors.length] === 1) {\n            transitions++;\n          }\n        }\n        if (transitions !== 1) continue;\n        \n        // Check second sub-iteration conditions\n        // At least one of North, East, West is background\n        if (p2 * p4 * p8 !== 0) continue;\n        \n        // At least one of North, South, West is background\n        if (p2 * p6 * p8 !== 0) continue;\n        \n        // Mark for deletion\n        toRemove2.push([x, y]);\n      }\n    }\n    \n    // Apply second sub-iteration deletions\n    for (const [x, y] of toRemove2) {\n      setPixel(x, y, 0);\n      pixelsRemoved = true;\n    }\n  }\n  \n  console.log(`[DEBUG] Thinning completed after ${iterations} iterations`);\n  \n  // Create output ImageData\n  const result = new Uint8ClampedArray(input);\n  return new ImageData(result, width, height);\n}\n\n/**\n * Main function to skeletonize an image using the Zhang-Suen thinning algorithm\n */\nexport async function skeletonizeImage(\n  imageSource: HTMLImageElement | string | File,\n  options?: ProcessingOptions  \n): Promise<SkeletonResult> {\n  // Load the image if it's a string URL or blob\n  const img = imageSource instanceof HTMLImageElement \n    ? imageSource \n    : await loadImage(imageSource);\n  \n  const originalWidth = img.width;\n  const originalHeight = img.height;\n  \n  console.log(`[DEBUG] Original (H\u00D7W): ${originalHeight} \u00D7 ${originalWidth}`);\n  \n  // 1. Convert to ImageData\n  const imageData = imageToImageData(img);\n  \n  // 2. Preprocess the image (convert to grayscale and threshold)\n  const threshold = options?.threshold ?? 128;\n  const inverse = options?.inverse ?? true;\n  const binaryImageData = preprocessImage(imageData, { threshold, inverse });\n  console.log('[DEBUG] After preprocessing (grayscale + threshold)');\n  \n  // 3. Apply Zhang-Suen thinning algorithm for skeletonization\n  const maxIterations = options?.maxIterations ?? 100;\n  const skelImageData = zhangSuenThinning(binaryImageData, maxIterations);\n  console.log('[DEBUG] After thinning with Zhang-Suen algorithm');\n  \n  // 4. Return the processed image with metadata\n  return {\n    skeleton: skelImageData,\n    originalWidth,\n    originalHeight,\n    debugInfo: {\n      thresholdValue: threshold,\n      algorithm: \"Zhang-Suen thinning algorithm\"\n    }\n  };\n}", "/**\n * Feature detection functions for the floorplan processor\n */\nimport { Point, DetectionOptions, LineDetectionOptions, ClusterOptions, LineSegment, PointType } from \"./types.ts\";\n\n/**\n * Classifies a point based on its neighborhood pattern\n * Enhanced to better detect junctions, corners and endpoints\n * \n * @param neighborhood A 3x3 array of pixel values (0 or 255)\n * @returns The point type\n */\nexport function classifyJunctionType(neighborhood: number[]): PointType {\n  // Count total foreground neighbors\n  const neighbors = neighborhood.reduce((sum, val) => sum + val, 0);\n  \n  // Count transitions from 0 to 1\n  let transitions = 0;\n  for (let i = 0; i < neighborhood.length; i++) {\n    if (neighborhood[i] === 0 && neighborhood[(i + 1) % neighborhood.length] === 1) {\n      transitions++;\n    }\n  }\n  \n  // Create a continuous pattern string for easier pattern matching\n  const patternString = neighborhood.join('') + neighborhood[0]; // Add first element to end for circular pattern\n  \n  // Enhanced endpoint detection - more permissive to catch more endpoints\n  if (neighbors === 1 || (neighbors === 2 && transitions >= 2)) {\n    // Basic endpoint case: only one neighbor\n    if (neighbors === 1) {\n      return PointType.ENDPOINT;\n    }\n    \n    // Special case for endpoints with 2 neighbors that might be part of thin lines\n    // Check if they're adjacent which would suggest it's part of a thin line end\n    for (let i = 0; i < neighborhood.length; i++) {\n      if (neighborhood[i] === 1 && neighborhood[(i + 1) % 8] === 1) {\n        return PointType.ENDPOINT;\n      }\n    }\n  }\n  \n  // Enhanced corner detection (L-junction) - MORE RESTRICTIVE\n  if (neighbors === 2) {\n    if (transitions === 2) {\n      // Check if the two branches are adjacent for a real corner\n      // Non-adjacent branches indicate a straight line segment, not a corner\n      for (let i = 0; i < neighborhood.length; i++) {\n        if (neighborhood[i] === 1 && neighborhood[(i + 1) % 8] === 1) {\n          return PointType.UNCLASSIFIED; // Adjacent branches indicate a potential line segment\n        }\n      }\n      \n      // Two non-adjacent branches with transition count 2 is a corner\n      // Only check specific L-corner patterns (90-degree angles)\n      const exactCornerPatterns = [\n        [1, 0, 0, 0, 0, 1, 0, 0], // \u250C pattern (North-East)\n        [0, 1, 0, 0, 0, 0, 1, 0], // \u2510 pattern (East-South)\n        [0, 0, 1, 0, 0, 0, 0, 1], // \u2514 pattern (South-West)\n        [0, 0, 0, 1, 1, 0, 0, 0]  // \u2518 pattern (West-North)\n      ];\n      \n      // Check if the neighborhood matches any of these exact patterns\n      const matchesExactPattern = exactCornerPatterns.some(pattern => {\n        for (let i = 0; i < 8; i++) {\n          if (pattern[i] !== neighborhood[i]) {\n            return false;\n          }\n        }\n        return true;\n      });\n      \n      if (matchesExactPattern) {\n        return PointType.CORNER;\n      }\n      \n      return PointType.UNCLASSIFIED; // Not a recognized corner pattern\n    }\n    \n    // Check for specific corner patterns - STRICT MATCHING\n    // Look for two branches that are exactly 90\u00B0 apart\n    const cornerPatterns = [\n      '10000100', // \u250C pattern (North-East)\n      '01000010', // \u2510 pattern (East-South)\n      '00100001', // \u2514 pattern (South-West)\n      '00010001'  // \u2518 pattern (West-North)\n    ];\n    \n    // Only exact matches, not substring matches\n    if (cornerPatterns.includes(neighborhood.join(''))) {\n      return PointType.CORNER;\n    }\n  }\n  \n  // Enhanced T-junction detection\n  if (neighbors === 3) {\n    if (transitions === 2) {\n      return PointType.T_JUNCTION;\n    }\n    \n    // Check for additional T-junction patterns\n    const tPatterns = [\n      '10001000', // \u252C pattern\n      '01000100', // \u2524 pattern\n      '00100010', // \u2534 pattern\n      '00010001'  // \u251C pattern\n    ];\n    if (tPatterns.some(p => patternString.includes(p))) {\n      return PointType.T_JUNCTION;\n    }\n  }\n  \n  // Handle complex junctions with 4 or more branches\n  if (neighbors >= 4 && transitions >= 2) {\n    return PointType.INTERSECTION; \n  }\n  \n  return PointType.UNCLASSIFIED;\n}\n\n/**\n * Extract a 3x3 neighborhood from ImageData at position (x,y)\n */\nfunction getNeighborhood(imageData: ImageData, x: number, y: number): number[] {\n  const { width, height, data } = imageData;\n  \n  // Check bounds\n  if (x < 1 || y < 1 || x >= width - 1 || y >= height - 1) {\n    return [];\n  }\n  \n  // Extract 3x3 neighborhood as binary values (0 or 1)\n  const neighborhood: number[] = [];\n  \n  // Top-left to bottom-right in clockwise order, excluding center\n  const offsets = [\n    [-1, -1], [0, -1], [1, -1], [1, 0],\n    [1, 1], [0, 1], [-1, 1], [-1, 0]\n  ];\n  \n  for (const [dx, dy] of offsets) {\n    const nx = x + dx;\n    const ny = y + dy;\n    const idx = (ny * width + nx) * 4;\n    neighborhood.push(data[idx] > 0 ? 1 : 0);\n  }\n  \n  return neighborhood;\n}\n\n/**\n * Detects corner points and other junctions in a binary image using advanced pattern recognition.\n * Enhanced to better preserve endpoint detection.\n * \n * @param imageData - Skeletonized binary image\n * @param options - Detection options\n * @returns Array of detected junction points {x, y, type}\n */\nexport function detectCorners(\n  imageData: ImageData, \n  options: DetectionOptions = {}\n): Point[] {\n  const { width, height, data } = imageData;\n  const corners: Point[] = [];\n  const endpointMap = new Map<string, Point>(); // Track endpoints by position\n  \n  // Default parameter values\n  const minNeighbors = options.minNeighbors ?? 1; // Lower this to catch more points\n  const minTransitions = options.minTransitions ?? 1; // Lower this to catch more points\n  const includeTypes = options.includeTypes ?? [\n    PointType.CORNER, \n    PointType.T_JUNCTION, \n    PointType.ENDPOINT, \n    PointType.INTERSECTION\n  ];\n  \n  // Scan the image for all foreground pixels\n  for (let y = 1; y < height - 1; y++) {\n    for (let x = 1; x < width - 1; x++) {\n      const idx = (y * width + x) * 4;\n      \n      // Skip background pixels\n      if (data[idx] === 0) continue;\n      \n      // Get neighborhood\n      const neighborhood = getNeighborhood(imageData, x, y);\n      if (neighborhood.length === 0) continue;\n      \n      // Count foreground neighbors\n      const neighborCount = neighborhood.reduce((sum, val) => sum + val, 0);\n      \n      // For endpoints, we're more lenient with minimum neighbors\n      const pointType = classifyJunctionType(neighborhood);\n      \n      // Special handling for endpoints\n      if (pointType === PointType.ENDPOINT) {\n        if (includeTypes.includes(PointType.ENDPOINT)) {\n          const key = `${x},${y}`;\n          endpointMap.set(key, { x, y, type: PointType.ENDPOINT });\n        }\n        continue; // Skip other checks for endpoints\n      }\n      \n      // For non-endpoints, apply standard filtering\n      if (neighborCount < minNeighbors) continue;\n      \n      // Count transitions\n      let transitions = 0;\n      for (let i = 0; i < neighborhood.length; i++) {\n        if (neighborhood[i] === 0 && neighborhood[(i + 1) % 8] === 1) {\n          transitions++;\n        }\n      }\n      if (transitions < minTransitions) continue;\n      \n      // Add point if it's of a requested type\n      if (includeTypes.includes(pointType)) {\n        corners.push({ x, y, type: pointType });\n      }\n    }\n  }\n  \n  // Add all detected endpoints to the corners array\n  corners.push(...endpointMap.values());\n  \n  console.log(`[DEBUG] Detected ${corners.length} corner candidates (including endpoints: ${endpointMap.size})`);\n  return corners;\n}\n\n/**\n * Clusters nearby points into a single point using distance-based clustering.\n * Enhanced version with aggressive merging to handle noise in the floorplan.\n * \n * @param points - Array of points {x, y, type}\n * @param options - Clustering options\n * @returns Array of clustered points (centroids)\n */\nexport function clusterPoints(\n  points: Point[], \n  options: ClusterOptions = {}\n): Point[] {\n  if (points.length === 0) return [];\n\n  // Configuration parameters with more aggressive defaults\n  const maxDistance = options.maxDistance ?? 10;  // Increased from 10\n  const distanceThreshold = options.distanceThreshold ?? 30; \n  const minClusterSize = options.minClusterSize ?? 1;\n  const preserveTypes = options.preserveTypes ?? false; // Force false to ensure merging different types\n\n  console.log(`[DEBUG] Clustering with maxDistance=${maxDistance}, preserveTypes=${preserveTypes}`);\n  \n  // STEP 1: First pass - aggressively merge very close points regardless of type\n  // This handles the case where we have multiple points very close to each other\n  // representing the same physical corner but classified as different junction types\n  const tightRadius = Math.max(8, maxDistance / 2); // Increased from 5 to 8\n  \n  console.log(`[DEBUG] Initial tight clustering with radius=${tightRadius}`);\n  \n  // Build a distance matrix for quick lookup\n  const distMatrix: number[][] = [];\n  for (let i = 0; i < points.length; i++) {\n    distMatrix[i] = [];\n    for (let j = 0; j < points.length; j++) {\n      const dx = points[i].x - points[j].x;\n      const dy = points[i].y - points[j].y;\n      distMatrix[i][j] = Math.sqrt(dx*dx + dy*dy);\n    }\n  }\n  \n  // Initial clustering - assign each point to a cluster\n  const initialClusters: number[][] = [];\n  const assignedPoints = new Set<number>();\n  \n  for (let i = 0; i < points.length; i++) {\n    if (assignedPoints.has(i)) continue;\n    \n    const cluster: number[] = [i];\n    assignedPoints.add(i);\n    \n    for (let j = 0; j < points.length; j++) {\n      if (i === j || assignedPoints.has(j)) continue;\n      \n      if (distMatrix[i][j] <= tightRadius) {\n        cluster.push(j);\n        assignedPoints.add(j);\n      }\n    }\n    \n    initialClusters.push(cluster);\n  }\n  \n  console.log(`[DEBUG] Initial clustering: ${initialClusters.length} clusters from ${points.length} points`);\n  \n  // STEP 2: Second pass - merge the initial clusters if they're close enough\n  // Only apply type-based preservation if explicitly requested\n  let finalClusters: (Point[] | null)[] = [];\n  \n  if (preserveTypes) {\n    // Group initial clusters by type first\n    const pointsByType: Record<string, Point[]> = {};\n    \n    for (const cluster of initialClusters) {\n      // Determine the dominant type in this cluster\n      const typeCounts: Record<string, number> = {};\n      \n      for (const idx of cluster) {\n        const pointType = points[idx].type || PointType.UNCLASSIFIED;\n        typeCounts[pointType] = (typeCounts[pointType] || 0) + 1;\n      }\n      \n      // Find the most frequent type\n      let dominantType = PointType.UNCLASSIFIED;\n      let maxCount = 0;\n      for (const type in typeCounts) {\n        if (typeCounts[type] > maxCount) {\n          maxCount = typeCounts[type];\n          dominantType = type as PointType;\n        }\n      }\n      \n      // Create the point cluster with the average position\n      const clusterPoints = cluster.map(idx => points[idx]);\n      \n      if (!pointsByType[dominantType]) {\n        pointsByType[dominantType] = [];\n      }\n      pointsByType[dominantType].push(...clusterPoints);\n    }\n    \n    // Process each type separately\n    for (const type in pointsByType) {\n      const typePoints = pointsByType[type];\n      \n      // Create clusters for this type\n      finalClusters.push(...typePoints.map(p => [p]));\n    }\n  } else {\n    // Don't preserve types - just create clusters from the initial groupings\n    finalClusters = initialClusters.map(cluster => cluster.map(idx => points[idx]));\n  }\n  \n  // STEP 3: Merge clusters based on distance - iterative process\n  let mergeOccurred = true;\n  let iterationCount = 0;\n  const maxIterations = 10; // Prevent infinite loops\n  \n  while (mergeOccurred && iterationCount < maxIterations) {\n    mergeOccurred = false;\n    iterationCount++;\n    \n    for (let i = 0; i < finalClusters.length; i++) {\n      if (!finalClusters[i]) continue; // Skip already merged clusters\n      \n      for (let j = i + 1; j < finalClusters.length; j++) {\n        if (!finalClusters[j]) continue; // Skip already merged clusters\n        \n        // Check if any points in the clusters are close enough to merge\n        const canMerge = finalClusters[i]!.some(p1 => \n          finalClusters[j]!.some(p2 => {\n            const dx = p1.x - p2.x;\n            const dy = p1.y - p2.y;\n            const dist = Math.sqrt(dx*dx + dy*dy);\n            return dist <= maxDistance;\n          })\n        );\n        \n        // Merge clusters if they're close enough\n        if (canMerge) {\n          finalClusters[i] = finalClusters[i]!.concat(finalClusters[j]!);\n          finalClusters[j] = null; // Mark as merged\n          mergeOccurred = true;\n        }\n      }\n    }\n    \n    // Filter out null clusters\n    if (mergeOccurred) {\n      finalClusters = finalClusters.filter(cluster => cluster !== null);\n      console.log(`[DEBUG] Clustering iteration ${iterationCount}: ${finalClusters.length} clusters remaining`);\n    }\n  }\n  \n  // STEP 4: Calculate centroids for each cluster\n  const resultClusters = finalClusters\n    .filter(cluster => cluster!.length >= minClusterSize)\n    .map(cluster => {\n      const sumX = cluster!.reduce((sum, p) => sum + p.x, 0);\n      const sumY = cluster!.reduce((sum, p) => sum + p.y, 0);\n      \n      // Determine type priority\n      // T-junctions and intersections are more important than corners,\n      // which are more important than endpoints for wall reconstruction\n      const typePriority: Record<string, number> = {\n        [PointType.INTERSECTION]: 4,\n        [PointType.T_JUNCTION]: 3,\n        [PointType.CORNER]: 2,\n        [PointType.ENDPOINT]: 1,\n        [PointType.UNCLASSIFIED]: 0\n      };\n      \n      // Count point types and select by priority\n      const typeCounts: Record<string, number> = {};\n      for (const point of cluster!) {\n        const pointType = point.type || PointType.UNCLASSIFIED;\n        typeCounts[pointType] = (typeCounts[pointType] || 0) + 1;\n      }\n      \n      // Find highest priority type that appears at least once\n      let bestType = PointType.UNCLASSIFIED;\n      let highestPriority = -1;\n      \n      for (const type in typeCounts) {\n        const priority = typePriority[type] || 0;\n        if (priority > highestPriority && typeCounts[type] > 0) {\n          highestPriority = priority;\n          bestType = type as PointType;\n        }\n      }\n      \n      return {\n        x: Math.round(sumX / cluster!.length),\n        y: Math.round(sumY / cluster!.length),\n        type: bestType,\n        count: cluster!.length  // Keep track of cluster size\n      };\n    });\n  \n  // Log cluster results  \n  const typeCounts: Record<string, number> = {};\n  for (const point of resultClusters) {\n    const type = point.type || PointType.UNCLASSIFIED;\n    typeCounts[type] = (typeCounts[type] || 0) + 1;\n  }\n  \n  console.log(`[DEBUG] Final result: Clustered ${points.length} points into ${resultClusters.length} points`);\n  console.log(`[DEBUG] Point types after clustering:`);\n  console.log(`Endpoints: ${typeCounts[PointType.ENDPOINT] || 0}`);\n  console.log(`T-Junctions: ${typeCounts[PointType.T_JUNCTION] || 0}`);\n  console.log(`Corners: ${typeCounts[PointType.CORNER] || 0}`);\n  console.log(`Intersections: ${typeCounts[PointType.INTERSECTION] || 0}`);\n  console.log(`Unclassified: ${typeCounts[PointType.UNCLASSIFIED] || 0}`);\n  \n  return resultClusters;\n}\n\n/**\n * Creates line segments by connecting junctions and endpoints.\n * This approach uses junction information rather than a Hough transform.\n * \n * @param imageData - Binary image data\n * @param points - Array of junction and endpoint points to connect\n * @param options - Line connection options\n * @returns Array of detected line segments { x1, y1, x2, y2 }\n */\nexport function connectJunctionsToLines(\n  imageData: ImageData,\n  points: Point[],\n  options: LineDetectionOptions = {}\n): LineSegment[] {\n  if (points.length < 2) {\n    return [];\n  }\n\n  const { width, height, data } = imageData;\n  const lines: LineSegment[] = [];\n  \n  // Default parameter values\n  const maxLineGap = options.maxLineGap ?? 5;\n  const maxConnectionDistance = options.maxDistance ?? 100; // Maximum distance to search for connections\n  \n  // Create a function to check if a line between two points is valid\n  // by checking that it follows the foreground pixels in the image\n  const isLineValid = (p1: Point, p2: Point): boolean => {\n    const dx = p2.x - p1.x;\n    const dy = p2.y - p1.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    \n    // Skip very long connections\n    if (distance > maxConnectionDistance) {\n      return false;\n    }\n    \n    // Sample points along the line to check if they follow the foreground path\n    const steps = Math.max(10, Math.floor(distance / 2));\n    let foregroundCount = 0;\n    \n    for (let i = 0; i <= steps; i++) {\n      const t = i / steps;\n      const x = Math.round(p1.x + dx * t);\n      const y = Math.round(p1.y + dy * t);\n      \n      if (x >= 0 && x < width && y >= 0 && y < height) {\n        const idx = (y * width + x) * 4;\n        if (data[idx] > 0) {\n          foregroundCount++;\n        }\n      }\n    }\n    \n    // Line is valid if at least 70% of points are on foreground pixels\n    // For very short lines, we'll use a higher percentage\n    const minRequiredPercentage = distance < 20 ? 0.9 : 0.7;\n    return foregroundCount / steps >= minRequiredPercentage;\n  };\n  \n  // For each point, try to connect to all other points and check if the connection is valid\n  for (let i = 0; i < points.length; i++) {\n    const p1 = points[i];\n    \n    for (let j = i + 1; j < points.length; j++) {\n      const p2 = points[j];\n      \n      // Check if this is a valid connection\n      if (isLineValid(p1, p2)) {\n        lines.push({\n          x1: p1.x,\n          y1: p1.y,\n          x2: p2.x,\n          y2: p2.y\n        });\n      }\n    }\n  }\n  \n  // Filter duplicate or nearly identical lines\n  const filteredLines: LineSegment[] = [];\n  for (const line of lines) {\n    const isDuplicate = filteredLines.some(l => {\n      const d1 = Math.hypot(l.x1 - line.x1, l.y1 - line.y1) + \n                Math.hypot(l.x2 - line.x2, l.y2 - line.y2);\n      const d2 = Math.hypot(l.x1 - line.x2, l.y1 - line.y2) + \n                Math.hypot(l.x2 - line.x1, l.y2 - line.y1);\n      return d1 <= maxLineGap*2 || d2 <= maxLineGap*2;\n    });\n    \n    if (!isDuplicate) {\n      filteredLines.push(line);\n    }\n  }\n  \n  console.log(`[DEBUG] Created ${filteredLines.length} wall lines by connecting junctions`);\n  return filteredLines;\n}\n\n/**\n * Detects straight line segments in the skeleton image using a simplified Hough transform approach.\n * \n * @param imageData - Binary image data\n * @param options - Line detection options\n * @returns Array of detected line segments { x1, y1, x2, y2 }\n */\nexport function detectStraightLines(\n  imageData: ImageData,\n  options: LineDetectionOptions = {}\n): LineSegment[] {\n  const { width, height, data } = imageData;\n  const lines: LineSegment[] = [];\n  \n  // Default parameter values\n  const threshold = options.threshold ?? 30;\n  const minLineLength = options.minLineLength ?? 20;\n  const maxLineGap = options.maxLineGap ?? 5;\n  const maxDistance = options.maxDistance ?? 5;\n  \n  // Extract foreground pixel coordinates\n  const points: Point[] = [];\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const idx = (y * width + x) * 4;\n      if (data[idx] > 0) {\n        points.push({x, y});\n      }\n    }\n  }\n  \n  // Simple implementation of probabilistic Hough transform\n  // We'll use a simplified approach by checking groups of points\n  // and finding straight lines among them\n  const angleStep = Math.PI / 180;\n  \n  // Group points by potential lines\n  for (let i = 0; i < points.length; i++) {\n    const p1 = points[i];\n    \n    for (let angleIdx = 0; angleIdx < 180; angleIdx++) {\n      const theta = angleIdx * angleStep;\n      const cosTheta = Math.cos(theta);\n      const sinTheta = Math.sin(theta);\n      \n      // Find points that lie on this angle from p1\n      const potentialLinePoints: Point[] = [];\n      potentialLinePoints.push(p1);\n      \n      // Check other points to see if they lie close to this line\n      for (let j = 0; j < points.length; j++) {\n        if (i === j) continue;\n        \n        const p2 = points[j];\n        const dx = p2.x - p1.x;\n        const dy = p2.y - p1.y;\n        \n        // Distance from point to line\n        const dist = Math.abs(-sinTheta * p2.x + cosTheta * p2.y - \n                            (-sinTheta * p1.x + cosTheta * p1.y));\n        \n        if (dist <= maxDistance) {\n          potentialLinePoints.push(p2);\n        }\n      }\n      \n      // If we have enough points, consider this a line\n      if (potentialLinePoints.length >= threshold) {\n        // Sort points to find endpoints\n        potentialLinePoints.sort((a, b) => {\n          return (a.x - p1.x) * cosTheta + (a.y - p1.y) * sinTheta - \n                 ((b.x - p1.x) * cosTheta + (b.y - p1.y) * sinTheta);\n        });\n        \n        // Get first and last point of sorted array as line endpoints\n        const first = potentialLinePoints[0];\n        const last = potentialLinePoints[potentialLinePoints.length - 1];\n        \n        // Calculate length\n        const dx = last.x - first.x;\n        const dy = last.y - first.y;\n        const length = Math.sqrt(dx*dx + dy*dy);\n        \n        // Add line if it meets length requirement\n        if (length >= minLineLength) {\n          lines.push({\n            x1: first.x,\n            y1: first.y,\n            x2: last.x,\n            y2: last.y\n          });\n        }\n      }\n    }\n  }\n  \n  // Filter duplicate lines\n  const filteredLines: LineSegment[] = [];\n  for (const line of lines) {\n    const isDuplicate = filteredLines.some(l => {\n      const d1 = Math.hypot(l.x1 - line.x1, l.y1 - line.y1) + \n                Math.hypot(l.x2 - line.x2, l.y2 - line.y2);\n      const d2 = Math.hypot(l.x1 - line.x2, l.y1 - line.y2) + \n                Math.hypot(l.x2 - line.x1, l.y2 - line.y1);\n      return d1 <= maxLineGap*2 || d2 <= maxLineGap*2;\n    });\n    \n    if (!isDuplicate) {\n      filteredLines.push(line);\n    }\n  }\n  \n  console.log(`[DEBUG] Detected ${filteredLines.length} line segments`);\n  return filteredLines;\n}", "/**\n * Line intersection detection functions\n */\nimport { Point, LineSegment, PointType } from \"./types.ts\";\n\n/**\n * Calculate intersection point of two lines (if any).\n * \n * @param line1 - First line segment {x1, y1, x2, y2}\n * @param line2 - Second line segment {x1, y1, x2, y2}\n * @returns Point of intersection {x, y} or null if no intersection\n */\nexport function intersectLines(line1: LineSegment, line2: LineSegment): Point | null {\n  // Represent line1 in parametric form: P1 + t*(P2-P1)\n  const {x1, y1, x2, y2} = line1;\n  const {x1: x3, y1: y3, x2: x4, y2: y4} = line2;\n  \n  // Compute denominator\n  const denom = (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4);\n  if (Math.abs(denom) < 1e-6) {\n    return null; // Lines are parallel or nearly parallel\n  }\n  \n  // Intersection point\n  const intersectX = ((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4)) / denom;\n  const intersectY = ((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4)) / denom;\n  \n  // Check if intersection is within the line segments\n  const between = (a: number, b: number, c: number): boolean => \n    (a >= Math.min(b, c) - 1e-6 && a <= Math.max(b, c) + 1e-6);\n  \n  if (\n    between(intersectX, x1, x2) && between(intersectY, y1, y2) &&\n    between(intersectX, x3, x4) && between(intersectY, y3, y4)\n  ) {\n    return { x: intersectX, y: intersectY };\n  }\n  \n  return null;\n}\n\n/**\n * Find all intersection points between a set of detected lines\n * \n * @param lines - Array of line segments {x1, y1, x2, y2}\n * @returns Array of intersection points {x, y}\n */\nexport function findIntersections(lines: LineSegment[]): Point[] {\n  const intersections: Point[] = [];\n  \n  // Check all unique line pairs for intersections\n  for (let i = 0; i < lines.length; i++) {\n    for (let j = i + 1; j < lines.length; j++) {\n      const intersection = intersectLines(lines[i], lines[j]);\n      if (intersection) {\n        // Mark this as an intersection point type\n        intersection.type = PointType.INTERSECTION;\n        intersections.push(intersection);\n      }\n    }\n  }\n  \n  console.log(`[DEBUG] Found ${intersections.length} line intersections`);\n  return intersections;\n}\n\n/**\n * Extract endpoints from lines as potential corner points\n * Enhanced to work with image data directly when no line segments are available\n * \n * @param lines - Array of line segments\n * @returns Array of endpoint points\n */\nexport function extractEndpoints(lines: LineSegment[]): Point[] {\n  const endpoints: Point[] = [];\n  \n  if (lines.length > 0) {\n    // Normal case: extract endpoints from line segments\n    for (const line of lines) {\n      // Add both endpoints of the line\n      endpoints.push({ x: line.x1, y: line.y1, type: PointType.ENDPOINT });\n      endpoints.push({ x: line.x2, y: line.y2, type: PointType.ENDPOINT });\n    }\n  }\n  \n  // Log the result\n  console.log(`[DEBUG] Extracted ${endpoints.length} line endpoints`);\n  return endpoints;\n}\n\n/**\n * Combine all detected points: corners, intersections, and optionally endpoints\n * \n * @param corners - Detected corner points\n * @param intersections - Line intersection points\n * @param endpoints - Optional line endpoints to include\n * @returns Combined array of points\n */\nexport function combineFeaturePoints(\n  corners: Point[], \n  intersections: Point[], \n  endpoints: Point[] = []\n): Point[] {\n  // Make sure to include all points of each type\n  const combinedPoints = [...corners, ...intersections, ...endpoints];\n  \n  // Log the result\n  console.log(`[DEBUG] Combined ${corners.length} corners, ${intersections.length} intersections, and ${endpoints.length} endpoints`);\n  \n  return combinedPoints;\n}", "/**\n * Visualization functions for drawing detected features on floorplan images\n */\nimport { Point, LineSegment, PointType } from \"./types.ts\";\n\n/**\n * Helper function to set a pixel color in an ImageData\n */\nfunction setPixelColor(\n  imageData: ImageData,\n  x: number,\n  y: number,\n  r: number,\n  g: number,\n  b: number\n): void {\n  if (x < 0 || y < 0 || x >= imageData.width || y >= imageData.height) return;\n  const idx = (y * imageData.width + x) * 4;\n  imageData.data[idx] = r;\n  imageData.data[idx + 1] = g;\n  imageData.data[idx + 2] = b;\n}\n\n/**\n * Draw a point with its neighborhood on the image\n */\nfunction drawPoint(\n  imageData: ImageData,\n  point: Point,\n  size: number = 6,  // Increased default size from 3 to 6\n  color: [number, number, number] = [255, 0, 0],\n  respectSize: boolean = true\n): void {\n  // Only adjust size if respectSize is true, otherwise use the provided size\n  let adjustedSize = size;\n  \n  // Apply type-based size adjustment only when respectSize is true\n  if (respectSize && point.type) {\n    switch (point.type) {\n      case PointType.T_JUNCTION:\n      case PointType.INTERSECTION:\n        adjustedSize = Math.max(size * 2, 12); // Increased from 6 to 12\n        break;\n      case PointType.ENDPOINT:\n        adjustedSize = Math.max(size * 1.5, 8); // Increased from 4 to 8\n        break;\n      case PointType.CORNER:\n        adjustedSize = Math.max(size * 1.5, 8); // Added specific size for corners\n        break;\n      // Other types use the default size\n    }\n  }\n\n  const halfSize = Math.floor(adjustedSize / 2);\n  for (let dy = -halfSize; dy <= halfSize; dy++) {\n    for (let dx = -halfSize; dx <= halfSize; dx++) {\n      // Make the center brighter\n      const intensity = (dx === 0 && dy === 0) ? 255 : 180;\n      const [r, g, b] = color.map(c => Math.min(255, (c * intensity) / 255));\n      setPixelColor(imageData, point.x + dx, point.y + dy, r, g, b);\n    }\n  }\n}\n\n/**\n * Draw a line segment using Bresenham's algorithm\n */\nfunction drawLine(\n  imageData: ImageData,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  color: [number, number, number] = [0, 0, 255]\n): void {\n  const [r, g, b] = color;\n  const dx = Math.abs(x2 - x1);\n  const dy = Math.abs(y2 - y1);\n  const sx = x1 < x2 ? 1 : -1;\n  const sy = y1 < y2 ? 1 : -1;\n  let err = dx - dy;\n  \n  let x = x1;\n  let y = y1;\n  \n  while (true) {\n    // Draw a 3x3 square for each line point to make the line thicker\n    for (let offsetY = -1; offsetY <= 1; offsetY++) {\n      for (let offsetX = -1; offsetX <= 1; offsetX++) {\n        setPixelColor(imageData, x + offsetX, y + offsetY, r, g, b);\n      }\n    }\n    \n    if (x === x2 && y === y2) break;\n    \n    const e2 = 2 * err;\n    if (e2 > -dy) {\n      err -= dy;\n      x += sx;\n    }\n    if (e2 < dx) {\n      err += dx;\n      y += sy;\n    }\n  }\n}\n\n/**\n * Get color for a specific point type\n * \n * @param pointType - The type of point\n * @returns RGB color array\n */\nfunction getPointTypeColor(pointType?: PointType): [number, number, number] {\n  switch (pointType) {\n    case PointType.CORNER:\n      return [0, 0, 139]; // Dark blue for L-corners (was [255, 0, 0])\n    case PointType.T_JUNCTION:\n      return [0, 255, 0]; // Green for T junctions\n    case PointType.ENDPOINT:\n      return [173, 216, 230]; // Light blue for endpoints\n    case PointType.INTERSECTION:\n      return [255, 0, 255]; // Magenta for intersections\n    case PointType.UNCLASSIFIED:\n    default:\n      return [255, 165, 0]; // Orange for unclassified/unknown\n  }\n}\n\n/**\n * Draw annotation text next to a point\n * \n * @param imageData - Image to draw on\n * @param x - X coordinate\n * @param y - Y coordinate\n * @param label - Text label\n * @param color - Text color\n */\nfunction drawLabel(\n  imageData: ImageData,\n  x: number,\n  y: number,\n  label: string,\n  color: [number, number, number] = [255, 255, 255]\n): void {\n  // Simple implementation - just draw a bright pixel for now\n  // In a real implementation, you'd need a font rendering system\n  const [r, g, b] = color;\n  for (let dy = 0; dy < 5; dy++) {\n    for (let dx = 0; dx < 5; dx++) {\n      setPixelColor(imageData, x + dx, y + dy, r, g, b);\n    }\n  }\n}\n\n/**\n * Draws detected corners on an image.\n * \n * @param imageData - Image to draw on\n * @param corners - Array of corner points {x, y}\n * @param useOriginal - If true, modifies input imageData; otherwise makes a copy\n * @returns Modified image with corners highlighted\n */\nexport function drawCorners(\n  imageData: ImageData, \n  corners: Point[], \n  useOriginal: boolean = false\n): ImageData {\n  // Create a copy of the input image if needed\n  const result = useOriginal ? \n    imageData : \n    new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);\n  \n  // Draw each corner point with consistent size\n  for (const corner of corners) {\n    const color: [number, number, number] = getPointTypeColor(corner.type);\n    // Using fixed size=3 and respectSize=true for corners\n    drawPoint(result, corner, 3, color, true);\n  }\n  \n  return result;\n}\n\n/**\n * Draws clustered points on the image.\n *\n * @param imageData - Image to draw on\n * @param clusters - Array of cluster points {x, y}\n * @param useOriginal - If true, modifies input imageData; otherwise makes a copy\n * @param showLabels - If true, shows labels next to points\n * @returns Modified image with clustered points highlighted\n */\nexport function drawClusteredPoints(\n  imageData: ImageData, \n  clusters: Point[], \n  useOriginal: boolean = false,\n  showLabels: boolean = false\n): ImageData {\n  // Create a copy of the input image if needed\n  const result = useOriginal ? \n    imageData : \n    new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);\n  \n  // Draw each cluster centroid with appropriate color based on type\n  for (const point of clusters) {\n    // Get color based on point type\n    const color = getPointTypeColor(point.type);\n    \n    // Use larger size of 6 pixels (doubled from original 3)\n    drawPoint(result, point, 6, color, true);  // Changed to use respectSize=true\n    \n    if (showLabels && point.type) {\n      drawLabel(result, point.x + 8, point.y - 8, point.type);  // Adjusted label offset for larger points\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Draws detected lines on the image.\n *\n * @param imageData - Image to draw on\n * @param lines - Array of line segments {x1, y1, x2, y2}\n * @param useOriginal - If true, modifies input imageData; otherwise makes a copy\n * @returns Modified image with lines highlighted\n */\nexport function drawLines(\n  imageData: ImageData, \n  lines: LineSegment[], \n  useOriginal: boolean = false\n): ImageData {\n  // Create a copy of the input image if needed\n  const result = useOriginal ? \n    imageData : \n    new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);\n  \n  // Draw each line\n  for (const { x1, y1, x2, y2 } of lines) {\n    drawLine(\n      result, \n      Math.round(x1), \n      Math.round(y1), \n      Math.round(x2), \n      Math.round(y2),\n      [255, 69, 0] // Light brown (rgb value for tan/beige color)\n    );\n  }\n  \n  return result;\n}\n\n/**\n * Draw all detected features on the image\n * \n * @param imageData - Base image to draw on\n * @param features - Object containing all features to draw\n * @param useOriginal - Whether to modify input image or create copy\n * @param options - Additional options for visualization\n * @returns Modified image with all features drawn\n */\nexport function visualizeFeatures(\n  imageData: ImageData,\n  features: {\n    corners?: Point[];\n    clusters?: Point[];\n    lines?: LineSegment[];\n    intersections?: Point[];\n  },\n  useOriginal: boolean = false,\n  options: { showLabels?: boolean } = {}\n): ImageData {\n  const result = useOriginal ? \n    imageData : \n    new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);\n  \n  // Draw features in order: lines, corners, intersections, clusters\n  if (features.lines) {\n    drawLines(result, features.lines, true);\n  }\n  \n  if (features.corners) {\n    drawCorners(result, features.corners, true);\n  }\n  \n  if (features.intersections) {\n    // Draw intersections\n    for (const point of features.intersections) {\n      drawPoint(result, point, 6, getPointTypeColor(PointType.INTERSECTION), true);\n    }\n  }\n  \n  if (features.clusters) {\n    drawClusteredPoints(result, features.clusters, true, options.showLabels);\n  }\n  \n  // Add a legend to help identify the colors\n  const legendX = 10;\n  let legendY = 10;\n  const legendSpacing = 20;  // Increased spacing for larger points\n  \n  // Draw colored squares for each point type\n  if (features.clusters && features.clusters.length > 0) {\n    // Corner (L-junction)\n    drawPoint(result, {x: legendX, y: legendY}, 6, getPointTypeColor(PointType.CORNER), true);\n    drawLabel(result, legendX + 12, legendY, \"Corner (L)\", [255, 255, 255]);\n    legendY += legendSpacing;\n    \n    // T-junction\n    drawPoint(result, {x: legendX, y: legendY}, 6, getPointTypeColor(PointType.T_JUNCTION), true);\n    drawLabel(result, legendX + 12, legendY, \"T-Junction\", [255, 255, 255]);\n    legendY += legendSpacing;\n    \n    // Endpoint\n    drawPoint(result, {x: legendX, y: legendY}, 6, getPointTypeColor(PointType.ENDPOINT), true);\n    drawLabel(result, legendX + 12, legendY, \"Endpoint\", [255, 255, 255]);\n    legendY += legendSpacing;\n    \n    // Intersection\n    drawPoint(result, {x: legendX, y: legendY}, 6, getPointTypeColor(PointType.INTERSECTION), true);\n    drawLabel(result, legendX + 12, legendY, \"Intersection\", [255, 255, 255]);\n  }\n  \n  return result;\n}"],
  "mappings": ";AA2BO,IAAKA,OACVA,EAAA,OAAS,SACTA,EAAA,SAAW,WACXA,EAAA,WAAa,aACbA,EAAA,aAAe,eACfA,EAAA,aAAe,eALLA,OAAA,ICnBL,SAASC,EAAiBC,EAAkC,CACjE,IAAMC,EAAS,SAAS,cAAc,QAAQ,EAC9CA,EAAO,MAAQD,EAAI,MACnBC,EAAO,OAASD,EAAI,OACpB,IAAME,EAAMD,EAAO,WAAW,IAAI,EAElC,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,8BAA8B,EAGhD,OAAAA,EAAI,UAAUF,EAAK,EAAG,CAAC,EAChBE,EAAI,aAAa,EAAG,EAAGD,EAAO,MAAOA,EAAO,MAAM,CAC3D,CAKO,SAASE,EAAUC,EAA+C,CACvE,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,IAAMN,EAAM,IAAI,MAChBA,EAAI,YAAc,YAElBA,EAAI,OAAS,IAAMK,EAAQL,CAAG,EAC9BA,EAAI,QAAU,IAAMM,EAAO,IAAI,MAAM,sBAAsB,CAAC,EAExD,OAAOF,GAAQ,SACjBJ,EAAI,IAAMI,EAEVJ,EAAI,IAAM,IAAI,gBAAgBI,CAAG,CAErC,CAAC,CACH,CAKO,SAASG,EAAmBC,EAAiC,CAClE,GAAM,CAAE,MAAAC,EAAO,OAAAC,EAAQ,KAAAC,CAAK,EAAIH,EAC1BP,EAAS,SAAS,cAAc,QAAQ,EAC9CA,EAAO,MAAQQ,EACfR,EAAO,OAASS,EAEhB,IAAME,EADMX,EAAO,WAAW,IAAI,EACR,gBAAgBQ,EAAOC,CAAM,EACjDG,EAAWD,EAAc,KAG/B,QAASE,EAAI,EAAGA,EAAIH,EAAK,OAAQG,GAAK,EAAG,CAEvC,IAAMC,EAAO,KAAQJ,EAAKG,CAAC,EAAI,KAAQH,EAAKG,EAAI,CAAC,EAAI,KAAQH,EAAKG,EAAI,CAAC,EAEvED,EAASC,CAAC,EAAIC,EACdF,EAASC,EAAI,CAAC,EAAIC,EAClBF,EAASC,EAAI,CAAC,EAAIC,EAClBF,EAASC,EAAI,CAAC,EAAIH,EAAKG,EAAI,CAAC,CAC9B,CAEA,OAAOF,CACT,CAKO,SAASI,EACdR,EACAS,EAAoB,IACpBC,EAAmB,GACR,CACX,GAAM,CAAE,MAAAT,EAAO,OAAAC,EAAQ,KAAAC,CAAK,EAAIH,EAC1BP,EAAS,SAAS,cAAc,QAAQ,EAC9CA,EAAO,MAAQQ,EACfR,EAAO,OAASS,EAEhB,IAAMS,EADMlB,EAAO,WAAW,IAAI,EACT,gBAAgBQ,EAAOC,CAAM,EAChDU,EAAUD,EAAa,KAG7B,QAASL,EAAI,EAAGA,EAAIH,EAAK,OAAQG,GAAK,EAAG,CAEvC,IAAMC,EAAOJ,EAAKG,CAAC,IAAMH,EAAKG,EAAI,CAAC,GAAKH,EAAKG,CAAC,IAAMH,EAAKG,EAAI,CAAC,EAC1DH,EAAKG,CAAC,EACN,KAAQH,EAAKG,CAAC,EAAI,KAAQH,EAAKG,EAAI,CAAC,EAAI,KAAQH,EAAKG,EAAI,CAAC,EAGxDO,EAAMH,EACTH,EAAOE,EAAY,IAAM,EACzBF,EAAOE,EAAY,IAAM,EAE5BG,EAAQN,CAAC,EAAIO,EACbD,EAAQN,EAAI,CAAC,EAAIO,EACjBD,EAAQN,EAAI,CAAC,EAAIO,EACjBD,EAAQN,EAAI,CAAC,EAAI,GACnB,CAEA,OAAOK,CACT,CAKO,SAASG,EAAwBd,EAAsBP,EAAiC,CAC7FA,EAAO,MAAQO,EAAU,MACzBP,EAAO,OAASO,EAAU,OAE1B,IAAMN,EAAMD,EAAO,WAAW,IAAI,EAClC,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,8BAA8B,EAGhDA,EAAI,aAAaM,EAAW,EAAG,CAAC,CAClC,CAMO,SAASe,EACdf,EACAgB,EACW,CACX,IAAMP,EAAYO,GAAS,WAAa,IAClCN,EAAUM,GAAS,UAAY,OAAYA,EAAQ,QAAU,GAGnE,OAAOR,EAAeR,EAAWS,EAAWC,CAAO,CACrD,CC1HO,SAASO,EACdC,EACAC,EAAwB,IACb,CACX,GAAM,CAAE,MAAAC,EAAO,OAAAC,EAAQ,KAAAC,CAAK,EAAIJ,EAG1BK,EAAQ,IAAI,kBAAkBD,CAAI,EAGlCE,EAAW,CAACC,EAAWC,IAAsB,CACjD,GAAID,EAAI,GAAKC,EAAI,GAAKD,GAAKL,GAASM,GAAKL,EAAQ,MAAO,GACxD,IAAMM,GAAOD,EAAIN,EAAQK,GAAK,EAC9B,OAAOF,EAAMI,CAAG,EAAI,EAAI,EAAI,CAC9B,EAGMC,EAAW,CAACH,EAAWC,EAAWG,IAAwB,CAC9D,IAAMF,GAAOD,EAAIN,EAAQK,GAAK,EACxBK,EAAMD,EAAQ,EAAI,IAAM,EAC9BN,EAAMI,CAAG,EAAIJ,EAAMI,EAAM,CAAC,EAAIJ,EAAMI,EAAM,CAAC,EAAIG,CACjD,EAEIC,EAAgB,GAChBC,EAAa,EAEjB,KAAOD,GAAiBC,EAAab,GAAe,CAClDY,EAAgB,GAChBC,IAGA,IAAMC,EAAgC,CAAC,EAEvC,QAASP,EAAI,EAAGA,EAAIL,EAAS,EAAGK,IAC9B,QAASD,EAAI,EAAGA,EAAIL,EAAQ,EAAGK,IAAK,CAClC,GAAID,EAASC,EAAGC,CAAC,IAAM,EAAG,SAG1B,IAAMQ,EAAKV,EAASC,EAAGC,EAAE,CAAC,EACpBS,EAAKX,EAASC,EAAE,EAAGC,EAAE,CAAC,EACtBU,EAAKZ,EAASC,EAAE,EAAGC,CAAC,EACpBW,EAAKb,EAASC,EAAE,EAAGC,EAAE,CAAC,EACtBY,EAAKd,EAASC,EAAGC,EAAE,CAAC,EACpBa,EAAKf,EAASC,EAAE,EAAGC,EAAE,CAAC,EACtBc,EAAKhB,EAASC,EAAE,EAAGC,CAAC,EACpBe,EAAKjB,EAASC,EAAE,EAAGC,EAAE,CAAC,EAEtBgB,EAAY,CAACR,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,CAAE,EAG3CE,EAAcD,EAAU,OAAO,CAACE,EAAKd,IAAQc,EAAMd,EAAK,CAAC,EAC/D,GAAIa,EAAc,GAAKA,EAAc,EAAG,SAGxC,IAAIE,EAAc,EAClB,QAASC,EAAI,EAAGA,EAAIJ,EAAU,OAAQI,IAChCJ,EAAUI,CAAC,IAAM,GAAKJ,GAAWI,EAAI,GAAKJ,EAAU,MAAM,IAAM,GAClEG,IAGAA,IAAgB,GAIhBX,EAAKE,EAAKE,IAAO,GAGjBF,EAAKE,EAAKE,IAAO,GAGrBP,EAAU,KAAK,CAACR,EAAGC,CAAC,CAAC,CACvB,CAIF,OAAW,CAACD,EAAGC,CAAC,IAAKO,EACnBL,EAASH,EAAGC,EAAG,CAAC,EAChBK,EAAgB,GAIlB,IAAMgB,EAAgC,CAAC,EAEvC,QAASrB,EAAI,EAAGA,EAAIL,EAAS,EAAGK,IAC9B,QAASD,EAAI,EAAGA,EAAIL,EAAQ,EAAGK,IAAK,CAClC,GAAID,EAASC,EAAGC,CAAC,IAAM,EAAG,SAG1B,IAAMQ,EAAKV,EAASC,EAAGC,EAAE,CAAC,EACpBS,EAAKX,EAASC,EAAE,EAAGC,EAAE,CAAC,EACtBU,EAAKZ,EAASC,EAAE,EAAGC,CAAC,EACpBW,EAAKb,EAASC,EAAE,EAAGC,EAAE,CAAC,EACtBY,EAAKd,EAASC,EAAGC,EAAE,CAAC,EACpBa,EAAKf,EAASC,EAAE,EAAGC,EAAE,CAAC,EACtBc,EAAKhB,EAASC,EAAE,EAAGC,CAAC,EACpBe,EAAKjB,EAASC,EAAE,EAAGC,EAAE,CAAC,EAEtBgB,EAAY,CAACR,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,CAAE,EAG3CE,EAAcD,EAAU,OAAO,CAACE,EAAKd,IAAQc,EAAMd,EAAK,CAAC,EAC/D,GAAIa,EAAc,GAAKA,EAAc,EAAG,SAGxC,IAAIE,EAAc,EAClB,QAASC,EAAI,EAAGA,EAAIJ,EAAU,OAAQI,IAChCJ,EAAUI,CAAC,IAAM,GAAKJ,GAAWI,EAAI,GAAKJ,EAAU,MAAM,IAAM,GAClEG,IAGAA,IAAgB,GAIhBX,EAAKE,EAAKI,IAAO,GAGjBN,EAAKI,EAAKE,IAAO,GAGrBO,EAAU,KAAK,CAACtB,EAAGC,CAAC,CAAC,CACvB,CAIF,OAAW,CAACD,EAAGC,CAAC,IAAKqB,EACnBnB,EAASH,EAAGC,EAAG,CAAC,EAChBK,EAAgB,EAEpB,CAEA,QAAQ,IAAI,oCAAoCC,CAAU,aAAa,EAGvE,IAAMgB,EAAS,IAAI,kBAAkBzB,CAAK,EAC1C,OAAO,IAAI,UAAUyB,EAAQ5B,EAAOC,CAAM,CAC5C,CAKA,eAAsB4B,EACpBC,EACAC,EACyB,CAEzB,IAAMC,EAAMF,aAAuB,iBAC/BA,EACA,MAAMG,EAAUH,CAAW,EAEzBI,EAAgBF,EAAI,MACpBG,EAAiBH,EAAI,OAE3B,QAAQ,IAAI,8BAA2BG,CAAc,SAAMD,CAAa,EAAE,EAG1E,IAAMpC,EAAYsC,EAAiBJ,CAAG,EAGhCK,EAAYN,GAAS,WAAa,IAClCO,EAAUP,GAAS,SAAW,GAC9BQ,EAAkBC,EAAgB1C,EAAW,CAAE,UAAAuC,EAAW,QAAAC,CAAQ,CAAC,EACzE,QAAQ,IAAI,qDAAqD,EAGjE,IAAMvC,EAAgBgC,GAAS,eAAiB,IAC1CU,EAAgB5C,EAAkB0C,EAAiBxC,CAAa,EACtE,eAAQ,IAAI,kDAAkD,EAGvD,CACL,SAAU0C,EACV,cAAAP,EACA,eAAAC,EACA,UAAW,CACT,eAAgBE,EAChB,UAAW,+BACb,CACF,CACF,CCjLO,SAASK,EAAqBC,EAAmC,CAEtE,IAAMC,EAAYD,EAAa,OAAO,CAACE,EAAKC,IAAQD,EAAMC,EAAK,CAAC,EAG5DC,EAAc,EAClB,QAAS,EAAI,EAAG,EAAIJ,EAAa,OAAQ,IACnCA,EAAa,CAAC,IAAM,GAAKA,GAAc,EAAI,GAAKA,EAAa,MAAM,IAAM,GAC3EI,IAKJ,IAAMC,EAAgBL,EAAa,KAAK,EAAE,EAAIA,EAAa,CAAC,EAG5D,GAAIC,IAAc,GAAMA,IAAc,GAAKG,GAAe,EAAI,CAE5D,GAAIH,IAAc,EAChB,iBAKF,QAAS,EAAI,EAAG,EAAID,EAAa,OAAQ,IACvC,GAAIA,EAAa,CAAC,IAAM,GAAKA,GAAc,EAAI,GAAK,CAAC,IAAM,EACzD,gBAGN,CAGA,GAAIC,IAAc,EAAG,CACnB,GAAIG,IAAgB,EAAG,CAGrB,QAASE,EAAI,EAAGA,EAAIN,EAAa,OAAQM,IACvC,GAAIN,EAAaM,CAAC,IAAM,GAAKN,GAAcM,EAAI,GAAK,CAAC,IAAM,EACzD,qBAuBJ,MAjB4B,CAC1B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EACvB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EACvB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EACvB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CACzB,EAGgD,KAAKC,GAAW,CAC9D,QAASD,EAAI,EAAGA,EAAI,EAAGA,IACrB,GAAIC,EAAQD,CAAC,IAAMN,EAAaM,CAAC,EAC/B,MAAO,GAGX,MAAO,EACT,CAAC,yBAOH,CAYA,GARuB,CACrB,WACA,WACA,WACA,UACF,EAGmB,SAASN,EAAa,KAAK,EAAE,CAAC,EAC/C,cAEJ,CAGA,GAAIC,IAAc,EAAG,CACnB,GAAIG,IAAgB,EAClB,mBAUF,GANkB,CAChB,WACA,WACA,WACA,UACF,EACc,KAAKI,GAAKH,EAAc,SAASG,CAAC,CAAC,EAC/C,kBAEJ,CAGA,OAAIP,GAAa,GAAKG,GAAe,+BAKvC,CAKA,SAASK,EAAgBC,EAAsBC,EAAWC,EAAqB,CAC7E,GAAM,CAAE,MAAAC,EAAO,OAAAC,EAAQ,KAAAC,CAAK,EAAIL,EAGhC,GAAIC,EAAI,GAAKC,EAAI,GAAKD,GAAKE,EAAQ,GAAKD,GAAKE,EAAS,EACpD,MAAO,CAAC,EAIV,IAAMd,EAAyB,CAAC,EAG1BgB,EAAU,CACd,CAAC,GAAI,EAAE,EAAG,CAAC,EAAG,EAAE,EAAG,CAAC,EAAG,EAAE,EAAG,CAAC,EAAG,CAAC,EACjC,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,GAAI,CAAC,EAAG,CAAC,GAAI,CAAC,CACjC,EAEA,OAAW,CAACC,EAAIC,CAAE,IAAKF,EAAS,CAC9B,IAAMG,EAAKR,EAAIM,EAETG,IADKR,EAAIM,GACGL,EAAQM,GAAM,EAChCnB,EAAa,KAAKe,EAAKK,CAAG,EAAI,EAAI,EAAI,CAAC,CACzC,CAEA,OAAOpB,CACT,CAUO,SAASqB,GACdX,EACAY,EAA4B,CAAC,EACpB,CACT,GAAM,CAAE,MAAAT,EAAO,OAAAC,EAAQ,KAAAC,CAAK,EAAIL,EAC1Ba,EAAmB,CAAC,EACpBC,EAAc,IAAI,IAGlBC,EAAeH,EAAQ,cAAgB,EACvCI,EAAiBJ,EAAQ,gBAAkB,EAC3CK,EAAeL,EAAQ,cAAgB,gDAK7C,EAGA,QAASV,EAAI,EAAGA,EAAIE,EAAS,EAAGF,IAC9B,QAASD,EAAI,EAAGA,EAAIE,EAAQ,EAAGF,IAAK,CAClC,IAAMS,GAAOR,EAAIC,EAAQF,GAAK,EAG9B,GAAII,EAAKK,CAAG,IAAM,EAAG,SAGrB,IAAMpB,EAAeS,EAAgBC,EAAWC,EAAGC,CAAC,EACpD,GAAIZ,EAAa,SAAW,EAAG,SAG/B,IAAM4B,EAAgB5B,EAAa,OAAO,CAACE,EAAKC,IAAQD,EAAMC,EAAK,CAAC,EAG9D0B,EAAY9B,EAAqBC,CAAY,EAGnD,GAAI6B,eAAkC,CACpC,GAAIF,EAAa,mBAA2B,EAAG,CAC7C,IAAMG,EAAM,GAAGnB,CAAC,IAAIC,CAAC,GACrBY,EAAY,IAAIM,EAAK,CAAE,EAAAnB,EAAG,EAAAC,EAAG,eAAyB,CAAC,CACzD,CACA,QACF,CAGA,GAAIgB,EAAgBH,EAAc,SAGlC,IAAIrB,EAAc,EAClB,QAASE,EAAI,EAAGA,EAAIN,EAAa,OAAQM,IACnCN,EAAaM,CAAC,IAAM,GAAKN,GAAcM,EAAI,GAAK,CAAC,IAAM,GACzDF,IAGAA,EAAcsB,GAGdC,EAAa,SAASE,CAAS,GACjCN,EAAQ,KAAK,CAAE,EAAAZ,EAAG,EAAAC,EAAG,KAAMiB,CAAU,CAAC,CAE1C,CAIF,OAAAN,EAAQ,KAAK,GAAGC,EAAY,OAAO,CAAC,EAEpC,QAAQ,IAAI,oBAAoBD,EAAQ,MAAM,4CAA4CC,EAAY,IAAI,GAAG,EACtGD,CACT,CAUO,SAASQ,GACdC,EACAV,EAA0B,CAAC,EAClB,CACT,GAAIU,EAAO,SAAW,EAAG,MAAO,CAAC,EAGjC,IAAMC,EAAcX,EAAQ,aAAe,GACrCY,EAAoBZ,EAAQ,mBAAqB,GACjDa,EAAiBb,EAAQ,gBAAkB,EAC3Cc,EAAgBd,EAAQ,eAAiB,GAE/C,QAAQ,IAAI,uCAAuCW,CAAW,mBAAmBG,CAAa,EAAE,EAKhG,IAAMC,EAAc,KAAK,IAAI,EAAGJ,EAAc,CAAC,EAE/C,QAAQ,IAAI,gDAAgDI,CAAW,EAAE,EAGzE,IAAMC,EAAyB,CAAC,EAChC,QAAShC,EAAI,EAAGA,EAAI0B,EAAO,OAAQ1B,IAAK,CACtCgC,EAAWhC,CAAC,EAAI,CAAC,EACjB,QAASiC,EAAI,EAAGA,EAAIP,EAAO,OAAQO,IAAK,CACtC,IAAMtB,EAAKe,EAAO1B,CAAC,EAAE,EAAI0B,EAAOO,CAAC,EAAE,EAC7BrB,EAAKc,EAAO1B,CAAC,EAAE,EAAI0B,EAAOO,CAAC,EAAE,EACnCD,EAAWhC,CAAC,EAAEiC,CAAC,EAAI,KAAK,KAAKtB,EAAGA,EAAKC,EAAGA,CAAE,CAC5C,CACF,CAGA,IAAMsB,EAA8B,CAAC,EAC/BC,EAAiB,IAAI,IAE3B,QAASnC,EAAI,EAAGA,EAAI0B,EAAO,OAAQ1B,IAAK,CACtC,GAAImC,EAAe,IAAInC,CAAC,EAAG,SAE3B,IAAMoC,EAAoB,CAACpC,CAAC,EAC5BmC,EAAe,IAAInC,CAAC,EAEpB,QAASiC,EAAI,EAAGA,EAAIP,EAAO,OAAQO,IAC7BjC,IAAMiC,GAAKE,EAAe,IAAIF,CAAC,GAE/BD,EAAWhC,CAAC,EAAEiC,CAAC,GAAKF,IACtBK,EAAQ,KAAKH,CAAC,EACdE,EAAe,IAAIF,CAAC,GAIxBC,EAAgB,KAAKE,CAAO,CAC9B,CAEA,QAAQ,IAAI,+BAA+BF,EAAgB,MAAM,kBAAkBR,EAAO,MAAM,SAAS,EAIzG,IAAIW,EAAoC,CAAC,EAEzC,GAAIP,EAAe,CAEjB,IAAMQ,EAAwC,CAAC,EAE/C,QAAWF,KAAWF,EAAiB,CAErC,IAAMK,EAAqC,CAAC,EAE5C,QAAWzB,KAAOsB,EAAS,CACzB,IAAMb,EAAYG,EAAOZ,CAAG,EAAE,qBAC9ByB,EAAWhB,CAAS,GAAKgB,EAAWhB,CAAS,GAAK,GAAK,CACzD,CAGA,IAAIiB,iBACAC,EAAW,EACf,QAAWC,KAAQH,EACbA,EAAWG,CAAI,EAAID,IACrBA,EAAWF,EAAWG,CAAI,EAC1BF,EAAeE,GAKnB,IAAMjB,EAAgBW,EAAQ,IAAItB,GAAOY,EAAOZ,CAAG,CAAC,EAE/CwB,EAAaE,CAAY,IAC5BF,EAAaE,CAAY,EAAI,CAAC,GAEhCF,EAAaE,CAAY,EAAE,KAAK,GAAGf,CAAa,CAClD,CAGA,QAAWiB,KAAQJ,EAAc,CAC/B,IAAMK,EAAaL,EAAaI,CAAI,EAGpCL,EAAc,KAAK,GAAGM,EAAW,IAAIzC,GAAK,CAACA,CAAC,CAAC,CAAC,CAChD,CACF,MAEEmC,EAAgBH,EAAgB,IAAIE,GAAWA,EAAQ,IAAItB,GAAOY,EAAOZ,CAAG,CAAC,CAAC,EAIhF,IAAI8B,EAAgB,GAChBC,EAAiB,EACfC,EAAgB,GAEtB,KAAOF,GAAiBC,EAAiBC,GAAe,CACtDF,EAAgB,GAChBC,IAEA,QAAS7C,EAAI,EAAGA,EAAIqC,EAAc,OAAQrC,IACxC,GAAKqC,EAAcrC,CAAC,EAEpB,QAASiC,EAAIjC,EAAI,EAAGiC,EAAII,EAAc,OAAQJ,IAAK,CACjD,GAAI,CAACI,EAAcJ,CAAC,EAAG,SAGNI,EAAcrC,CAAC,EAAG,KAAK+C,GACtCV,EAAcJ,CAAC,EAAG,KAAKe,GAAM,CAC3B,IAAMrC,EAAKoC,EAAG,EAAIC,EAAG,EACfpC,EAAKmC,EAAG,EAAIC,EAAG,EAErB,OADa,KAAK,KAAKrC,EAAGA,EAAKC,EAAGA,CAAE,GACrBe,CACjB,CAAC,CACH,IAIEU,EAAcrC,CAAC,EAAIqC,EAAcrC,CAAC,EAAG,OAAOqC,EAAcJ,CAAC,CAAE,EAC7DI,EAAcJ,CAAC,EAAI,KACnBW,EAAgB,GAEpB,CAIEA,IACFP,EAAgBA,EAAc,OAAOD,GAAWA,IAAY,IAAI,EAChE,QAAQ,IAAI,gCAAgCS,CAAc,KAAKR,EAAc,MAAM,qBAAqB,EAE5G,CAGA,IAAMY,EAAiBZ,EACpB,OAAOD,GAAWA,EAAS,QAAUP,CAAc,EACnD,IAAIO,GAAW,CACd,IAAMc,EAAOd,EAAS,OAAO,CAACxC,EAAKM,IAAMN,EAAMM,EAAE,EAAG,CAAC,EAC/CiD,EAAOf,EAAS,OAAO,CAACxC,EAAKM,IAAMN,EAAMM,EAAE,EAAG,CAAC,EAK/CkD,EAAuC,CAC1C,aAAyB,EACzB,WAAuB,EACvB,OAAmB,EACnB,SAAqB,EACrB,aAAyB,CAC5B,EAGMb,EAAqC,CAAC,EAC5C,QAAWc,KAASjB,EAAU,CAC5B,IAAMb,EAAY8B,EAAM,qBACxBd,EAAWhB,CAAS,GAAKgB,EAAWhB,CAAS,GAAK,GAAK,CACzD,CAGA,IAAI+B,iBACAC,EAAkB,GAEtB,QAAWb,KAAQH,EAAY,CAC7B,IAAMiB,EAAWJ,EAAaV,CAAI,GAAK,EACnCc,EAAWD,GAAmBhB,EAAWG,CAAI,EAAI,IACnDa,EAAkBC,EAClBF,EAAWZ,EAEf,CAEA,MAAO,CACL,EAAG,KAAK,MAAMQ,EAAOd,EAAS,MAAM,EACpC,EAAG,KAAK,MAAMe,EAAOf,EAAS,MAAM,EACpC,KAAMkB,EACN,MAAOlB,EAAS,MAClB,CACF,CAAC,EAGGG,EAAqC,CAAC,EAC5C,QAAWc,KAASJ,EAAgB,CAClC,IAAMP,EAAOW,EAAM,qBACnBd,EAAWG,CAAI,GAAKH,EAAWG,CAAI,GAAK,GAAK,CAC/C,CAEA,eAAQ,IAAI,mCAAmChB,EAAO,MAAM,gBAAgBuB,EAAe,MAAM,SAAS,EAC1G,QAAQ,IAAI,uCAAuC,EACnD,QAAQ,IAAI,cAAcV,EAAW,UAAuB,CAAC,EAAE,EAC/D,QAAQ,IAAI,gBAAgBA,EAAW,YAAyB,CAAC,EAAE,EACnE,QAAQ,IAAI,YAAYA,EAAW,QAAqB,CAAC,EAAE,EAC3D,QAAQ,IAAI,kBAAkBA,EAAW,cAA2B,CAAC,EAAE,EACvE,QAAQ,IAAI,iBAAiBA,EAAW,cAA2B,CAAC,EAAE,EAE/DU,CACT,CAWO,SAASQ,GACdrD,EACAsB,EACAV,EAAgC,CAAC,EAClB,CACf,GAAIU,EAAO,OAAS,EAClB,MAAO,CAAC,EAGV,GAAM,CAAE,MAAAnB,EAAO,OAAAC,EAAQ,KAAAC,CAAK,EAAIL,EAC1BsD,EAAuB,CAAC,EAGxBC,EAAa3C,EAAQ,YAAc,EACnC4C,EAAwB5C,EAAQ,aAAe,IAI/C6C,EAAc,CAACd,EAAWC,IAAuB,CACrD,IAAMrC,EAAKqC,EAAG,EAAID,EAAG,EACfnC,EAAKoC,EAAG,EAAID,EAAG,EACfe,EAAW,KAAK,KAAKnD,EAAKA,EAAKC,EAAKA,CAAE,EAG5C,GAAIkD,EAAWF,EACb,MAAO,GAIT,IAAMG,EAAQ,KAAK,IAAI,GAAI,KAAK,MAAMD,EAAW,CAAC,CAAC,EAC/CE,EAAkB,EAEtB,QAAShE,EAAI,EAAGA,GAAK+D,EAAO/D,IAAK,CAC/B,IAAMiE,EAAIjE,EAAI+D,EACR1D,EAAI,KAAK,MAAM0C,EAAG,EAAIpC,EAAKsD,CAAC,EAC5B3D,EAAI,KAAK,MAAMyC,EAAG,EAAInC,EAAKqD,CAAC,EAElC,GAAI5D,GAAK,GAAKA,EAAIE,GAASD,GAAK,GAAKA,EAAIE,EAAQ,CAC/C,IAAMM,GAAOR,EAAIC,EAAQF,GAAK,EAC1BI,EAAKK,CAAG,EAAI,GACdkD,GAEJ,CACF,CAIA,IAAME,EAAwBJ,EAAW,GAAK,GAAM,GACpD,OAAOE,EAAkBD,GAASG,CACpC,EAGA,QAASlE,EAAI,EAAGA,EAAI0B,EAAO,OAAQ1B,IAAK,CACtC,IAAM+C,EAAKrB,EAAO1B,CAAC,EAEnB,QAASiC,EAAIjC,EAAI,EAAGiC,EAAIP,EAAO,OAAQO,IAAK,CAC1C,IAAMe,EAAKtB,EAAOO,CAAC,EAGf4B,EAAYd,EAAIC,CAAE,GACpBU,EAAM,KAAK,CACT,GAAIX,EAAG,EACP,GAAIA,EAAG,EACP,GAAIC,EAAG,EACP,GAAIA,EAAG,CACT,CAAC,CAEL,CACF,CAGA,IAAMmB,EAA+B,CAAC,EACtC,QAAWC,KAAQV,EACGS,EAAc,KAAKE,GAAK,CAC1C,IAAMC,EAAK,KAAK,MAAMD,EAAE,GAAKD,EAAK,GAAIC,EAAE,GAAKD,EAAK,EAAE,EAC1C,KAAK,MAAMC,EAAE,GAAKD,EAAK,GAAIC,EAAE,GAAKD,EAAK,EAAE,EAC7CG,EAAK,KAAK,MAAMF,EAAE,GAAKD,EAAK,GAAIC,EAAE,GAAKD,EAAK,EAAE,EAC1C,KAAK,MAAMC,EAAE,GAAKD,EAAK,GAAIC,EAAE,GAAKD,EAAK,EAAE,EACnD,OAAOE,GAAMX,EAAW,GAAKY,GAAMZ,EAAW,CAChD,CAAC,GAGCQ,EAAc,KAAKC,CAAI,EAI3B,eAAQ,IAAI,mBAAmBD,EAAc,MAAM,qCAAqC,EACjFA,CACT,CASO,SAASK,GACdpE,EACAY,EAAgC,CAAC,EAClB,CACf,GAAM,CAAE,MAAAT,EAAO,OAAAC,EAAQ,KAAAC,CAAK,EAAIL,EAC1BsD,EAAuB,CAAC,EAGxBe,EAAYzD,EAAQ,WAAa,GACjC0D,EAAgB1D,EAAQ,eAAiB,GACzC2C,EAAa3C,EAAQ,YAAc,EACnCW,EAAcX,EAAQ,aAAe,EAGrCU,EAAkB,CAAC,EACzB,QAASpB,EAAI,EAAGA,EAAIE,EAAQF,IAC1B,QAASD,EAAI,EAAGA,EAAIE,EAAOF,IAAK,CAC9B,IAAMS,GAAOR,EAAIC,EAAQF,GAAK,EAC1BI,EAAKK,CAAG,EAAI,GACdY,EAAO,KAAK,CAAC,EAAArB,EAAG,EAAAC,CAAC,CAAC,CAEtB,CAMF,IAAMqE,EAAY,KAAK,GAAK,IAG5B,QAAS3E,EAAI,EAAGA,EAAI0B,EAAO,OAAQ1B,IAAK,CACtC,IAAM+C,EAAKrB,EAAO1B,CAAC,EAEnB,QAAS4E,EAAW,EAAGA,EAAW,IAAKA,IAAY,CACjD,IAAMC,EAAQD,EAAWD,EACnBG,EAAW,KAAK,IAAID,CAAK,EACzBE,EAAW,KAAK,IAAIF,CAAK,EAGzBG,EAA+B,CAAC,EACtCA,EAAoB,KAAKjC,CAAE,EAG3B,QAASd,EAAI,EAAGA,EAAIP,EAAO,OAAQO,IAAK,CACtC,GAAIjC,IAAMiC,EAAG,SAEb,IAAMe,EAAKtB,EAAOO,CAAC,EACbtB,EAAKqC,EAAG,EAAID,EAAG,EACfnC,EAAKoC,EAAG,EAAID,EAAG,EAGR,KAAK,IAAI,CAACgC,EAAW/B,EAAG,EAAI8B,EAAW9B,EAAG,GAClC,CAAC+B,EAAWhC,EAAG,EAAI+B,EAAW/B,EAAG,EAAE,GAE5CpB,GACVqD,EAAoB,KAAKhC,CAAE,CAE/B,CAGA,GAAIgC,EAAoB,QAAUP,EAAW,CAE3CO,EAAoB,KAAK,CAACC,EAAGC,KACnBD,EAAE,EAAIlC,EAAG,GAAK+B,GAAYG,EAAE,EAAIlC,EAAG,GAAKgC,IACvCG,EAAE,EAAInC,EAAG,GAAK+B,GAAYI,EAAE,EAAInC,EAAG,GAAKgC,EAClD,EAGD,IAAMI,EAAQH,EAAoB,CAAC,EAC7BI,EAAOJ,EAAoBA,EAAoB,OAAS,CAAC,EAGzDrE,EAAKyE,EAAK,EAAID,EAAM,EACpBvE,EAAKwE,EAAK,EAAID,EAAM,EACX,KAAK,KAAKxE,EAAGA,EAAKC,EAAGA,CAAE,GAGxB8D,GACZhB,EAAM,KAAK,CACT,GAAIyB,EAAM,EACV,GAAIA,EAAM,EACV,GAAIC,EAAK,EACT,GAAIA,EAAK,CACX,CAAC,CAEL,CACF,CACF,CAGA,IAAMjB,EAA+B,CAAC,EACtC,QAAWC,KAAQV,EACGS,EAAc,KAAKE,GAAK,CAC1C,IAAMC,EAAK,KAAK,MAAMD,EAAE,GAAKD,EAAK,GAAIC,EAAE,GAAKD,EAAK,EAAE,EAC1C,KAAK,MAAMC,EAAE,GAAKD,EAAK,GAAIC,EAAE,GAAKD,EAAK,EAAE,EAC7CG,EAAK,KAAK,MAAMF,EAAE,GAAKD,EAAK,GAAIC,EAAE,GAAKD,EAAK,EAAE,EAC1C,KAAK,MAAMC,EAAE,GAAKD,EAAK,GAAIC,EAAE,GAAKD,EAAK,EAAE,EACnD,OAAOE,GAAMX,EAAW,GAAKY,GAAMZ,EAAW,CAChD,CAAC,GAGCQ,EAAc,KAAKC,CAAI,EAI3B,eAAQ,IAAI,oBAAoBD,EAAc,MAAM,gBAAgB,EAC7DA,CACT,CCvoBO,SAASkB,EAAeC,EAAoBC,EAAkC,CAEnF,GAAM,CAAC,GAAAC,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,CAAE,EAAIL,EACnB,CAAC,GAAIM,EAAI,GAAIC,EAAI,GAAIC,EAAI,GAAIC,CAAE,EAAIR,EAGnCS,GAASR,EAAKE,IAAKG,EAAKE,IAAON,EAAKE,IAAKC,EAAKE,GACpD,GAAI,KAAK,IAAIE,CAAK,EAAI,KACpB,OAAO,KAIT,IAAMC,IAAeT,EAAGG,EAAKF,EAAGC,IAAKE,EAAKE,IAAON,EAAKE,IAAKE,EAAGG,EAAKF,EAAGC,IAAOE,EACvEE,IAAeV,EAAGG,EAAKF,EAAGC,IAAKG,EAAKE,IAAON,EAAKE,IAAKC,EAAGG,EAAKF,EAAGC,IAAOE,EAGvEG,EAAU,CAACC,EAAWC,EAAWC,IACpCF,GAAK,KAAK,IAAIC,EAAGC,CAAC,EAAI,MAAQF,GAAK,KAAK,IAAIC,EAAGC,CAAC,EAAI,KAEvD,OACEH,EAAQF,EAAYT,EAAIE,CAAE,GAAKS,EAAQD,EAAYT,EAAIE,CAAE,GACzDQ,EAAQF,EAAYL,EAAIE,CAAE,GAAKK,EAAQD,EAAYL,EAAIE,CAAE,EAElD,CAAE,EAAGE,EAAY,EAAGC,CAAW,EAGjC,IACT,CAQO,SAASK,GAAkBC,EAA+B,CAC/D,IAAMC,EAAyB,CAAC,EAGhC,QAASC,EAAI,EAAGA,EAAIF,EAAM,OAAQE,IAChC,QAASC,EAAID,EAAI,EAAGC,EAAIH,EAAM,OAAQG,IAAK,CACzC,IAAMC,EAAevB,EAAemB,EAAME,CAAC,EAAGF,EAAMG,CAAC,CAAC,EAClDC,IAEFA,EAAa,oBACbH,EAAc,KAAKG,CAAY,EAEnC,CAGF,eAAQ,IAAI,iBAAiBH,EAAc,MAAM,qBAAqB,EAC/DA,CACT,CASO,SAASI,GAAiBL,EAA+B,CAC9D,IAAMM,EAAqB,CAAC,EAE5B,GAAIN,EAAM,OAAS,EAEjB,QAAWO,KAAQP,EAEjBM,EAAU,KAAK,CAAE,EAAGC,EAAK,GAAI,EAAGA,EAAK,GAAI,eAAyB,CAAC,EACnED,EAAU,KAAK,CAAE,EAAGC,EAAK,GAAI,EAAGA,EAAK,GAAI,eAAyB,CAAC,EAKvE,eAAQ,IAAI,qBAAqBD,EAAU,MAAM,iBAAiB,EAC3DA,CACT,CAUO,SAASE,GACdC,EACAR,EACAK,EAAqB,CAAC,EACb,CAET,IAAMI,EAAiB,CAAC,GAAGD,EAAS,GAAGR,EAAe,GAAGK,CAAS,EAGlE,eAAQ,IAAI,oBAAoBG,EAAQ,MAAM,aAAaR,EAAc,MAAM,uBAAuBK,EAAU,MAAM,YAAY,EAE3HI,CACT,CCtGA,SAASC,EACPC,EACAC,EACAC,EACAC,EACAC,EACAC,EACM,CACN,GAAIJ,EAAI,GAAKC,EAAI,GAAKD,GAAKD,EAAU,OAASE,GAAKF,EAAU,OAAQ,OACrE,IAAMM,GAAOJ,EAAIF,EAAU,MAAQC,GAAK,EACxCD,EAAU,KAAKM,CAAG,EAAIH,EACtBH,EAAU,KAAKM,EAAM,CAAC,EAAIF,EAC1BJ,EAAU,KAAKM,EAAM,CAAC,EAAID,CAC5B,CAKA,SAASE,EACPP,EACAQ,EACAC,EAAe,EACfC,EAAkC,CAAC,IAAK,EAAG,CAAC,EAC5CC,EAAuB,GACjB,CAEN,IAAIC,EAAeH,EAGnB,GAAIE,GAAeH,EAAM,KACvB,OAAQA,EAAM,KAAM,CAClB,iBACA,mBACEI,EAAe,KAAK,IAAIH,EAAO,EAAG,EAAE,EACpC,MACF,eACEG,EAAe,KAAK,IAAIH,EAAO,IAAK,CAAC,EACrC,MACF,aACEG,EAAe,KAAK,IAAIH,EAAO,IAAK,CAAC,EACrC,KAEJ,CAGF,IAAMI,EAAW,KAAK,MAAMD,EAAe,CAAC,EAC5C,QAASE,EAAK,CAACD,EAAUC,GAAMD,EAAUC,IACvC,QAASC,EAAK,CAACF,EAAUE,GAAMF,EAAUE,IAAM,CAE7C,IAAMC,EAAaD,IAAO,GAAKD,IAAO,EAAK,IAAM,IAC3C,CAACX,EAAG,EAAGE,CAAC,EAAIK,EAAM,IAAIO,GAAK,KAAK,IAAI,IAAMA,EAAID,EAAa,GAAG,CAAC,EACrEjB,EAAcC,EAAWQ,EAAM,EAAIO,EAAIP,EAAM,EAAIM,EAAIX,EAAG,EAAGE,CAAC,CAC9D,CAEJ,CAKA,SAASa,EACPlB,EACAmB,EACAC,EACAC,EACAC,EACAZ,EAAkC,CAAC,EAAG,EAAG,GAAG,EACtC,CACN,GAAM,CAACP,EAAGC,EAAGC,CAAC,EAAIK,EACZK,EAAK,KAAK,IAAIM,EAAKF,CAAE,EACrBL,EAAK,KAAK,IAAIQ,EAAKF,CAAE,EACrBG,EAAKJ,EAAKE,EAAK,EAAI,GACnBG,EAAKJ,EAAKE,EAAK,EAAI,GACrBG,EAAMV,EAAKD,EAEXb,EAAIkB,EACJjB,EAAIkB,EAER,OAAa,CAEX,QAASM,EAAU,GAAIA,GAAW,EAAGA,IACnC,QAASC,EAAU,GAAIA,GAAW,EAAGA,IACnC5B,EAAcC,EAAWC,EAAI0B,EAASzB,EAAIwB,EAASvB,EAAGC,EAAGC,CAAC,EAI9D,GAAIJ,IAAMoB,GAAMnB,IAAMoB,EAAI,MAE1B,IAAMM,EAAK,EAAIH,EACXG,EAAK,CAACd,IACRW,GAAOX,EACPb,GAAKsB,GAEHK,EAAKb,IACPU,GAAOV,EACPb,GAAKsB,EAET,CACF,CAQA,SAASK,EAAkBC,EAAiD,CAC1E,OAAQA,EAAW,CACjB,aACE,MAAO,CAAC,EAAG,EAAG,GAAG,EACnB,iBACE,MAAO,CAAC,EAAG,IAAK,CAAC,EACnB,eACE,MAAO,CAAC,IAAK,IAAK,GAAG,EACvB,mBACE,MAAO,CAAC,IAAK,EAAG,GAAG,EACrB,mBACA,QACE,MAAO,CAAC,IAAK,IAAK,CAAC,CACvB,CACF,CAWA,SAASC,EACP/B,EACAC,EACAC,EACA8B,EACAtB,EAAkC,CAAC,IAAK,IAAK,GAAG,EAC1C,CAGN,GAAM,CAAC,EAAGN,EAAGC,CAAC,EAAIK,EAClB,QAASI,EAAK,EAAGA,EAAK,EAAGA,IACvB,QAASC,EAAK,EAAGA,EAAK,EAAGA,IACvBhB,EAAcC,EAAWC,EAAIc,EAAIb,EAAIY,EAAI,EAAGV,EAAGC,CAAC,CAGtD,CAUO,SAAS4B,EACdjC,EACAkC,EACAC,EAAuB,GACZ,CAEX,IAAMC,EAASD,EACbnC,EACA,IAAI,UAAU,IAAI,kBAAkBA,EAAU,IAAI,EAAGA,EAAU,MAAOA,EAAU,MAAM,EAGxF,QAAWqC,KAAUH,EAAS,CAC5B,IAAMxB,EAAkCmB,EAAkBQ,EAAO,IAAI,EAErE9B,EAAU6B,EAAQC,EAAQ,EAAG3B,EAAO,EAAI,CAC1C,CAEA,OAAO0B,CACT,CAWO,SAASE,EACdtC,EACAuC,EACAJ,EAAuB,GACvBK,EAAsB,GACX,CAEX,IAAMJ,EAASD,EACbnC,EACA,IAAI,UAAU,IAAI,kBAAkBA,EAAU,IAAI,EAAGA,EAAU,MAAOA,EAAU,MAAM,EAGxF,QAAWQ,KAAS+B,EAAU,CAE5B,IAAM7B,EAAQmB,EAAkBrB,EAAM,IAAI,EAG1CD,EAAU6B,EAAQ5B,EAAO,EAAGE,EAAO,EAAI,EAEnC8B,GAAchC,EAAM,MACtBuB,EAAUK,EAAQ5B,EAAM,EAAI,EAAGA,EAAM,EAAI,EAAGA,EAAM,IAAI,CAE1D,CAEA,OAAO4B,CACT,CAUO,SAASK,EACdzC,EACA0C,EACAP,EAAuB,GACZ,CAEX,IAAMC,EAASD,EACbnC,EACA,IAAI,UAAU,IAAI,kBAAkBA,EAAU,IAAI,EAAGA,EAAU,MAAOA,EAAU,MAAM,EAGxF,OAAW,CAAE,GAAAmB,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,CAAG,IAAKoB,EAC/BxB,EACEkB,EACA,KAAK,MAAMjB,CAAE,EACb,KAAK,MAAMC,CAAE,EACb,KAAK,MAAMC,CAAE,EACb,KAAK,MAAMC,CAAE,EACb,CAAC,IAAK,GAAI,CAAC,CACb,EAGF,OAAOc,CACT,CAWO,SAASO,GACd3C,EACA4C,EAMAT,EAAuB,GACvBU,EAAoC,CAAC,EAC1B,CACX,IAAMT,EAASD,EACbnC,EACA,IAAI,UAAU,IAAI,kBAAkBA,EAAU,IAAI,EAAGA,EAAU,MAAOA,EAAU,MAAM,EAWxF,GARI4C,EAAS,OACXH,EAAUL,EAAQQ,EAAS,MAAO,EAAI,EAGpCA,EAAS,SACXX,EAAYG,EAAQQ,EAAS,QAAS,EAAI,EAGxCA,EAAS,cAEX,QAAWpC,KAASoC,EAAS,cAC3BrC,EAAU6B,EAAQ5B,EAAO,EAAGqB,gBAAwC,EAAG,EAAI,EAI3Ee,EAAS,UACXN,EAAoBF,EAAQQ,EAAS,SAAU,GAAMC,EAAQ,UAAU,EAIzE,IAAMC,EAAU,GACZC,EAAU,GACRC,EAAgB,GAGtB,OAAIJ,EAAS,UAAYA,EAAS,SAAS,OAAS,IAElDrC,EAAU6B,EAAQ,CAAC,EAAGU,EAAS,EAAGC,CAAO,EAAG,EAAGlB,UAAkC,EAAG,EAAI,EACxFE,EAAUK,EAAQU,EAAU,GAAIC,EAAS,aAAc,CAAC,IAAK,IAAK,GAAG,CAAC,EACtEA,GAAWC,EAGXzC,EAAU6B,EAAQ,CAAC,EAAGU,EAAS,EAAGC,CAAO,EAAG,EAAGlB,cAAsC,EAAG,EAAI,EAC5FE,EAAUK,EAAQU,EAAU,GAAIC,EAAS,aAAc,CAAC,IAAK,IAAK,GAAG,CAAC,EACtEA,GAAWC,EAGXzC,EAAU6B,EAAQ,CAAC,EAAGU,EAAS,EAAGC,CAAO,EAAG,EAAGlB,YAAoC,EAAG,EAAI,EAC1FE,EAAUK,EAAQU,EAAU,GAAIC,EAAS,WAAY,CAAC,IAAK,IAAK,GAAG,CAAC,EACpEA,GAAWC,EAGXzC,EAAU6B,EAAQ,CAAC,EAAGU,EAAS,EAAGC,CAAO,EAAG,EAAGlB,gBAAwC,EAAG,EAAI,EAC9FE,EAAUK,EAAQU,EAAU,GAAIC,EAAS,eAAgB,CAAC,IAAK,IAAK,GAAG,CAAC,GAGnEX,CACT",
  "names": ["PointType", "imageToImageData", "img", "canvas", "ctx", "loadImage", "src", "resolve", "reject", "convertToGrayscale", "imageData", "width", "height", "data", "grayImageData", "grayData", "i", "gray", "thresholdImage", "threshold", "inverse", "binImageData", "binData", "val", "renderImageDataToCanvas", "preprocessImage", "options", "zhangSuenThinning", "imageData", "maxIterations", "width", "height", "data", "input", "getPixel", "x", "y", "idx", "setPixel", "value", "val", "pixelsRemoved", "iterations", "toRemove1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "neighbors", "neighborSum", "sum", "transitions", "i", "toRemove2", "result", "skeletonizeImage", "imageSource", "options", "img", "loadImage", "originalWidth", "originalHeight", "imageToImageData", "threshold", "inverse", "binaryImageData", "preprocessImage", "skelImageData", "classifyJunctionType", "neighborhood", "neighbors", "sum", "val", "transitions", "patternString", "i", "pattern", "p", "getNeighborhood", "imageData", "x", "y", "width", "height", "data", "offsets", "dx", "dy", "nx", "idx", "detectCorners", "options", "corners", "endpointMap", "minNeighbors", "minTransitions", "includeTypes", "neighborCount", "pointType", "key", "clusterPoints", "points", "maxDistance", "distanceThreshold", "minClusterSize", "preserveTypes", "tightRadius", "distMatrix", "j", "initialClusters", "assignedPoints", "cluster", "finalClusters", "pointsByType", "typeCounts", "dominantType", "maxCount", "type", "typePoints", "mergeOccurred", "iterationCount", "maxIterations", "p1", "p2", "resultClusters", "sumX", "sumY", "typePriority", "point", "bestType", "highestPriority", "priority", "connectJunctionsToLines", "lines", "maxLineGap", "maxConnectionDistance", "isLineValid", "distance", "steps", "foregroundCount", "t", "minRequiredPercentage", "filteredLines", "line", "l", "d1", "d2", "detectStraightLines", "threshold", "minLineLength", "angleStep", "angleIdx", "theta", "cosTheta", "sinTheta", "potentialLinePoints", "a", "b", "first", "last", "intersectLines", "line1", "line2", "x1", "y1", "x2", "y2", "x3", "y3", "x4", "y4", "denom", "intersectX", "intersectY", "between", "a", "b", "c", "findIntersections", "lines", "intersections", "i", "j", "intersection", "extractEndpoints", "endpoints", "line", "combineFeaturePoints", "corners", "combinedPoints", "setPixelColor", "imageData", "x", "y", "r", "g", "b", "idx", "drawPoint", "point", "size", "color", "respectSize", "adjustedSize", "halfSize", "dy", "dx", "intensity", "c", "drawLine", "x1", "y1", "x2", "y2", "sx", "sy", "err", "offsetY", "offsetX", "e2", "getPointTypeColor", "pointType", "drawLabel", "label", "drawCorners", "corners", "useOriginal", "result", "corner", "drawClusteredPoints", "clusters", "showLabels", "drawLines", "lines", "visualizeFeatures", "features", "options", "legendX", "legendY", "legendSpacing"]
}
