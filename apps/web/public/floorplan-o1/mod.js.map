{
  "version": 3,
  "sources": ["../../../../packages/floorplan-o1/types.ts", "../../../../packages/floorplan-o1/image-processor.ts", "../../../../packages/floorplan-o1/skeletonize.ts", "../../../../packages/floorplan-o1/feature-detection.ts", "../../../../packages/floorplan-o1/intersection-detection.ts", "../../../../packages/floorplan-o1/visualization.ts"],
  "sourcesContent": ["/**\n * Type definitions for the Floorplan O1 processor\n */\n\n/**\n * Represents a point in 2D space\n */\nexport type Point = { \n  x: number; \n  y: number;\n  type?: PointType; \n};\n\n/**\n * Represents a line segment between two points\n */\nexport type LineSegment = { \n  x1: number; \n  y1: number; \n  x2: number; \n  y2: number;\n};\n\n/**\n * Types of points based on their position in the floorplan\n */\nexport enum PointType {\n  CORNER = 'corner',\n  ENDPOINT = 'endpoint',\n  T_JUNCTION = 't_junction',\n  INTERSECTION = 'intersection',\n  UNCLASSIFIED = 'unclassified'\n}\n\n/**\n * Result of the skeletonization process\n */\nexport interface SkeletonResult {\n  skeleton: ImageData;\n  originalWidth: number;\n  originalHeight: number;\n  debugInfo: {\n    thresholdValue: number;\n    algorithm: string;\n  }\n}\n\n/**\n * Options for preprocessing and skeletonization\n */\nexport interface ProcessingOptions {\n  threshold?: number;\n  inverse?: boolean;\n  maxIterations?: number;\n}\n\n/**\n * Options for corner and feature detection\n */\nexport interface DetectionOptions {\n  minNeighbors?: number;\n  minTransitions?: number;\n}\n\n/**\n * Options for line detection\n */\nexport interface LineDetectionOptions {\n  threshold?: number;\n  minLineLength?: number;\n  maxLineGap?: number;\n  maxDistance?: number;\n}\n\n/**\n * Options for clustering points\n */\nexport interface ClusterOptions {\n  maxDistance?: number;\n}", "/**\n * Image processing utilities for the Floorplan O1 implementation\n */\nimport { ProcessingOptions } from \"./types.ts\";\n\n/**\n * Convert an HTML Image element to a canvas and get its ImageData\n */\nexport function imageToImageData(img: HTMLImageElement): ImageData {\n  const canvas = document.createElement('canvas');\n  canvas.width = img.width;\n  canvas.height = img.height;\n  const ctx = canvas.getContext('2d');\n  \n  if (!ctx) {\n    throw new Error('Could not get canvas context');\n  }\n  \n  ctx.drawImage(img, 0, 0);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\n\n/**\n * Loads an image from a File or URL into an Image object\n */\nexport function loadImage(src: string | File): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = \"Anonymous\"; // Allow cross-origin images if URL\n    \n    img.onload = () => resolve(img);\n    img.onerror = () => reject(new Error('Failed to load image'));\n    \n    if (typeof src === 'string') {\n      img.src = src;\n    } else {\n      img.src = URL.createObjectURL(src);\n    }\n  });\n}\n\n/**\n * Converts an ImageData to grayscale\n */\nexport function convertToGrayscale(imageData: ImageData): ImageData {\n  const { width, height, data } = imageData;\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d')!;\n  const grayImageData = ctx.createImageData(width, height);\n  const grayData = grayImageData.data;\n  \n  // Convert to grayscale\n  for (let i = 0; i < data.length; i += 4) {\n    // Standard grayscale conversion: 0.299*R + 0.587*G + 0.114*B\n    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];\n    \n    grayData[i] = gray;     // R\n    grayData[i + 1] = gray; // G\n    grayData[i + 2] = gray; // B\n    grayData[i + 3] = data[i + 3]; // Keep original alpha\n  }\n  \n  return grayImageData;\n}\n\n/**\n * Converts an ImageData to grayscale and applies binary thresholding.\n */\nexport function thresholdImage(\n  imageData: ImageData, \n  threshold: number = 128, \n  inverse: boolean = true\n): ImageData {\n  const { width, height, data } = imageData;\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d')!;\n  const binImageData = ctx.createImageData(width, height);\n  const binData = binImageData.data;\n  \n  // Convert to grayscale and threshold\n  for (let i = 0; i < data.length; i += 4) {\n    // Get luminance if not already grayscale\n    const gray = data[i] === data[i + 1] && data[i] === data[i + 2] \n      ? data[i] \n      : 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];\n      \n    // Apply threshold (with option to invert)\n    const val = inverse ? \n      (gray < threshold ? 255 : 0) : \n      (gray > threshold ? 255 : 0);\n    \n    binData[i] = val;     // R\n    binData[i + 1] = val; // G\n    binData[i + 2] = val; // B\n    binData[i + 3] = 255; // A (fully opaque)\n  }\n  \n  return binImageData;\n}\n\n/**\n * Renders an ImageData to a canvas\n */\nexport function renderImageDataToCanvas(imageData: ImageData, canvas: HTMLCanvasElement): void {\n  canvas.width = imageData.width;\n  canvas.height = imageData.height;\n  \n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    throw new Error('Could not get canvas context');\n  }\n  \n  ctx.putImageData(imageData, 0, 0);\n}\n\n/**\n * Preprocesses an image for floorplan analysis\n * Performs grayscale conversion and thresholding\n */\nexport function preprocessImage(\n  imageData: ImageData, \n  options?: ProcessingOptions\n): ImageData {\n  const threshold = options?.threshold || 128;\n  const inverse = options?.inverse !== undefined ? options.inverse : true;\n  \n  // Apply thresholding directly\n  return thresholdImage(imageData, threshold, inverse);\n}", "/**\n * Skeletonization implementation using Zhang-Suen thinning algorithm\n */\nimport { ProcessingOptions, SkeletonResult } from \"./types.ts\";\nimport { imageToImageData, loadImage, preprocessImage } from \"./image-processor.ts\";\n\n/**\n * Performs morphological thinning (skeletonization) on a binary ImageData.\n * Uses the Zhang-Suen algorithm to reduce lines to 1-pixel thickness.\n */\nexport function zhangSuenThinning(\n  imageData: ImageData, \n  maxIterations: number = 100\n): ImageData {\n  const { width, height, data } = imageData;\n  \n  // Create a copy of the input data for processing\n  const input = new Uint8ClampedArray(data);\n  \n  // Helper: get pixel value (1 for foreground, 0 for background)\n  const getPixel = (x: number, y: number): number => {\n    if (x < 0 || y < 0 || x >= width || y >= height) return 0;\n    const idx = (y * width + x) * 4;\n    return input[idx] > 0 ? 1 : 0;\n  };\n  \n  // Helper: set pixel value\n  const setPixel = (x: number, y: number, value: number): void => {\n    const idx = (y * width + x) * 4;\n    const val = value > 0 ? 255 : 0;\n    input[idx] = input[idx + 1] = input[idx + 2] = val;\n  };\n  \n  let pixelsRemoved = true;\n  let iterations = 0;\n  \n  while (pixelsRemoved && iterations < maxIterations) {\n    pixelsRemoved = false;\n    iterations++;\n    \n    // First sub-iteration\n    const toRemove1: [number, number][] = [];\n    \n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        if (getPixel(x, y) === 0) continue; // Skip background pixels\n        \n        // Get 8 neighbors (clockwise from top)\n        const p2 = getPixel(x, y-1);   // North\n        const p3 = getPixel(x+1, y-1); // Northeast\n        const p4 = getPixel(x+1, y);   // East\n        const p5 = getPixel(x+1, y+1); // Southeast\n        const p6 = getPixel(x, y+1);   // South\n        const p7 = getPixel(x-1, y+1); // Southwest\n        const p8 = getPixel(x-1, y);   // West\n        const p9 = getPixel(x-1, y-1); // Northwest\n        \n        const neighbors = [p2, p3, p4, p5, p6, p7, p8, p9];\n        \n        // Count foreground neighbors\n        const neighborSum = neighbors.reduce((sum, val) => sum + val, 0);\n        if (neighborSum < 2 || neighborSum > 6) continue;\n        \n        // Count 0->1 transitions in the ordered sequence\n        let transitions = 0;\n        for (let i = 0; i < neighbors.length; i++) {\n          if (neighbors[i] === 0 && neighbors[(i + 1) % neighbors.length] === 1) {\n            transitions++;\n          }\n        }\n        if (transitions !== 1) continue;\n        \n        // Check first sub-iteration conditions\n        // At least one of North, East, South is background\n        if (p2 * p4 * p6 !== 0) continue;\n        \n        // At least one of East, South, West is background\n        if (p4 * p6 * p8 !== 0) continue;\n        \n        // Mark for deletion\n        toRemove1.push([x, y]);\n      }\n    }\n    \n    // Apply first sub-iteration deletions\n    for (const [x, y] of toRemove1) {\n      setPixel(x, y, 0);\n      pixelsRemoved = true;\n    }\n    \n    // Second sub-iteration\n    const toRemove2: [number, number][] = [];\n    \n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        if (getPixel(x, y) === 0) continue;\n        \n        // Get 8 neighbors (clockwise from top)\n        const p2 = getPixel(x, y-1);   // North\n        const p3 = getPixel(x+1, y-1); // Northeast\n        const p4 = getPixel(x+1, y);   // East\n        const p5 = getPixel(x+1, y+1); // Southeast\n        const p6 = getPixel(x, y+1);   // South\n        const p7 = getPixel(x-1, y+1); // Southwest\n        const p8 = getPixel(x-1, y);   // West\n        const p9 = getPixel(x-1, y-1); // Northwest\n        \n        const neighbors = [p2, p3, p4, p5, p6, p7, p8, p9];\n        \n        // Count foreground neighbors\n        const neighborSum = neighbors.reduce((sum, val) => sum + val, 0);\n        if (neighborSum < 2 || neighborSum > 6) continue;\n        \n        // Count 0->1 transitions in the ordered sequence\n        let transitions = 0;\n        for (let i = 0; i < neighbors.length; i++) {\n          if (neighbors[i] === 0 && neighbors[(i + 1) % neighbors.length] === 1) {\n            transitions++;\n          }\n        }\n        if (transitions !== 1) continue;\n        \n        // Check second sub-iteration conditions\n        // At least one of North, East, West is background\n        if (p2 * p4 * p8 !== 0) continue;\n        \n        // At least one of North, South, West is background\n        if (p2 * p6 * p8 !== 0) continue;\n        \n        // Mark for deletion\n        toRemove2.push([x, y]);\n      }\n    }\n    \n    // Apply second sub-iteration deletions\n    for (const [x, y] of toRemove2) {\n      setPixel(x, y, 0);\n      pixelsRemoved = true;\n    }\n  }\n  \n  console.log(`[DEBUG] Thinning completed after ${iterations} iterations`);\n  \n  // Create output ImageData\n  const result = new Uint8ClampedArray(input);\n  return new ImageData(result, width, height);\n}\n\n/**\n * Main function to skeletonize an image using the Zhang-Suen thinning algorithm\n */\nexport async function skeletonizeImage(\n  imageSource: HTMLImageElement | string | File,\n  options?: ProcessingOptions  \n): Promise<SkeletonResult> {\n  // Load the image if it's a string URL or blob\n  const img = imageSource instanceof HTMLImageElement \n    ? imageSource \n    : await loadImage(imageSource);\n  \n  const originalWidth = img.width;\n  const originalHeight = img.height;\n  \n  console.log(`[DEBUG] Original (H\u00D7W): ${originalHeight} \u00D7 ${originalWidth}`);\n  \n  // 1. Convert to ImageData\n  const imageData = imageToImageData(img);\n  \n  // 2. Preprocess the image (convert to grayscale and threshold)\n  const threshold = options?.threshold ?? 128;\n  const inverse = options?.inverse ?? true;\n  const binaryImageData = preprocessImage(imageData, { threshold, inverse });\n  console.log('[DEBUG] After preprocessing (grayscale + threshold)');\n  \n  // 3. Apply Zhang-Suen thinning algorithm for skeletonization\n  const maxIterations = options?.maxIterations ?? 100;\n  const skelImageData = zhangSuenThinning(binaryImageData, maxIterations);\n  console.log('[DEBUG] After thinning with Zhang-Suen algorithm');\n  \n  // 4. Return the processed image with metadata\n  return {\n    skeleton: skelImageData,\n    originalWidth,\n    originalHeight,\n    debugInfo: {\n      thresholdValue: threshold,\n      algorithm: \"Zhang-Suen thinning algorithm\"\n    }\n  };\n}", "/**\n * Feature detection functions for the floorplan processor\n */\nimport { Point, DetectionOptions, LineDetectionOptions, ClusterOptions, LineSegment } from \"./types.ts\";\n\n/**\n * Detects corner points in a binary image using pattern recognition.\n * This is an implementation specifically optimized for detecting wall intersections in floorplans.\n * \n * @param imageData - Skeletonized binary image\n * @param options - Detection options\n * @returns Array of detected corner points {x, y}\n */\nexport function detectCorners(\n  imageData: ImageData, \n  options: DetectionOptions = {}\n): Point[] {\n  const { width, height, data } = imageData;\n  const corners: Point[] = [];\n\n  // Default parameter values\n  const minNeighbors = options.minNeighbors ?? 3;\n  const minTransitions = options.minTransitions ?? 2;\n\n  // Helper function to check if a pixel is a corner candidate\n  const isCornerCandidate = (x: number, y: number): boolean => {\n    if (x <= 1 || y <= 1 || x >= width - 2 || y >= height - 2) return false;\n    \n    // Check if this is a foreground pixel\n    const idx = (y * width + x) * 4;\n    if (data[idx] === 0) return false;\n    \n    // Count neighbors (in 3x3 window)\n    let neighborCount = 0;\n    let transitions = 0;\n    const neighborVals: number[] = [];\n\n    // Collect neighbor values in 8-connected neighborhood\n    for (let j = -1; j <= 1; j++) {\n      for (let i = -1; i <= 1; i++) {\n        if (i === 0 && j === 0) continue; // Skip center pixel\n        \n        const nx = x + i;\n        const ny = y + j;\n        const nidx = (ny * width + nx) * 4;\n        \n        const val = data[nidx] > 0 ? 1 : 0;\n        neighborVals.push(val);\n        if (val === 1) neighborCount++;\n      }\n    }\n\n    // Count 0->1 transitions in circular order\n    for (let i = 0; i < neighborVals.length; i++) {\n      if (neighborVals[i] === 0 && neighborVals[(i + 1) % 8] === 1) {\n        transitions++;\n      }\n    }\n\n    // A corner should have sufficient foreground neighbors\n    // and enough transitions (for T-junction or X-crossing)\n    return neighborCount >= minNeighbors && transitions >= minTransitions;\n  };\n\n  // Scan the image for corner candidates\n  for (let y = 2; y < height - 2; y++) {\n    for (let x = 2; x < width - 2; x++) {\n      if (isCornerCandidate(x, y)) {\n        corners.push({ x, y });\n      }\n    }\n  }\n\n  console.log(`[DEBUG] Detected ${corners.length} corner candidates`);\n  return corners;\n}\n\n/**\n * Clusters nearby points into a single point using distance-based clustering.\n * \n * @param points - Array of points {x, y}\n * @param options - Clustering options\n * @returns Array of clustered points (centroids)\n */\nexport function clusterPoints(\n  points: Point[], \n  options: ClusterOptions = {}\n): Point[] {\n  if (points.length === 0) return [];\n\n  const maxDistance = options.maxDistance ?? 10;\n\n  // Create clusters initially containing one point each\n  let clusters: (Point[] | null)[] = points.map(point => [point]);\n  let mergeOccurred = true;\n\n  // Iteratively merge clusters until no more merges occur\n  while (mergeOccurred) {\n    mergeOccurred = false;\n\n    for (let i = 0; i < clusters.length; i++) {\n      if (!clusters[i]) continue; // Skip already merged clusters\n\n      for (let j = i + 1; j < clusters.length; j++) {\n        if (!clusters[j]) continue; // Skip already merged clusters\n\n        // Check distance between clusters\n        const canMerge = clusters[i]!.some(p1 => \n          clusters[j]!.some(p2 => {\n            const dx = p1.x - p2.x;\n            const dy = p1.y - p2.y;\n            return Math.sqrt(dx*dx + dy*dy) <= maxDistance;\n          })\n        );\n\n        // Merge clusters if they're close enough\n        if (canMerge) {\n          clusters[i] = clusters[i]!.concat(clusters[j]!);\n          clusters[j] = null; // Mark as merged\n          mergeOccurred = true;\n        }\n      }\n    }\n\n    // Filter out null clusters\n    if (mergeOccurred) {\n      clusters = clusters.filter(cluster => cluster !== null);\n    }\n  }\n\n  // Calculate centroids (averages) for each cluster\n  return clusters.map(cluster => {\n    const sumX = cluster!.reduce((sum, p) => sum + p.x, 0);\n    const sumY = cluster!.reduce((sum, p) => sum + p.y, 0);\n    return { \n      x: Math.round(sumX / cluster!.length), \n      y: Math.round(sumY / cluster!.length) \n    };\n  });\n}\n\n/**\n * Detects straight line segments in the skeleton image using a simplified Hough transform approach.\n * \n * @param imageData - Binary image data\n * @param options - Line detection options\n * @returns Array of detected line segments { x1, y1, x2, y2 }\n */\nexport function detectStraightLines(\n  imageData: ImageData,\n  options: LineDetectionOptions = {}\n): LineSegment[] {\n  const { width, height, data } = imageData;\n  const lines: LineSegment[] = [];\n  \n  // Default parameter values\n  const threshold = options.threshold ?? 30;\n  const minLineLength = options.minLineLength ?? 20;\n  const maxLineGap = options.maxLineGap ?? 5;\n  const maxDistance = options.maxDistance ?? 5;\n  \n  // Extract foreground pixel coordinates\n  const points: Point[] = [];\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const idx = (y * width + x) * 4;\n      if (data[idx] > 0) {\n        points.push({x, y});\n      }\n    }\n  }\n  \n  // Simple implementation of probabilistic Hough transform\n  // We'll use a simplified approach by checking groups of points\n  // and finding straight lines among them\n  const angleStep = Math.PI / 180;\n  \n  // Group points by potential lines\n  for (let i = 0; i < points.length; i++) {\n    const p1 = points[i];\n    \n    for (let angleIdx = 0; angleIdx < 180; angleIdx++) {\n      const theta = angleIdx * angleStep;\n      const cosTheta = Math.cos(theta);\n      const sinTheta = Math.sin(theta);\n      \n      // Find points that lie on this angle from p1\n      const potentialLinePoints: Point[] = [];\n      potentialLinePoints.push(p1);\n      \n      // Check other points to see if they lie close to this line\n      for (let j = 0; j < points.length; j++) {\n        if (i === j) continue;\n        \n        const p2 = points[j];\n        const dx = p2.x - p1.x;\n        const dy = p2.y - p1.y;\n        \n        // Distance from point to line\n        const dist = Math.abs(-sinTheta * p2.x + cosTheta * p2.y - \n                            (-sinTheta * p1.x + cosTheta * p1.y));\n        \n        if (dist <= maxDistance) {\n          potentialLinePoints.push(p2);\n        }\n      }\n      \n      // If we have enough points, consider this a line\n      if (potentialLinePoints.length >= threshold) {\n        // Sort points to find endpoints\n        potentialLinePoints.sort((a, b) => {\n          return (a.x - p1.x) * cosTheta + (a.y - p1.y) * sinTheta - \n                 ((b.x - p1.x) * cosTheta + (b.y - p1.y) * sinTheta);\n        });\n        \n        // Get first and last point of sorted array as line endpoints\n        const first = potentialLinePoints[0];\n        const last = potentialLinePoints[potentialLinePoints.length - 1];\n        \n        // Calculate length\n        const dx = last.x - first.x;\n        const dy = last.y - first.y;\n        const length = Math.sqrt(dx*dx + dy*dy);\n        \n        // Add line if it meets length requirement\n        if (length >= minLineLength) {\n          lines.push({\n            x1: first.x,\n            y1: first.y,\n            x2: last.x,\n            y2: last.y\n          });\n        }\n      }\n    }\n  }\n  \n  // Filter duplicate lines\n  const filteredLines: LineSegment[] = [];\n  for (const line of lines) {\n    const isDuplicate = filteredLines.some(l => {\n      const d1 = Math.hypot(l.x1 - line.x1, l.y1 - line.y1) + \n                Math.hypot(l.x2 - line.x2, l.y2 - line.y2);\n      const d2 = Math.hypot(l.x1 - line.x2, l.y1 - line.y2) + \n                Math.hypot(l.x2 - line.x1, l.y2 - line.y1);\n      return d1 <= maxLineGap*2 || d2 <= maxLineGap*2;\n    });\n    \n    if (!isDuplicate) {\n      filteredLines.push(line);\n    }\n  }\n  \n  console.log(`[DEBUG] Detected ${filteredLines.length} line segments`);\n  return filteredLines;\n}", "/**\n * Line intersection detection functions\n */\nimport { Point, LineSegment, PointType } from \"./types.ts\";\n\n/**\n * Calculate intersection point of two lines (if any).\n * \n * @param line1 - First line segment {x1, y1, x2, y2}\n * @param line2 - Second line segment {x1, y1, x2, y2}\n * @returns Point of intersection {x, y} or null if no intersection\n */\nexport function intersectLines(line1: LineSegment, line2: LineSegment): Point | null {\n  // Represent line1 in parametric form: P1 + t*(P2-P1)\n  const {x1, y1, x2, y2} = line1;\n  const {x1: x3, y1: y3, x2: x4, y2: y4} = line2;\n  \n  // Compute denominator\n  const denom = (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4);\n  if (Math.abs(denom) < 1e-6) {\n    return null; // Lines are parallel or nearly parallel\n  }\n  \n  // Intersection point\n  const intersectX = ((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4)) / denom;\n  const intersectY = ((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4)) / denom;\n  \n  // Check if intersection is within the line segments\n  const between = (a: number, b: number, c: number): boolean => \n    (a >= Math.min(b, c) - 1e-6 && a <= Math.max(b, c) + 1e-6);\n  \n  if (\n    between(intersectX, x1, x2) && between(intersectY, y1, y2) &&\n    between(intersectX, x3, x4) && between(intersectY, y3, y4)\n  ) {\n    return { x: intersectX, y: intersectY };\n  }\n  \n  return null;\n}\n\n/**\n * Find all intersection points between a set of detected lines\n * \n * @param lines - Array of line segments {x1, y1, x2, y2}\n * @returns Array of intersection points {x, y}\n */\nexport function findIntersections(lines: LineSegment[]): Point[] {\n  const intersections: Point[] = [];\n  \n  // Check all unique line pairs for intersections\n  for (let i = 0; i < lines.length; i++) {\n    for (let j = i + 1; j < lines.length; j++) {\n      const intersection = intersectLines(lines[i], lines[j]);\n      if (intersection) {\n        // Mark this as an intersection point type\n        intersection.type = PointType.INTERSECTION;\n        intersections.push(intersection);\n      }\n    }\n  }\n  \n  console.log(`[DEBUG] Found ${intersections.length} line intersections`);\n  return intersections;\n}\n\n/**\n * Extract endpoints from lines as potential corner points\n * \n * @param lines - Array of line segments\n * @returns Array of endpoint points\n */\nexport function extractEndpoints(lines: LineSegment[]): Point[] {\n  const endpoints: Point[] = [];\n  \n  for (const line of lines) {\n    // Add both endpoints of the line\n    endpoints.push({ x: line.x1, y: line.y1, type: PointType.ENDPOINT });\n    endpoints.push({ x: line.x2, y: line.y2, type: PointType.ENDPOINT }); // Fixed y2 coordinate\n  }\n  \n  return endpoints;\n}\n\n/**\n * Combine all detected points: corners, intersections, and optionally endpoints\n * \n * @param corners - Detected corner points\n * @param intersections - Line intersection points\n * @param endpoints - Optional line endpoints to include\n * @returns Combined array of points\n */\nexport function combineFeaturePoints(\n  corners: Point[], \n  intersections: Point[], \n  endpoints: Point[] = []\n): Point[] {\n  return [...corners, ...intersections, ...endpoints];\n}", "/**\n * Visualization functions for drawing detected features on floorplan images\n */\nimport { Point, LineSegment } from \"./types.ts\";\n\n/**\n * Helper function to set a pixel color in an ImageData\n */\nfunction setPixelColor(\n  imageData: ImageData,\n  x: number,\n  y: number,\n  r: number,\n  g: number,\n  b: number\n): void {\n  if (x < 0 || y < 0 || x >= imageData.width || y >= imageData.height) return;\n  const idx = (y * imageData.width + x) * 4;\n  imageData.data[idx] = r;\n  imageData.data[idx + 1] = g;\n  imageData.data[idx + 2] = b;\n}\n\n/**\n * Draw a point with its neighborhood on the image\n */\nfunction drawPoint(\n  imageData: ImageData,\n  point: Point,\n  size: number = 3,\n  color: [number, number, number] = [255, 0, 0]\n): void {\n  const halfSize = Math.floor(size / 2);\n  for (let dy = -halfSize; dy <= halfSize; dy++) {\n    for (let dx = -halfSize; dx <= halfSize; dx++) {\n      // Make the center brighter\n      const intensity = (dx === 0 && dy === 0) ? 255 : 180;\n      const [r, g, b] = color.map(c => Math.min(255, (c * intensity) / 255));\n      setPixelColor(imageData, point.x + dx, point.y + dy, r, g, b);\n    }\n  }\n}\n\n/**\n * Draw a line segment using Bresenham's algorithm\n */\nfunction drawLine(\n  imageData: ImageData,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  color: [number, number, number] = [0, 0, 255]\n): void {\n  const [r, g, b] = color;\n  const dx = Math.abs(x2 - x1);\n  const dy = Math.abs(y2 - y1);\n  const sx = x1 < x2 ? 1 : -1;\n  const sy = y1 < y2 ? 1 : -1;\n  let err = dx - dy;\n  \n  let x = x1;\n  let y = y1;\n  \n  while (true) {\n    setPixelColor(imageData, x, y, r, g, b);\n    \n    if (x === x2 && y === y2) break;\n    \n    const e2 = 2 * err;\n    if (e2 > -dy) {\n      err -= dy;\n      x += sx;\n    }\n    if (e2 < dx) {\n      err += dx;\n      y += sy;\n    }\n  }\n}\n\n/**\n * Draws detected corners on an image.\n * \n * @param imageData - Image to draw on\n * @param corners - Array of corner points {x, y}\n * @param useOriginal - If true, modifies input imageData; otherwise makes a copy\n * @returns Modified image with corners highlighted\n */\nexport function drawCorners(\n  imageData: ImageData, \n  corners: Point[], \n  useOriginal: boolean = false\n): ImageData {\n  // Create a copy of the input image if needed\n  const result = useOriginal ? \n    imageData : \n    new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);\n  \n  // Draw each corner point\n  for (const corner of corners) {\n    const color: [number, number, number] = [255, 0, 0]; // Red for corners\n    drawPoint(result, corner, 3, color);\n  }\n  \n  return result;\n}\n\n/**\n * Draws clustered points on the image.\n *\n * @param imageData - Image to draw on\n * @param clusters - Array of cluster points {x, y}\n * @param useOriginal - If true, modifies input imageData; otherwise makes a copy\n * @returns Modified image with clustered points highlighted\n */\nexport function drawClusteredPoints(\n  imageData: ImageData, \n  clusters: Point[], \n  useOriginal: boolean = false\n): ImageData {\n  // Create a copy of the input image if needed\n  const result = useOriginal ? \n    imageData : \n    new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);\n  \n  // Draw each cluster centroid\n  for (const point of clusters) {\n    const color: [number, number, number] = [0, 255, 0]; // Green for clusters\n    drawPoint(result, point, 5, color);\n  }\n  \n  return result;\n}\n\n/**\n * Draws detected lines on the image.\n *\n * @param imageData - Image to draw on\n * @param lines - Array of line segments {x1, y1, x2, y2}\n * @param useOriginal - If true, modifies input imageData; otherwise makes a copy\n * @returns Modified image with lines highlighted\n */\nexport function drawLines(\n  imageData: ImageData, \n  lines: LineSegment[], \n  useOriginal: boolean = false\n): ImageData {\n  // Create a copy of the input image if needed\n  const result = useOriginal ? \n    imageData : \n    new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);\n  \n  // Draw each line\n  for (const { x1, y1, x2, y2 } of lines) {\n    drawLine(\n      result, \n      Math.round(x1), \n      Math.round(y1), \n      Math.round(x2), \n      Math.round(y2),\n      [0, 0, 255] // Blue for lines\n    );\n  }\n  \n  return result;\n}\n\n/**\n * Draw all detected features on the image\n * \n * @param imageData - Base image to draw on\n * @param features - Object containing all features to draw\n * @param useOriginal - Whether to modify input image or create copy\n * @returns Modified image with all features drawn\n */\nexport function visualizeFeatures(\n  imageData: ImageData,\n  features: {\n    corners?: Point[];\n    clusters?: Point[];\n    lines?: LineSegment[];\n    intersections?: Point[];\n  },\n  useOriginal: boolean = false\n): ImageData {\n  const result = useOriginal ? \n    imageData : \n    new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);\n  \n  // Draw features in order: lines, corners, intersections, clusters\n  if (features.lines) {\n    drawLines(result, features.lines, true);\n  }\n  \n  if (features.corners) {\n    drawCorners(result, features.corners, true);\n  }\n  \n  if (features.intersections) {\n    // Draw intersections in purple\n    for (const point of features.intersections) {\n      drawPoint(result, point, 3, [255, 0, 255]);\n    }\n  }\n  \n  if (features.clusters) {\n    drawClusteredPoints(result, features.clusters, true);\n  }\n  \n  return result;\n}"],
  "mappings": "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",
  "names": ["PointType", "imageToImageData", "img", "canvas", "ctx", "loadImage", "src", "resolve", "reject", "convertToGrayscale", "imageData", "width", "height", "data", "grayImageData", "grayData", "i", "gray", "thresholdImage", "threshold", "inverse", "binImageData", "binData", "val", "renderImageDataToCanvas", "preprocessImage", "options", "zhangSuenThinning", "imageData", "maxIterations", "width", "height", "data", "input", "getPixel", "x", "y", "idx", "setPixel", "value", "val", "pixelsRemoved", "iterations", "toRemove1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "neighbors", "neighborSum", "sum", "transitions", "i", "toRemove2", "result", "skeletonizeImage", "imageSource", "options", "img", "loadImage", "originalWidth", "originalHeight", "imageToImageData", "threshold", "inverse", "binaryImageData", "preprocessImage", "skelImageData", "detectCorners", "imageData", "options", "width", "height", "data", "corners", "minNeighbors", "minTransitions", "isCornerCandidate", "x", "y", "idx", "neighborCount", "transitions", "neighborVals", "j", "i", "nx", "nidx", "val", "clusterPoints", "points", "maxDistance", "clusters", "point", "mergeOccurred", "p1", "p2", "dx", "dy", "cluster", "sumX", "sum", "p", "sumY", "detectStraightLines", "lines", "threshold", "minLineLength", "maxLineGap", "angleStep", "angleIdx", "theta", "cosTheta", "sinTheta", "potentialLinePoints", "a", "b", "first", "last", "filteredLines", "line", "l", "d1", "d2", "intersectLines", "line1", "line2", "x1", "y1", "x2", "y2", "x3", "y3", "x4", "y4", "denom", "intersectX", "intersectY", "between", "a", "b", "c", "findIntersections", "lines", "intersections", "i", "j", "intersection", "extractEndpoints", "endpoints", "line", "combineFeaturePoints", "corners", "setPixelColor", "imageData", "x", "y", "r", "g", "b", "idx", "drawPoint", "point", "size", "color", "halfSize", "dy", "dx", "intensity", "c", "drawLine", "x1", "y1", "x2", "y2", "sx", "sy", "err", "e2", "drawCorners", "corners", "useOriginal", "result", "corner", "drawClusteredPoints", "clusters", "drawLines", "lines", "visualizeFeatures", "features"]
}
