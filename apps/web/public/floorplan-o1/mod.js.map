{
  "version": 3,
  "sources": ["../../../../packages/floorplan-o1/types.ts", "../../../../packages/floorplan-o1/image-processor.ts", "../../../../packages/floorplan-o1/skeletonize.ts", "../../../../packages/floorplan-o1/feature-detection.ts", "../../../../packages/floorplan-o1/intersection-detection.ts", "../../../../packages/floorplan-o1/visualization.ts"],
  "sourcesContent": ["/**\n * Type definitions for the Floorplan O1 processor\n */\n\n/**\n * Represents a point in 2D space\n */\nexport type Point = { \n  x: number; \n  y: number;\n  type?: PointType; \n  count?: number; // For tracking cluster sizes\n};\n\n/**\n * Represents a line segment between two points\n */\nexport type LineSegment = { \n  x1: number; \n  y1: number; \n  x2: number; \n  y2: number;\n};\n\n/**\n * Types of points based on their position in the floorplan\n */\nexport enum PointType {\n  CORNER = 'corner',\n  ENDPOINT = 'endpoint',\n  T_JUNCTION = 't_junction',\n  INTERSECTION = 'intersection',\n  UNCLASSIFIED = 'unclassified'\n}\n\n/**\n * Result of the skeletonization process\n */\nexport interface SkeletonResult {\n  skeleton: ImageData;\n  originalWidth: number;\n  originalHeight: number;\n  debugInfo: {\n    thresholdValue: number;\n    algorithm: string;\n  }\n}\n\n/**\n * Options for preprocessing and skeletonization\n */\nexport interface ProcessingOptions {\n  threshold?: number;\n  inverse?: boolean;\n  maxIterations?: number;\n}\n\n/**\n * Options for corner and feature detection\n */\nexport interface DetectionOptions {\n  minNeighbors?: number;\n  minTransitions?: number;\n  includeTypes?: PointType[]; // Types of points to include in detection\n}\n\n/**\n * Options for line detection\n */\nexport interface LineDetectionOptions {\n  threshold?: number;\n  minLineLength?: number;\n  maxLineGap?: number;\n  maxDistance?: number;\n}\n\n/**\n * Options for clustering points\n */\nexport interface ClusterOptions {\n  maxDistance?: number;\n  distanceThreshold?: number; // Maximum distance threshold for including points in clustering\n  minClusterSize?: number;   // Minimum number of points in a cluster to be considered valid\n  validateWalls?: boolean;   // Whether to validate that clusters are actually on walls\n  preserveTypes?: boolean;   // Whether to group points by type before clustering\n}", "/**\n * Image processing utilities for the Floorplan O1 implementation\n */\nimport { ProcessingOptions } from \"./types.ts\";\n\n/**\n * Convert an HTML Image element to a canvas and get its ImageData\n */\nexport function imageToImageData(img: HTMLImageElement): ImageData {\n  const canvas = document.createElement('canvas');\n  canvas.width = img.width;\n  canvas.height = img.height;\n  const ctx = canvas.getContext('2d');\n  \n  if (!ctx) {\n    throw new Error('Could not get canvas context');\n  }\n  \n  ctx.drawImage(img, 0, 0);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\n\n/**\n * Loads an image from a File or URL into an Image object\n */\nexport function loadImage(src: string | File): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = \"Anonymous\"; // Allow cross-origin images if URL\n    \n    img.onload = () => resolve(img);\n    img.onerror = () => reject(new Error('Failed to load image'));\n    \n    if (typeof src === 'string') {\n      img.src = src;\n    } else {\n      img.src = URL.createObjectURL(src);\n    }\n  });\n}\n\n/**\n * Converts an ImageData to grayscale\n */\nexport function convertToGrayscale(imageData: ImageData): ImageData {\n  const { width, height, data } = imageData;\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d')!;\n  const grayImageData = ctx.createImageData(width, height);\n  const grayData = grayImageData.data;\n  \n  // Convert to grayscale\n  for (let i = 0; i < data.length; i += 4) {\n    // Standard grayscale conversion: 0.299*R + 0.587*G + 0.114*B\n    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];\n    \n    grayData[i] = gray;     // R\n    grayData[i + 1] = gray; // G\n    grayData[i + 2] = gray; // B\n    grayData[i + 3] = data[i + 3]; // Keep original alpha\n  }\n  \n  return grayImageData;\n}\n\n/**\n * Converts an ImageData to grayscale and applies binary thresholding.\n */\nexport function thresholdImage(\n  imageData: ImageData, \n  threshold: number = 128, \n  inverse: boolean = true\n): ImageData {\n  const { width, height, data } = imageData;\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d')!;\n  const binImageData = ctx.createImageData(width, height);\n  const binData = binImageData.data;\n  \n  // Convert to grayscale and threshold\n  for (let i = 0; i < data.length; i += 4) {\n    // Get luminance if not already grayscale\n    const gray = data[i] === data[i + 1] && data[i] === data[i + 2] \n      ? data[i] \n      : 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];\n      \n    // Apply threshold (with option to invert)\n    const val = inverse ? \n      (gray < threshold ? 255 : 0) : \n      (gray > threshold ? 255 : 0);\n    \n    binData[i] = val;     // R\n    binData[i + 1] = val; // G\n    binData[i + 2] = val; // B\n    binData[i + 3] = 255; // A (fully opaque)\n  }\n  \n  return binImageData;\n}\n\n/**\n * Renders an ImageData to a canvas\n */\nexport function renderImageDataToCanvas(imageData: ImageData, canvas: HTMLCanvasElement): void {\n  canvas.width = imageData.width;\n  canvas.height = imageData.height;\n  \n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    throw new Error('Could not get canvas context');\n  }\n  \n  ctx.putImageData(imageData, 0, 0);\n}\n\n/**\n * Preprocesses an image for floorplan analysis\n * Performs grayscale conversion and thresholding\n */\nexport function preprocessImage(\n  imageData: ImageData, \n  options?: ProcessingOptions\n): ImageData {\n  const threshold = options?.threshold || 128;\n  const inverse = options?.inverse !== undefined ? options.inverse : true;\n  \n  // Apply thresholding directly\n  return thresholdImage(imageData, threshold, inverse);\n}", "/**\n * Skeletonization implementation using Zhang-Suen thinning algorithm\n */\nimport { ProcessingOptions, SkeletonResult } from \"./types.ts\";\nimport { imageToImageData, loadImage, preprocessImage } from \"./image-processor.ts\";\n\n/**\n * Performs morphological thinning (skeletonization) on a binary ImageData.\n * Uses the Zhang-Suen algorithm to reduce lines to 1-pixel thickness.\n */\nexport function zhangSuenThinning(\n  imageData: ImageData, \n  maxIterations: number = 100\n): ImageData {\n  const { width, height, data } = imageData;\n  \n  // Create a copy of the input data for processing\n  const input = new Uint8ClampedArray(data);\n  \n  // Helper: get pixel value (1 for foreground, 0 for background)\n  const getPixel = (x: number, y: number): number => {\n    if (x < 0 || y < 0 || x >= width || y >= height) return 0;\n    const idx = (y * width + x) * 4;\n    return input[idx] > 0 ? 1 : 0;\n  };\n  \n  // Helper: set pixel value\n  const setPixel = (x: number, y: number, value: number): void => {\n    const idx = (y * width + x) * 4;\n    const val = value > 0 ? 255 : 0;\n    input[idx] = input[idx + 1] = input[idx + 2] = val;\n  };\n  \n  let pixelsRemoved = true;\n  let iterations = 0;\n  \n  while (pixelsRemoved && iterations < maxIterations) {\n    pixelsRemoved = false;\n    iterations++;\n    \n    // First sub-iteration\n    const toRemove1: [number, number][] = [];\n    \n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        if (getPixel(x, y) === 0) continue; // Skip background pixels\n        \n        // Get 8 neighbors (clockwise from top)\n        const p2 = getPixel(x, y-1);   // North\n        const p3 = getPixel(x+1, y-1); // Northeast\n        const p4 = getPixel(x+1, y);   // East\n        const p5 = getPixel(x+1, y+1); // Southeast\n        const p6 = getPixel(x, y+1);   // South\n        const p7 = getPixel(x-1, y+1); // Southwest\n        const p8 = getPixel(x-1, y);   // West\n        const p9 = getPixel(x-1, y-1); // Northwest\n        \n        const neighbors = [p2, p3, p4, p5, p6, p7, p8, p9];\n        \n        // Count foreground neighbors\n        const neighborSum = neighbors.reduce((sum, val) => sum + val, 0);\n        if (neighborSum < 2 || neighborSum > 6) continue;\n        \n        // Count 0->1 transitions in the ordered sequence\n        let transitions = 0;\n        for (let i = 0; i < neighbors.length; i++) {\n          if (neighbors[i] === 0 && neighbors[(i + 1) % neighbors.length] === 1) {\n            transitions++;\n          }\n        }\n        if (transitions !== 1) continue;\n        \n        // Check first sub-iteration conditions\n        // At least one of North, East, South is background\n        if (p2 * p4 * p6 !== 0) continue;\n        \n        // At least one of East, South, West is background\n        if (p4 * p6 * p8 !== 0) continue;\n        \n        // Mark for deletion\n        toRemove1.push([x, y]);\n      }\n    }\n    \n    // Apply first sub-iteration deletions\n    for (const [x, y] of toRemove1) {\n      setPixel(x, y, 0);\n      pixelsRemoved = true;\n    }\n    \n    // Second sub-iteration\n    const toRemove2: [number, number][] = [];\n    \n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        if (getPixel(x, y) === 0) continue;\n        \n        // Get 8 neighbors (clockwise from top)\n        const p2 = getPixel(x, y-1);   // North\n        const p3 = getPixel(x+1, y-1); // Northeast\n        const p4 = getPixel(x+1, y);   // East\n        const p5 = getPixel(x+1, y+1); // Southeast\n        const p6 = getPixel(x, y+1);   // South\n        const p7 = getPixel(x-1, y+1); // Southwest\n        const p8 = getPixel(x-1, y);   // West\n        const p9 = getPixel(x-1, y-1); // Northwest\n        \n        const neighbors = [p2, p3, p4, p5, p6, p7, p8, p9];\n        \n        // Count foreground neighbors\n        const neighborSum = neighbors.reduce((sum, val) => sum + val, 0);\n        if (neighborSum < 2 || neighborSum > 6) continue;\n        \n        // Count 0->1 transitions in the ordered sequence\n        let transitions = 0;\n        for (let i = 0; i < neighbors.length; i++) {\n          if (neighbors[i] === 0 && neighbors[(i + 1) % neighbors.length] === 1) {\n            transitions++;\n          }\n        }\n        if (transitions !== 1) continue;\n        \n        // Check second sub-iteration conditions\n        // At least one of North, East, West is background\n        if (p2 * p4 * p8 !== 0) continue;\n        \n        // At least one of North, South, West is background\n        if (p2 * p6 * p8 !== 0) continue;\n        \n        // Mark for deletion\n        toRemove2.push([x, y]);\n      }\n    }\n    \n    // Apply second sub-iteration deletions\n    for (const [x, y] of toRemove2) {\n      setPixel(x, y, 0);\n      pixelsRemoved = true;\n    }\n  }\n  \n  console.log(`[DEBUG] Thinning completed after ${iterations} iterations`);\n  \n  // Create output ImageData\n  const result = new Uint8ClampedArray(input);\n  return new ImageData(result, width, height);\n}\n\n/**\n * Main function to skeletonize an image using the Zhang-Suen thinning algorithm\n */\nexport async function skeletonizeImage(\n  imageSource: HTMLImageElement | string | File,\n  options?: ProcessingOptions  \n): Promise<SkeletonResult> {\n  // Load the image if it's a string URL or blob\n  const img = imageSource instanceof HTMLImageElement \n    ? imageSource \n    : await loadImage(imageSource);\n  \n  const originalWidth = img.width;\n  const originalHeight = img.height;\n  \n  console.log(`[DEBUG] Original (H\u00D7W): ${originalHeight} \u00D7 ${originalWidth}`);\n  \n  // 1. Convert to ImageData\n  const imageData = imageToImageData(img);\n  \n  // 2. Preprocess the image (convert to grayscale and threshold)\n  const threshold = options?.threshold ?? 128;\n  const inverse = options?.inverse ?? true;\n  const binaryImageData = preprocessImage(imageData, { threshold, inverse });\n  console.log('[DEBUG] After preprocessing (grayscale + threshold)');\n  \n  // 3. Apply Zhang-Suen thinning algorithm for skeletonization\n  const maxIterations = options?.maxIterations ?? 100;\n  const skelImageData = zhangSuenThinning(binaryImageData, maxIterations);\n  console.log('[DEBUG] After thinning with Zhang-Suen algorithm');\n  \n  // 4. Return the processed image with metadata\n  return {\n    skeleton: skelImageData,\n    originalWidth,\n    originalHeight,\n    debugInfo: {\n      thresholdValue: threshold,\n      algorithm: \"Zhang-Suen thinning algorithm\"\n    }\n  };\n}", "/**\n * Feature detection functions for the floorplan processor\n */\nimport { Point, DetectionOptions, LineDetectionOptions, ClusterOptions, LineSegment, PointType } from \"./types.ts\";\n\n/**\n * Classifies a point based on its neighborhood pattern\n * Enhanced to better detect junctions, corners and endpoints\n * \n * @param neighborhood A 3x3 array of pixel values (0 or 255)\n * @returns The point type\n */\nexport function classifyJunctionType(neighborhood: number[]): PointType {\n  // Count total foreground neighbors\n  const neighbors = neighborhood.reduce((sum, val) => sum + val, 0);\n  \n  // Count transitions from 0 to 1\n  let transitions = 0;\n  for (let i = 0; i < neighborhood.length; i++) {\n    if (neighborhood[i] === 0 && neighborhood[(i + 1) % neighborhood.length] === 1) {\n      transitions++;\n    }\n  }\n  \n  // Create a continuous pattern string for easier pattern matching\n  const patternString = neighborhood.join('') + neighborhood[0]; // Add first element to end for circular pattern\n  \n  // Enhanced endpoint detection - more permissive to catch more endpoints\n  if (neighbors === 1 || (neighbors === 2 && transitions >= 2)) {\n    // Basic endpoint case: only one neighbor\n    if (neighbors === 1) {\n      return PointType.ENDPOINT;\n    }\n    \n    // Special case for endpoints with 2 neighbors that might be part of thin lines\n    // Check if they're adjacent which would suggest it's part of a thin line end\n    for (let i = 0; i < neighborhood.length; i++) {\n      if (neighborhood[i] === 1 && neighborhood[(i + 1) % 8] === 1) {\n        return PointType.ENDPOINT;\n      }\n    }\n  }\n  \n  // Enhanced corner detection (L-junction)\n  if (neighbors === 2) {\n    if (transitions === 2) {\n      // Check if the two branches are adjacent for a real corner\n      // Non-adjacent branches indicate a straight line segment, not a corner\n      for (let i = 0; i < neighborhood.length; i++) {\n        if (neighborhood[i] === 1 && neighborhood[(i + 1) % 8] === 1) {\n          return PointType.UNCLASSIFIED; // Adjacent branches indicate a potential line segment\n        }\n      }\n      // Two non-adjacent branches with transition count 2 is a corner\n      return PointType.CORNER;\n    }\n    \n    // Check for additional corner patterns\n    // Look for two branches that are approximately 90\u00B0 apart\n    const cornerPatterns = [\n      '10000100', // \u250C pattern\n      '01000010', // \u2510 pattern  \n      '00100001', // \u2514 pattern\n      '00010001'  // \u2518 pattern\n    ];\n    if (cornerPatterns.some(p => patternString.includes(p))) {\n      return PointType.CORNER;\n    }\n  }\n  \n  // Enhanced T-junction detection\n  if (neighbors === 3) {\n    if (transitions === 2) {\n      return PointType.T_JUNCTION;\n    }\n    \n    // Check for additional T-junction patterns\n    const tPatterns = [\n      '10001000', // \u252C pattern\n      '01000100', // \u2524 pattern\n      '00100010', // \u2534 pattern\n      '00010001'  // \u251C pattern\n    ];\n    if (tPatterns.some(p => patternString.includes(p))) {\n      return PointType.T_JUNCTION;\n    }\n  }\n  \n  // Handle complex junctions with 4 or more branches\n  if (neighbors >= 4 && transitions >= 2) {\n    return PointType.INTERSECTION; \n  }\n  \n  return PointType.UNCLASSIFIED;\n}\n\n/**\n * Extract a 3x3 neighborhood from ImageData at position (x,y)\n */\nfunction getNeighborhood(imageData: ImageData, x: number, y: number): number[] {\n  const { width, height, data } = imageData;\n  \n  // Check bounds\n  if (x < 1 || y < 1 || x >= width - 1 || y >= height - 1) {\n    return [];\n  }\n  \n  // Extract 3x3 neighborhood as binary values (0 or 1)\n  const neighborhood: number[] = [];\n  \n  // Top-left to bottom-right in clockwise order, excluding center\n  const offsets = [\n    [-1, -1], [0, -1], [1, -1], [1, 0],\n    [1, 1], [0, 1], [-1, 1], [-1, 0]\n  ];\n  \n  for (const [dx, dy] of offsets) {\n    const nx = x + dx;\n    const ny = y + dy;\n    const idx = (ny * width + nx) * 4;\n    neighborhood.push(data[idx] > 0 ? 1 : 0);\n  }\n  \n  return neighborhood;\n}\n\n/**\n * Detects corner points and other junctions in a binary image using advanced pattern recognition.\n * Enhanced to better preserve endpoint detection.\n * \n * @param imageData - Skeletonized binary image\n * @param options - Detection options\n * @returns Array of detected junction points {x, y, type}\n */\nexport function detectCorners(\n  imageData: ImageData, \n  options: DetectionOptions = {}\n): Point[] {\n  const { width, height, data } = imageData;\n  const corners: Point[] = [];\n  const endpointMap = new Map<string, Point>(); // Track endpoints by position\n  \n  // Default parameter values\n  const minNeighbors = options.minNeighbors ?? 1; // Lower this to catch more points\n  const minTransitions = options.minTransitions ?? 1; // Lower this to catch more points\n  const includeTypes = options.includeTypes ?? [\n    PointType.CORNER, \n    PointType.T_JUNCTION, \n    PointType.ENDPOINT, \n    PointType.INTERSECTION\n  ];\n  \n  // Scan the image for all foreground pixels\n  for (let y = 1; y < height - 1; y++) {\n    for (let x = 1; x < width - 1; x++) {\n      const idx = (y * width + x) * 4;\n      \n      // Skip background pixels\n      if (data[idx] === 0) continue;\n      \n      // Get neighborhood\n      const neighborhood = getNeighborhood(imageData, x, y);\n      if (neighborhood.length === 0) continue;\n      \n      // Count foreground neighbors\n      const neighborCount = neighborhood.reduce((sum, val) => sum + val, 0);\n      \n      // For endpoints, we're more lenient with minimum neighbors\n      const pointType = classifyJunctionType(neighborhood);\n      \n      // Special handling for endpoints\n      if (pointType === PointType.ENDPOINT) {\n        if (includeTypes.includes(PointType.ENDPOINT)) {\n          const key = `${x},${y}`;\n          endpointMap.set(key, { x, y, type: PointType.ENDPOINT });\n        }\n        continue; // Skip other checks for endpoints\n      }\n      \n      // For non-endpoints, apply standard filtering\n      if (neighborCount < minNeighbors) continue;\n      \n      // Count transitions\n      let transitions = 0;\n      for (let i = 0; i < neighborhood.length; i++) {\n        if (neighborhood[i] === 0 && neighborhood[(i + 1) % 8] === 1) {\n          transitions++;\n        }\n      }\n      if (transitions < minTransitions) continue;\n      \n      // Add point if it's of a requested type\n      if (includeTypes.includes(pointType)) {\n        corners.push({ x, y, type: pointType });\n      }\n    }\n  }\n  \n  // Add all detected endpoints to the corners array\n  corners.push(...endpointMap.values());\n  \n  console.log(`[DEBUG] Detected ${corners.length} corner candidates (including endpoints: ${endpointMap.size})`);\n  return corners;\n}\n\n/**\n * Clusters nearby points into a single point using distance-based clustering.\n * Enhanced version with type-aware clustering to improve junction detection.\n * \n * @param points - Array of points {x, y, type}\n * @param options - Clustering options\n * @returns Array of clustered points (centroids)\n */\nexport function clusterPoints(\n  points: Point[], \n  options: ClusterOptions = {}\n): Point[] {\n  if (points.length === 0) return [];\n\n  const maxDistance = options.maxDistance ?? 10;\n  const distanceThreshold = options.distanceThreshold ?? 30; // Max distance threshold\n  const minClusterSize = options.minClusterSize ?? 1; // Default to 1 to keep all clusters\n  const preserveTypes = options.preserveTypes ?? true; // Whether to prioritize junction types\n  \n  // Group points by type first if preserveTypes is enabled\n  const pointsByType: Record<string, Point[]> = {};\n  \n  if (preserveTypes) {\n    // Group by type\n    for (const point of points) {\n      const type = point.type || PointType.UNCLASSIFIED;\n      if (!pointsByType[type]) {\n        pointsByType[type] = [];\n      }\n      pointsByType[type].push(point);\n    }\n    \n    // Ensure there's a specific group for endpoints to prevent merging with other types\n    if (!pointsByType[PointType.ENDPOINT]) {\n      pointsByType[PointType.ENDPOINT] = [];\n    }\n  } else {\n    // Just one group with all points\n    pointsByType['all'] = points;\n  }\n  \n  // Process each type group separately\n  const allClusters: Point[] = [];\n  \n  for (const type in pointsByType) {\n    const typePoints = pointsByType[type];\n    \n    // Create clusters initially containing one point each\n    let clusters: (Point[] | null)[] = typePoints.map(point => [point]);\n    let mergeOccurred = true;\n    \n    // Iteratively merge clusters until no more merges occur\n    while (mergeOccurred) {\n      mergeOccurred = false;\n      \n      for (let i = 0; i < clusters.length; i++) {\n        if (!clusters[i]) continue; // Skip already merged clusters\n        \n        for (let j = i + 1; j < clusters.length; j++) {\n          if (!clusters[j]) continue; // Skip already merged clusters\n          \n          // Check distance between clusters\n          const canMerge = clusters[i]!.some(p1 => \n            clusters[j]!.some(p2 => {\n              const dx = p1.x - p2.x;\n              const dy = p1.y - p2.y;\n              const dist = Math.sqrt(dx*dx + dy*dy);\n              // Only merge if within the merge distance threshold\n              return dist <= maxDistance;\n            })\n          );\n          \n          // Merge clusters if they're close enough\n          if (canMerge) {\n            clusters[i] = clusters[i]!.concat(clusters[j]!);\n            clusters[j] = null; // Mark as merged\n            mergeOccurred = true;\n          }\n        }\n      }\n      \n      // Filter out null clusters\n      if (mergeOccurred) {\n        clusters = clusters.filter(cluster => cluster !== null);\n      }\n    }\n    \n    // Calculate centroids (averages) for each cluster\n    const typeClusters = clusters\n      .filter(cluster => cluster!.length >= minClusterSize)\n      .map(cluster => {\n        const sumX = cluster!.reduce((sum, p) => sum + p.x, 0);\n        const sumY = cluster!.reduce((sum, p) => sum + p.y, 0);\n        \n        // Determine the most common point type in this cluster\n        const typeCounts: Record<string, number> = {};\n        for (const point of cluster!) {\n          const pointType = point.type || PointType.UNCLASSIFIED;\n          typeCounts[pointType] = (typeCounts[pointType] || 0) + 1;\n        }\n        \n        // Find the most frequent type\n        let mostCommonType = PointType.UNCLASSIFIED;\n        let maxCount = 0;\n        for (const type in typeCounts) {\n          if (typeCounts[type] > maxCount) {\n            maxCount = typeCounts[type];\n            mostCommonType = type as PointType;\n          }\n        }\n        \n        return {\n          x: Math.round(sumX / cluster!.length),\n          y: Math.round(sumY / cluster!.length),\n          type: mostCommonType as PointType,\n          count: cluster!.length  // Keep track of cluster size\n        };\n      });\n    \n    allClusters.push(...typeClusters);\n  }\n  \n  // Count point types for logging\n  const typeCounts: Record<string, number> = {};\n  for (const point of allClusters) {\n    const type = point.type || PointType.UNCLASSIFIED;\n    typeCounts[type] = (typeCounts[type] || 0) + 1;\n  }\n  \n  console.log(`[DEBUG] Clustered into ${allClusters.length} points`);\n  console.log(`[DEBUG] Point types after clustering:`);\n  console.log(`Endpoints: ${typeCounts[PointType.ENDPOINT] || 0}`);\n  console.log(`T-Junctions: ${typeCounts[PointType.T_JUNCTION] || 0}`);\n  console.log(`Corners: ${typeCounts[PointType.CORNER] || 0}`);\n  console.log(`Intersections: ${typeCounts[PointType.INTERSECTION] || 0}`);\n  console.log(`Unclassified: ${typeCounts[PointType.UNCLASSIFIED] || 0}`);\n  \n  return allClusters;\n}\n\n/**\n * Detects straight line segments in the skeleton image using a simplified Hough transform approach.\n * \n * @param imageData - Binary image data\n * @param options - Line detection options\n * @returns Array of detected line segments { x1, y1, x2, y2 }\n */\nexport function detectStraightLines(\n  imageData: ImageData,\n  options: LineDetectionOptions = {}\n): LineSegment[] {\n  const { width, height, data } = imageData;\n  const lines: LineSegment[] = [];\n  \n  // Default parameter values\n  const threshold = options.threshold ?? 30;\n  const minLineLength = options.minLineLength ?? 20;\n  const maxLineGap = options.maxLineGap ?? 5;\n  const maxDistance = options.maxDistance ?? 5;\n  \n  // Extract foreground pixel coordinates\n  const points: Point[] = [];\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const idx = (y * width + x) * 4;\n      if (data[idx] > 0) {\n        points.push({x, y});\n      }\n    }\n  }\n  \n  // Simple implementation of probabilistic Hough transform\n  // We'll use a simplified approach by checking groups of points\n  // and finding straight lines among them\n  const angleStep = Math.PI / 180;\n  \n  // Group points by potential lines\n  for (let i = 0; i < points.length; i++) {\n    const p1 = points[i];\n    \n    for (let angleIdx = 0; angleIdx < 180; angleIdx++) {\n      const theta = angleIdx * angleStep;\n      const cosTheta = Math.cos(theta);\n      const sinTheta = Math.sin(theta);\n      \n      // Find points that lie on this angle from p1\n      const potentialLinePoints: Point[] = [];\n      potentialLinePoints.push(p1);\n      \n      // Check other points to see if they lie close to this line\n      for (let j = 0; j < points.length; j++) {\n        if (i === j) continue;\n        \n        const p2 = points[j];\n        const dx = p2.x - p1.x;\n        const dy = p2.y - p1.y;\n        \n        // Distance from point to line\n        const dist = Math.abs(-sinTheta * p2.x + cosTheta * p2.y - \n                            (-sinTheta * p1.x + cosTheta * p1.y));\n        \n        if (dist <= maxDistance) {\n          potentialLinePoints.push(p2);\n        }\n      }\n      \n      // If we have enough points, consider this a line\n      if (potentialLinePoints.length >= threshold) {\n        // Sort points to find endpoints\n        potentialLinePoints.sort((a, b) => {\n          return (a.x - p1.x) * cosTheta + (a.y - p1.y) * sinTheta - \n                 ((b.x - p1.x) * cosTheta + (b.y - p1.y) * sinTheta);\n        });\n        \n        // Get first and last point of sorted array as line endpoints\n        const first = potentialLinePoints[0];\n        const last = potentialLinePoints[potentialLinePoints.length - 1];\n        \n        // Calculate length\n        const dx = last.x - first.x;\n        const dy = last.y - first.y;\n        const length = Math.sqrt(dx*dx + dy*dy);\n        \n        // Add line if it meets length requirement\n        if (length >= minLineLength) {\n          lines.push({\n            x1: first.x,\n            y1: first.y,\n            x2: last.x,\n            y2: last.y\n          });\n        }\n      }\n    }\n  }\n  \n  // Filter duplicate lines\n  const filteredLines: LineSegment[] = [];\n  for (const line of lines) {\n    const isDuplicate = filteredLines.some(l => {\n      const d1 = Math.hypot(l.x1 - line.x1, l.y1 - line.y1) + \n                Math.hypot(l.x2 - line.x2, l.y2 - line.y2);\n      const d2 = Math.hypot(l.x1 - line.x2, l.y1 - line.y2) + \n                Math.hypot(l.x2 - line.x1, l.y2 - line.y1);\n      return d1 <= maxLineGap*2 || d2 <= maxLineGap*2;\n    });\n    \n    if (!isDuplicate) {\n      filteredLines.push(line);\n    }\n  }\n  \n  console.log(`[DEBUG] Detected ${filteredLines.length} line segments`);\n  return filteredLines;\n}", "/**\n * Line intersection detection functions\n */\nimport { Point, LineSegment, PointType } from \"./types.ts\";\n\n/**\n * Calculate intersection point of two lines (if any).\n * \n * @param line1 - First line segment {x1, y1, x2, y2}\n * @param line2 - Second line segment {x1, y1, x2, y2}\n * @returns Point of intersection {x, y} or null if no intersection\n */\nexport function intersectLines(line1: LineSegment, line2: LineSegment): Point | null {\n  // Represent line1 in parametric form: P1 + t*(P2-P1)\n  const {x1, y1, x2, y2} = line1;\n  const {x1: x3, y1: y3, x2: x4, y2: y4} = line2;\n  \n  // Compute denominator\n  const denom = (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4);\n  if (Math.abs(denom) < 1e-6) {\n    return null; // Lines are parallel or nearly parallel\n  }\n  \n  // Intersection point\n  const intersectX = ((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4)) / denom;\n  const intersectY = ((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4)) / denom;\n  \n  // Check if intersection is within the line segments\n  const between = (a: number, b: number, c: number): boolean => \n    (a >= Math.min(b, c) - 1e-6 && a <= Math.max(b, c) + 1e-6);\n  \n  if (\n    between(intersectX, x1, x2) && between(intersectY, y1, y2) &&\n    between(intersectX, x3, x4) && between(intersectY, y3, y4)\n  ) {\n    return { x: intersectX, y: intersectY };\n  }\n  \n  return null;\n}\n\n/**\n * Find all intersection points between a set of detected lines\n * \n * @param lines - Array of line segments {x1, y1, x2, y2}\n * @returns Array of intersection points {x, y}\n */\nexport function findIntersections(lines: LineSegment[]): Point[] {\n  const intersections: Point[] = [];\n  \n  // Check all unique line pairs for intersections\n  for (let i = 0; i < lines.length; i++) {\n    for (let j = i + 1; j < lines.length; j++) {\n      const intersection = intersectLines(lines[i], lines[j]);\n      if (intersection) {\n        // Mark this as an intersection point type\n        intersection.type = PointType.INTERSECTION;\n        intersections.push(intersection);\n      }\n    }\n  }\n  \n  console.log(`[DEBUG] Found ${intersections.length} line intersections`);\n  return intersections;\n}\n\n/**\n * Extract endpoints from lines as potential corner points\n * Enhanced to work with image data directly when no line segments are available\n * \n * @param lines - Array of line segments\n * @returns Array of endpoint points\n */\nexport function extractEndpoints(lines: LineSegment[]): Point[] {\n  const endpoints: Point[] = [];\n  \n  if (lines.length > 0) {\n    // Normal case: extract endpoints from line segments\n    for (const line of lines) {\n      // Add both endpoints of the line\n      endpoints.push({ x: line.x1, y: line.y1, type: PointType.ENDPOINT });\n      endpoints.push({ x: line.x2, y: line.y2, type: PointType.ENDPOINT });\n    }\n  }\n  \n  // Log the result\n  console.log(`[DEBUG] Extracted ${endpoints.length} line endpoints`);\n  return endpoints;\n}\n\n/**\n * Combine all detected points: corners, intersections, and optionally endpoints\n * \n * @param corners - Detected corner points\n * @param intersections - Line intersection points\n * @param endpoints - Optional line endpoints to include\n * @returns Combined array of points\n */\nexport function combineFeaturePoints(\n  corners: Point[], \n  intersections: Point[], \n  endpoints: Point[] = []\n): Point[] {\n  // Make sure to include all points of each type\n  const combinedPoints = [...corners, ...intersections, ...endpoints];\n  \n  // Log the result\n  console.log(`[DEBUG] Combined ${corners.length} corners, ${intersections.length} intersections, and ${endpoints.length} endpoints`);\n  \n  return combinedPoints;\n}", "/**\n * Visualization functions for drawing detected features on floorplan images\n */\nimport { Point, LineSegment, PointType } from \"./types.ts\";\n\n/**\n * Helper function to set a pixel color in an ImageData\n */\nfunction setPixelColor(\n  imageData: ImageData,\n  x: number,\n  y: number,\n  r: number,\n  g: number,\n  b: number\n): void {\n  if (x < 0 || y < 0 || x >= imageData.width || y >= imageData.height) return;\n  const idx = (y * imageData.width + x) * 4;\n  imageData.data[idx] = r;\n  imageData.data[idx + 1] = g;\n  imageData.data[idx + 2] = b;\n}\n\n/**\n * Draw a point with its neighborhood on the image\n */\nfunction drawPoint(\n  imageData: ImageData,\n  point: Point,\n  size: number = 3,\n  color: [number, number, number] = [255, 0, 0]\n): void {\n  // Adjust size only for junctions and intersections\n  let adjustedSize = size;\n  if (point.type) {\n    switch (point.type) {\n      case PointType.T_JUNCTION:\n      case PointType.INTERSECTION:\n        adjustedSize = Math.max(size * 3, 9); // 3x larger, minimum 9 pixels\n        break;\n      case PointType.ENDPOINT:\n        adjustedSize = Math.max(size * 2, 6); // 2x larger for endpoints\n        break;\n      // Corners remain at normal size\n    }\n  }\n\n  const halfSize = Math.floor(adjustedSize / 2);\n  for (let dy = -halfSize; dy <= halfSize; dy++) {\n    for (let dx = -halfSize; dx <= halfSize; dx++) {\n      // Make the center brighter\n      const intensity = (dx === 0 && dy === 0) ? 255 : 180;\n      const [r, g, b] = color.map(c => Math.min(255, (c * intensity) / 255));\n      setPixelColor(imageData, point.x + dx, point.y + dy, r, g, b);\n    }\n  }\n}\n\n/**\n * Draw a line segment using Bresenham's algorithm\n */\nfunction drawLine(\n  imageData: ImageData,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  color: [number, number, number] = [0, 0, 255]\n): void {\n  const [r, g, b] = color;\n  const dx = Math.abs(x2 - x1);\n  const dy = Math.abs(y2 - y1);\n  const sx = x1 < x2 ? 1 : -1;\n  const sy = y1 < y2 ? 1 : -1;\n  let err = dx - dy;\n  \n  let x = x1;\n  let y = y1;\n  \n  while (true) {\n    setPixelColor(imageData, x, y, r, g, b);\n    \n    if (x === x2 && y === y2) break;\n    \n    const e2 = 2 * err;\n    if (e2 > -dy) {\n      err -= dy;\n      x += sx;\n    }\n    if (e2 < dx) {\n      err += dx;\n      y += sy;\n    }\n  }\n}\n\n/**\n * Get color for a specific point type\n * \n * @param pointType - The type of point\n * @returns RGB color array\n */\nfunction getPointTypeColor(pointType?: PointType): [number, number, number] {\n  switch (pointType) {\n    case PointType.CORNER:\n      return [255, 0, 0]; // Red for corners\n    case PointType.T_JUNCTION:\n      return [255, 255, 0]; // Yellow for T junctions\n    case PointType.ENDPOINT:\n      return [173, 216, 230]; // Light blue for endpoints\n    case PointType.INTERSECTION:\n      return [255, 255, 0]; // Yellow for intersections\n    case PointType.UNCLASSIFIED:\n    default:\n      return [255, 165, 0]; // Orange for unclassified/unknown\n  }\n}\n\n/**\n * Draw annotation text next to a point\n * \n * @param imageData - Image to draw on\n * @param x - X coordinate\n * @param y - Y coordinate\n * @param label - Text label\n * @param color - Text color\n */\nfunction drawLabel(\n  imageData: ImageData,\n  x: number,\n  y: number,\n  label: string,\n  color: [number, number, number] = [255, 255, 255]\n): void {\n  // Simple implementation - just draw a bright pixel for now\n  // In a real implementation, you'd need a font rendering system\n  const [r, g, b] = color;\n  for (let dy = 0; dy < 5; dy++) {\n    for (let dx = 0; dx < 5; dx++) {\n      setPixelColor(imageData, x + dx, y + dy, r, g, b);\n    }\n  }\n}\n\n/**\n * Draws detected corners on an image.\n * \n * @param imageData - Image to draw on\n * @param corners - Array of corner points {x, y}\n * @param useOriginal - If true, modifies input imageData; otherwise makes a copy\n * @returns Modified image with corners highlighted\n */\nexport function drawCorners(\n  imageData: ImageData, \n  corners: Point[], \n  useOriginal: boolean = false\n): ImageData {\n  // Create a copy of the input image if needed\n  const result = useOriginal ? \n    imageData : \n    new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);\n  \n  // Draw each corner point\n  for (const corner of corners) {\n    const color: [number, number, number] = getPointTypeColor(corner.type);\n    drawPoint(result, corner, 3, color);\n  }\n  \n  return result;\n}\n\n/**\n * Draws clustered points on the image.\n *\n * @param imageData - Image to draw on\n * @param clusters - Array of cluster points {x, y}\n * @param useOriginal - If true, modifies input imageData; otherwise makes a copy\n * @param showLabels - If true, shows labels next to points\n * @returns Modified image with clustered points highlighted\n */\nexport function drawClusteredPoints(\n  imageData: ImageData, \n  clusters: Point[], \n  useOriginal: boolean = false,\n  showLabels: boolean = false\n): ImageData {\n  // Create a copy of the input image if needed\n  const result = useOriginal ? \n    imageData : \n    new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);\n  \n  // Draw each cluster centroid with appropriate color based on type\n  for (const point of clusters) {\n    // Get color based on point type\n    const color = getPointTypeColor(point.type);\n    \n    // Draw a larger point for clusters to make them stand out\n    const size = point.count ? Math.min(5 + Math.floor(point.count / 3), 10) : 5;\n    drawPoint(result, point, size, color);\n    \n    if (showLabels && point.type) {\n      drawLabel(result, point.x + 6, point.y - 6, point.type);\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Draws detected lines on the image.\n *\n * @param imageData - Image to draw on\n * @param lines - Array of line segments {x1, y1, x2, y2}\n * @param useOriginal - If true, modifies input imageData; otherwise makes a copy\n * @returns Modified image with lines highlighted\n */\nexport function drawLines(\n  imageData: ImageData, \n  lines: LineSegment[], \n  useOriginal: boolean = false\n): ImageData {\n  // Create a copy of the input image if needed\n  const result = useOriginal ? \n    imageData : \n    new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);\n  \n  // Draw each line\n  for (const { x1, y1, x2, y2 } of lines) {\n    drawLine(\n      result, \n      Math.round(x1), \n      Math.round(y1), \n      Math.round(x2), \n      Math.round(y2),\n      [0, 255, 255] // Cyan for lines\n    );\n  }\n  \n  return result;\n}\n\n/**\n * Draw all detected features on the image\n * \n * @param imageData - Base image to draw on\n * @param features - Object containing all features to draw\n * @param useOriginal - Whether to modify input image or create copy\n * @param options - Additional options for visualization\n * @returns Modified image with all features drawn\n */\nexport function visualizeFeatures(\n  imageData: ImageData,\n  features: {\n    corners?: Point[];\n    clusters?: Point[];\n    lines?: LineSegment[];\n    intersections?: Point[];\n  },\n  useOriginal: boolean = false,\n  options: { showLabels?: boolean } = {}\n): ImageData {\n  const result = useOriginal ? \n    imageData : \n    new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);\n  \n  // Draw features in order: lines, corners, intersections, clusters\n  if (features.lines) {\n    drawLines(result, features.lines, true);\n  }\n  \n  if (features.corners) {\n    drawCorners(result, features.corners, true);\n  }\n  \n  if (features.intersections) {\n    // Draw intersections\n    for (const point of features.intersections) {\n      drawPoint(result, point, 3, getPointTypeColor(PointType.INTERSECTION));\n    }\n  }\n  \n  if (features.clusters) {\n    drawClusteredPoints(result, features.clusters, true, options.showLabels);\n  }\n  \n  // Add a legend to help identify the colors\n  const legendX = 10;\n  let legendY = 10;\n  const legendSpacing = 15;\n  \n  // Draw colored squares for each point type\n  if (features.clusters && features.clusters.length > 0) {\n    // Corner (L-junction)\n    drawPoint(result, {x: legendX, y: legendY}, 5, getPointTypeColor(PointType.CORNER));\n    drawLabel(result, legendX + 10, legendY, \"Corner (L)\", [255, 255, 255]);\n    legendY += legendSpacing;\n    \n    // T-junction\n    drawPoint(result, {x: legendX, y: legendY}, 5, getPointTypeColor(PointType.T_JUNCTION));\n    drawLabel(result, legendX + 10, legendY, \"T-Junction\", [255, 255, 255]);\n    legendY += legendSpacing;\n    \n    // Endpoint\n    drawPoint(result, {x: legendX, y: legendY}, 5, getPointTypeColor(PointType.ENDPOINT));\n    drawLabel(result, legendX + 10, legendY, \"Endpoint\", [255, 255, 255]);\n    legendY += legendSpacing;\n    \n    // Intersection\n    drawPoint(result, {x: legendX, y: legendY}, 5, getPointTypeColor(PointType.INTERSECTION));\n    drawLabel(result, legendX + 10, legendY, \"Intersection\", [255, 255, 255]);\n  }\n  \n  return result;\n}"],
  "mappings": ";AA2BO,IAAKA,OACVA,EAAA,OAAS,SACTA,EAAA,SAAW,WACXA,EAAA,WAAa,aACbA,EAAA,aAAe,eACfA,EAAA,aAAe,eALLA,OAAA,ICnBL,SAASC,EAAiBC,EAAkC,CACjE,IAAMC,EAAS,SAAS,cAAc,QAAQ,EAC9CA,EAAO,MAAQD,EAAI,MACnBC,EAAO,OAASD,EAAI,OACpB,IAAME,EAAMD,EAAO,WAAW,IAAI,EAElC,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,8BAA8B,EAGhD,OAAAA,EAAI,UAAUF,EAAK,EAAG,CAAC,EAChBE,EAAI,aAAa,EAAG,EAAGD,EAAO,MAAOA,EAAO,MAAM,CAC3D,CAKO,SAASE,EAAUC,EAA+C,CACvE,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,IAAMN,EAAM,IAAI,MAChBA,EAAI,YAAc,YAElBA,EAAI,OAAS,IAAMK,EAAQL,CAAG,EAC9BA,EAAI,QAAU,IAAMM,EAAO,IAAI,MAAM,sBAAsB,CAAC,EAExD,OAAOF,GAAQ,SACjBJ,EAAI,IAAMI,EAEVJ,EAAI,IAAM,IAAI,gBAAgBI,CAAG,CAErC,CAAC,CACH,CAKO,SAASG,EAAmBC,EAAiC,CAClE,GAAM,CAAE,MAAAC,EAAO,OAAAC,EAAQ,KAAAC,CAAK,EAAIH,EAC1BP,EAAS,SAAS,cAAc,QAAQ,EAC9CA,EAAO,MAAQQ,EACfR,EAAO,OAASS,EAEhB,IAAME,EADMX,EAAO,WAAW,IAAI,EACR,gBAAgBQ,EAAOC,CAAM,EACjDG,EAAWD,EAAc,KAG/B,QAASE,EAAI,EAAGA,EAAIH,EAAK,OAAQG,GAAK,EAAG,CAEvC,IAAMC,EAAO,KAAQJ,EAAKG,CAAC,EAAI,KAAQH,EAAKG,EAAI,CAAC,EAAI,KAAQH,EAAKG,EAAI,CAAC,EAEvED,EAASC,CAAC,EAAIC,EACdF,EAASC,EAAI,CAAC,EAAIC,EAClBF,EAASC,EAAI,CAAC,EAAIC,EAClBF,EAASC,EAAI,CAAC,EAAIH,EAAKG,EAAI,CAAC,CAC9B,CAEA,OAAOF,CACT,CAKO,SAASI,EACdR,EACAS,EAAoB,IACpBC,EAAmB,GACR,CACX,GAAM,CAAE,MAAAT,EAAO,OAAAC,EAAQ,KAAAC,CAAK,EAAIH,EAC1BP,EAAS,SAAS,cAAc,QAAQ,EAC9CA,EAAO,MAAQQ,EACfR,EAAO,OAASS,EAEhB,IAAMS,EADMlB,EAAO,WAAW,IAAI,EACT,gBAAgBQ,EAAOC,CAAM,EAChDU,EAAUD,EAAa,KAG7B,QAASL,EAAI,EAAGA,EAAIH,EAAK,OAAQG,GAAK,EAAG,CAEvC,IAAMC,EAAOJ,EAAKG,CAAC,IAAMH,EAAKG,EAAI,CAAC,GAAKH,EAAKG,CAAC,IAAMH,EAAKG,EAAI,CAAC,EAC1DH,EAAKG,CAAC,EACN,KAAQH,EAAKG,CAAC,EAAI,KAAQH,EAAKG,EAAI,CAAC,EAAI,KAAQH,EAAKG,EAAI,CAAC,EAGxDO,EAAMH,EACTH,EAAOE,EAAY,IAAM,EACzBF,EAAOE,EAAY,IAAM,EAE5BG,EAAQN,CAAC,EAAIO,EACbD,EAAQN,EAAI,CAAC,EAAIO,EACjBD,EAAQN,EAAI,CAAC,EAAIO,EACjBD,EAAQN,EAAI,CAAC,EAAI,GACnB,CAEA,OAAOK,CACT,CAKO,SAASG,EAAwBd,EAAsBP,EAAiC,CAC7FA,EAAO,MAAQO,EAAU,MACzBP,EAAO,OAASO,EAAU,OAE1B,IAAMN,EAAMD,EAAO,WAAW,IAAI,EAClC,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,8BAA8B,EAGhDA,EAAI,aAAaM,EAAW,EAAG,CAAC,CAClC,CAMO,SAASe,EACdf,EACAgB,EACW,CACX,IAAMP,EAAYO,GAAS,WAAa,IAClCN,EAAUM,GAAS,UAAY,OAAYA,EAAQ,QAAU,GAGnE,OAAOR,EAAeR,EAAWS,EAAWC,CAAO,CACrD,CC1HO,SAASO,EACdC,EACAC,EAAwB,IACb,CACX,GAAM,CAAE,MAAAC,EAAO,OAAAC,EAAQ,KAAAC,CAAK,EAAIJ,EAG1BK,EAAQ,IAAI,kBAAkBD,CAAI,EAGlCE,EAAW,CAACC,EAAWC,IAAsB,CACjD,GAAID,EAAI,GAAKC,EAAI,GAAKD,GAAKL,GAASM,GAAKL,EAAQ,MAAO,GACxD,IAAMM,GAAOD,EAAIN,EAAQK,GAAK,EAC9B,OAAOF,EAAMI,CAAG,EAAI,EAAI,EAAI,CAC9B,EAGMC,EAAW,CAACH,EAAWC,EAAWG,IAAwB,CAC9D,IAAMF,GAAOD,EAAIN,EAAQK,GAAK,EACxBK,EAAMD,EAAQ,EAAI,IAAM,EAC9BN,EAAMI,CAAG,EAAIJ,EAAMI,EAAM,CAAC,EAAIJ,EAAMI,EAAM,CAAC,EAAIG,CACjD,EAEIC,EAAgB,GAChBC,EAAa,EAEjB,KAAOD,GAAiBC,EAAab,GAAe,CAClDY,EAAgB,GAChBC,IAGA,IAAMC,EAAgC,CAAC,EAEvC,QAASP,EAAI,EAAGA,EAAIL,EAAS,EAAGK,IAC9B,QAASD,EAAI,EAAGA,EAAIL,EAAQ,EAAGK,IAAK,CAClC,GAAID,EAASC,EAAGC,CAAC,IAAM,EAAG,SAG1B,IAAMQ,EAAKV,EAASC,EAAGC,EAAE,CAAC,EACpBS,EAAKX,EAASC,EAAE,EAAGC,EAAE,CAAC,EACtBU,EAAKZ,EAASC,EAAE,EAAGC,CAAC,EACpBW,EAAKb,EAASC,EAAE,EAAGC,EAAE,CAAC,EACtBY,EAAKd,EAASC,EAAGC,EAAE,CAAC,EACpBa,EAAKf,EAASC,EAAE,EAAGC,EAAE,CAAC,EACtBc,EAAKhB,EAASC,EAAE,EAAGC,CAAC,EACpBe,EAAKjB,EAASC,EAAE,EAAGC,EAAE,CAAC,EAEtBgB,EAAY,CAACR,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,CAAE,EAG3CE,EAAcD,EAAU,OAAO,CAACE,EAAKd,IAAQc,EAAMd,EAAK,CAAC,EAC/D,GAAIa,EAAc,GAAKA,EAAc,EAAG,SAGxC,IAAIE,EAAc,EAClB,QAASC,EAAI,EAAGA,EAAIJ,EAAU,OAAQI,IAChCJ,EAAUI,CAAC,IAAM,GAAKJ,GAAWI,EAAI,GAAKJ,EAAU,MAAM,IAAM,GAClEG,IAGAA,IAAgB,GAIhBX,EAAKE,EAAKE,IAAO,GAGjBF,EAAKE,EAAKE,IAAO,GAGrBP,EAAU,KAAK,CAACR,EAAGC,CAAC,CAAC,CACvB,CAIF,OAAW,CAACD,EAAGC,CAAC,IAAKO,EACnBL,EAASH,EAAGC,EAAG,CAAC,EAChBK,EAAgB,GAIlB,IAAMgB,EAAgC,CAAC,EAEvC,QAASrB,EAAI,EAAGA,EAAIL,EAAS,EAAGK,IAC9B,QAASD,EAAI,EAAGA,EAAIL,EAAQ,EAAGK,IAAK,CAClC,GAAID,EAASC,EAAGC,CAAC,IAAM,EAAG,SAG1B,IAAMQ,EAAKV,EAASC,EAAGC,EAAE,CAAC,EACpBS,EAAKX,EAASC,EAAE,EAAGC,EAAE,CAAC,EACtBU,EAAKZ,EAASC,EAAE,EAAGC,CAAC,EACpBW,EAAKb,EAASC,EAAE,EAAGC,EAAE,CAAC,EACtBY,EAAKd,EAASC,EAAGC,EAAE,CAAC,EACpBa,EAAKf,EAASC,EAAE,EAAGC,EAAE,CAAC,EACtBc,EAAKhB,EAASC,EAAE,EAAGC,CAAC,EACpBe,EAAKjB,EAASC,EAAE,EAAGC,EAAE,CAAC,EAEtBgB,EAAY,CAACR,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,CAAE,EAG3CE,EAAcD,EAAU,OAAO,CAACE,EAAKd,IAAQc,EAAMd,EAAK,CAAC,EAC/D,GAAIa,EAAc,GAAKA,EAAc,EAAG,SAGxC,IAAIE,EAAc,EAClB,QAASC,EAAI,EAAGA,EAAIJ,EAAU,OAAQI,IAChCJ,EAAUI,CAAC,IAAM,GAAKJ,GAAWI,EAAI,GAAKJ,EAAU,MAAM,IAAM,GAClEG,IAGAA,IAAgB,GAIhBX,EAAKE,EAAKI,IAAO,GAGjBN,EAAKI,EAAKE,IAAO,GAGrBO,EAAU,KAAK,CAACtB,EAAGC,CAAC,CAAC,CACvB,CAIF,OAAW,CAACD,EAAGC,CAAC,IAAKqB,EACnBnB,EAASH,EAAGC,EAAG,CAAC,EAChBK,EAAgB,EAEpB,CAEA,QAAQ,IAAI,oCAAoCC,CAAU,aAAa,EAGvE,IAAMgB,EAAS,IAAI,kBAAkBzB,CAAK,EAC1C,OAAO,IAAI,UAAUyB,EAAQ5B,EAAOC,CAAM,CAC5C,CAKA,eAAsB4B,EACpBC,EACAC,EACyB,CAEzB,IAAMC,EAAMF,aAAuB,iBAC/BA,EACA,MAAMG,EAAUH,CAAW,EAEzBI,EAAgBF,EAAI,MACpBG,EAAiBH,EAAI,OAE3B,QAAQ,IAAI,8BAA2BG,CAAc,SAAMD,CAAa,EAAE,EAG1E,IAAMpC,EAAYsC,EAAiBJ,CAAG,EAGhCK,EAAYN,GAAS,WAAa,IAClCO,EAAUP,GAAS,SAAW,GAC9BQ,EAAkBC,EAAgB1C,EAAW,CAAE,UAAAuC,EAAW,QAAAC,CAAQ,CAAC,EACzE,QAAQ,IAAI,qDAAqD,EAGjE,IAAMvC,EAAgBgC,GAAS,eAAiB,IAC1CU,EAAgB5C,EAAkB0C,EAAiBxC,CAAa,EACtE,eAAQ,IAAI,kDAAkD,EAGvD,CACL,SAAU0C,EACV,cAAAP,EACA,eAAAC,EACA,UAAW,CACT,eAAgBE,EAChB,UAAW,+BACb,CACF,CACF,CCjLO,SAASK,EAAqBC,EAAmC,CAEtE,IAAMC,EAAYD,EAAa,OAAO,CAACE,EAAKC,IAAQD,EAAMC,EAAK,CAAC,EAG5DC,EAAc,EAClB,QAASC,EAAI,EAAGA,EAAIL,EAAa,OAAQK,IACnCL,EAAaK,CAAC,IAAM,GAAKL,GAAcK,EAAI,GAAKL,EAAa,MAAM,IAAM,GAC3EI,IAKJ,IAAME,EAAgBN,EAAa,KAAK,EAAE,EAAIA,EAAa,CAAC,EAG5D,GAAIC,IAAc,GAAMA,IAAc,GAAKG,GAAe,EAAI,CAE5D,GAAIH,IAAc,EAChB,iBAKF,QAASI,EAAI,EAAGA,EAAIL,EAAa,OAAQK,IACvC,GAAIL,EAAaK,CAAC,IAAM,GAAKL,GAAcK,EAAI,GAAK,CAAC,IAAM,EACzD,gBAGN,CAGA,GAAIJ,IAAc,EAAG,CACnB,GAAIG,IAAgB,EAAG,CAGrB,QAASC,EAAI,EAAGA,EAAIL,EAAa,OAAQK,IACvC,GAAIL,EAAaK,CAAC,IAAM,GAAKL,GAAcK,EAAI,GAAK,CAAC,IAAM,EACzD,qBAIJ,cACF,CAUA,GANuB,CACrB,WACA,WACA,WACA,UACF,EACmB,KAAKE,GAAKD,EAAc,SAASC,CAAC,CAAC,EACpD,cAEJ,CAGA,GAAIN,IAAc,EAAG,CACnB,GAAIG,IAAgB,EAClB,mBAUF,GANkB,CAChB,WACA,WACA,WACA,UACF,EACc,KAAKG,GAAKD,EAAc,SAASC,CAAC,CAAC,EAC/C,kBAEJ,CAGA,OAAIN,GAAa,GAAKG,GAAe,+BAKvC,CAKA,SAASI,EAAgBC,EAAsBC,EAAWC,EAAqB,CAC7E,GAAM,CAAE,MAAAC,EAAO,OAAAC,EAAQ,KAAAC,CAAK,EAAIL,EAGhC,GAAIC,EAAI,GAAKC,EAAI,GAAKD,GAAKE,EAAQ,GAAKD,GAAKE,EAAS,EACpD,MAAO,CAAC,EAIV,IAAMb,EAAyB,CAAC,EAG1Be,EAAU,CACd,CAAC,GAAI,EAAE,EAAG,CAAC,EAAG,EAAE,EAAG,CAAC,EAAG,EAAE,EAAG,CAAC,EAAG,CAAC,EACjC,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,GAAI,CAAC,EAAG,CAAC,GAAI,CAAC,CACjC,EAEA,OAAW,CAACC,EAAIC,CAAE,IAAKF,EAAS,CAC9B,IAAMG,EAAKR,EAAIM,EAETG,IADKR,EAAIM,GACGL,EAAQM,GAAM,EAChClB,EAAa,KAAKc,EAAKK,CAAG,EAAI,EAAI,EAAI,CAAC,CACzC,CAEA,OAAOnB,CACT,CAUO,SAASoB,GACdX,EACAY,EAA4B,CAAC,EACpB,CACT,GAAM,CAAE,MAAAT,EAAO,OAAAC,EAAQ,KAAAC,CAAK,EAAIL,EAC1Ba,EAAmB,CAAC,EACpBC,EAAc,IAAI,IAGlBC,EAAeH,EAAQ,cAAgB,EACvCI,EAAiBJ,EAAQ,gBAAkB,EAC3CK,EAAeL,EAAQ,cAAgB,gDAK7C,EAGA,QAASV,EAAI,EAAGA,EAAIE,EAAS,EAAGF,IAC9B,QAASD,EAAI,EAAGA,EAAIE,EAAQ,EAAGF,IAAK,CAClC,IAAMS,GAAOR,EAAIC,EAAQF,GAAK,EAG9B,GAAII,EAAKK,CAAG,IAAM,EAAG,SAGrB,IAAMnB,EAAeQ,EAAgBC,EAAWC,EAAGC,CAAC,EACpD,GAAIX,EAAa,SAAW,EAAG,SAG/B,IAAM2B,EAAgB3B,EAAa,OAAO,CAACE,EAAKC,IAAQD,EAAMC,EAAK,CAAC,EAG9DyB,EAAY7B,EAAqBC,CAAY,EAGnD,GAAI4B,eAAkC,CACpC,GAAIF,EAAa,mBAA2B,EAAG,CAC7C,IAAMG,EAAM,GAAGnB,CAAC,IAAIC,CAAC,GACrBY,EAAY,IAAIM,EAAK,CAAE,EAAAnB,EAAG,EAAAC,EAAG,eAAyB,CAAC,CACzD,CACA,QACF,CAGA,GAAIgB,EAAgBH,EAAc,SAGlC,IAAIpB,EAAc,EAClB,QAASC,EAAI,EAAGA,EAAIL,EAAa,OAAQK,IACnCL,EAAaK,CAAC,IAAM,GAAKL,GAAcK,EAAI,GAAK,CAAC,IAAM,GACzDD,IAGAA,EAAcqB,GAGdC,EAAa,SAASE,CAAS,GACjCN,EAAQ,KAAK,CAAE,EAAAZ,EAAG,EAAAC,EAAG,KAAMiB,CAAU,CAAC,CAE1C,CAIF,OAAAN,EAAQ,KAAK,GAAGC,EAAY,OAAO,CAAC,EAEpC,QAAQ,IAAI,oBAAoBD,EAAQ,MAAM,4CAA4CC,EAAY,IAAI,GAAG,EACtGD,CACT,CAUO,SAASQ,GACdC,EACAV,EAA0B,CAAC,EAClB,CACT,GAAIU,EAAO,SAAW,EAAG,MAAO,CAAC,EAEjC,IAAMC,EAAcX,EAAQ,aAAe,GACrCY,EAAoBZ,EAAQ,mBAAqB,GACjDa,EAAiBb,EAAQ,gBAAkB,EAC3Cc,EAAgBd,EAAQ,eAAiB,GAGzCe,EAAwC,CAAC,EAE/C,GAAID,EAAe,CAEjB,QAAWE,KAASN,EAAQ,CAC1B,IAAMO,EAAOD,EAAM,qBACdD,EAAaE,CAAI,IACpBF,EAAaE,CAAI,EAAI,CAAC,GAExBF,EAAaE,CAAI,EAAE,KAAKD,CAAK,CAC/B,CAGKD,EAAa,WAChBA,EAAa,SAAsB,CAAC,EAExC,MAEEA,EAAa,IAASL,EAIxB,IAAMQ,EAAuB,CAAC,EAE9B,QAAWD,KAAQF,EAAc,CAI/B,IAAII,EAHeJ,EAAaE,CAAI,EAGU,IAAID,GAAS,CAACA,CAAK,CAAC,EAC9DI,EAAgB,GAGpB,KAAOA,GAAe,CACpBA,EAAgB,GAEhB,QAAS,EAAI,EAAG,EAAID,EAAS,OAAQ,IACnC,GAAKA,EAAS,CAAC,EAEf,QAASE,EAAI,EAAI,EAAGA,EAAIF,EAAS,OAAQE,IAAK,CAC5C,GAAI,CAACF,EAASE,CAAC,EAAG,SAGDF,EAAS,CAAC,EAAG,KAAKG,GACjCH,EAASE,CAAC,EAAG,KAAKE,GAAM,CACtB,IAAM5B,EAAK2B,EAAG,EAAIC,EAAG,EACf3B,EAAK0B,EAAG,EAAIC,EAAG,EAGrB,OAFa,KAAK,KAAK5B,EAAGA,EAAKC,EAAGA,CAAE,GAErBe,CACjB,CAAC,CACH,IAIEQ,EAAS,CAAC,EAAIA,EAAS,CAAC,EAAG,OAAOA,EAASE,CAAC,CAAE,EAC9CF,EAASE,CAAC,EAAI,KACdD,EAAgB,GAEpB,CAIEA,IACFD,EAAWA,EAAS,OAAOK,GAAWA,IAAY,IAAI,EAE1D,CAGA,IAAMC,EAAeN,EAClB,OAAOK,GAAWA,EAAS,QAAUX,CAAc,EACnD,IAAIW,GAAW,CACd,IAAME,EAAOF,EAAS,OAAO,CAAC3C,EAAKK,IAAML,EAAMK,EAAE,EAAG,CAAC,EAC/CyC,EAAOH,EAAS,OAAO,CAAC3C,EAAKK,IAAML,EAAMK,EAAE,EAAG,CAAC,EAG/C0C,EAAqC,CAAC,EAC5C,QAAWZ,KAASQ,EAAU,CAC5B,IAAMjB,EAAYS,EAAM,qBACxBY,EAAWrB,CAAS,GAAKqB,EAAWrB,CAAS,GAAK,GAAK,CACzD,CAGA,IAAIsB,iBACAC,EAAW,EACf,QAAWb,KAAQW,EACbA,EAAWX,CAAI,EAAIa,IACrBA,EAAWF,EAAWX,CAAI,EAC1BY,EAAiBZ,GAIrB,MAAO,CACL,EAAG,KAAK,MAAMS,EAAOF,EAAS,MAAM,EACpC,EAAG,KAAK,MAAMG,EAAOH,EAAS,MAAM,EACpC,KAAMK,EACN,MAAOL,EAAS,MAClB,CACF,CAAC,EAEHN,EAAY,KAAK,GAAGO,CAAY,CAClC,CAGA,IAAMG,EAAqC,CAAC,EAC5C,QAAWZ,KAASE,EAAa,CAC/B,IAAMD,EAAOD,EAAM,qBACnBY,EAAWX,CAAI,GAAKW,EAAWX,CAAI,GAAK,GAAK,CAC/C,CAEA,eAAQ,IAAI,0BAA0BC,EAAY,MAAM,SAAS,EACjE,QAAQ,IAAI,uCAAuC,EACnD,QAAQ,IAAI,cAAcU,EAAW,UAAuB,CAAC,EAAE,EAC/D,QAAQ,IAAI,gBAAgBA,EAAW,YAAyB,CAAC,EAAE,EACnE,QAAQ,IAAI,YAAYA,EAAW,QAAqB,CAAC,EAAE,EAC3D,QAAQ,IAAI,kBAAkBA,EAAW,cAA2B,CAAC,EAAE,EACvE,QAAQ,IAAI,iBAAiBA,EAAW,cAA2B,CAAC,EAAE,EAE/DV,CACT,CASO,SAASa,GACd3C,EACAY,EAAgC,CAAC,EAClB,CACf,GAAM,CAAE,MAAAT,EAAO,OAAAC,EAAQ,KAAAC,CAAK,EAAIL,EAC1B4C,EAAuB,CAAC,EAGxBC,EAAYjC,EAAQ,WAAa,GACjCkC,EAAgBlC,EAAQ,eAAiB,GACzCmC,EAAanC,EAAQ,YAAc,EACnCW,EAAcX,EAAQ,aAAe,EAGrCU,EAAkB,CAAC,EACzB,QAASpB,EAAI,EAAGA,EAAIE,EAAQF,IAC1B,QAASD,EAAI,EAAGA,EAAIE,EAAOF,IAAK,CAC9B,IAAMS,GAAOR,EAAIC,EAAQF,GAAK,EAC1BI,EAAKK,CAAG,EAAI,GACdY,EAAO,KAAK,CAAC,EAAArB,EAAG,EAAAC,CAAC,CAAC,CAEtB,CAMF,IAAM8C,EAAY,KAAK,GAAK,IAG5B,QAASpD,EAAI,EAAGA,EAAI0B,EAAO,OAAQ1B,IAAK,CACtC,IAAMsC,EAAKZ,EAAO1B,CAAC,EAEnB,QAASqD,EAAW,EAAGA,EAAW,IAAKA,IAAY,CACjD,IAAMC,EAAQD,EAAWD,EACnBG,EAAW,KAAK,IAAID,CAAK,EACzBE,EAAW,KAAK,IAAIF,CAAK,EAGzBG,EAA+B,CAAC,EACtCA,EAAoB,KAAKnB,CAAE,EAG3B,QAASD,EAAI,EAAGA,EAAIX,EAAO,OAAQW,IAAK,CACtC,GAAIrC,IAAMqC,EAAG,SAEb,IAAME,EAAKb,EAAOW,CAAC,EACb1B,EAAK4B,EAAG,EAAID,EAAG,EACf1B,EAAK2B,EAAG,EAAID,EAAG,EAGR,KAAK,IAAI,CAACkB,EAAWjB,EAAG,EAAIgB,EAAWhB,EAAG,GAClC,CAACiB,EAAWlB,EAAG,EAAIiB,EAAWjB,EAAG,EAAE,GAE5CX,GACV8B,EAAoB,KAAKlB,CAAE,CAE/B,CAGA,GAAIkB,EAAoB,QAAUR,EAAW,CAE3CQ,EAAoB,KAAK,CAACC,EAAGC,KACnBD,EAAE,EAAIpB,EAAG,GAAKiB,GAAYG,EAAE,EAAIpB,EAAG,GAAKkB,IACvCG,EAAE,EAAIrB,EAAG,GAAKiB,GAAYI,EAAE,EAAIrB,EAAG,GAAKkB,EAClD,EAGD,IAAMI,EAAQH,EAAoB,CAAC,EAC7BI,EAAOJ,EAAoBA,EAAoB,OAAS,CAAC,EAGzD9C,EAAKkD,EAAK,EAAID,EAAM,EACpBhD,EAAKiD,EAAK,EAAID,EAAM,EACX,KAAK,KAAKjD,EAAGA,EAAKC,EAAGA,CAAE,GAGxBsC,GACZF,EAAM,KAAK,CACT,GAAIY,EAAM,EACV,GAAIA,EAAM,EACV,GAAIC,EAAK,EACT,GAAIA,EAAK,CACX,CAAC,CAEL,CACF,CACF,CAGA,IAAMC,EAA+B,CAAC,EACtC,QAAWC,KAAQf,EACGc,EAAc,KAAKE,GAAK,CAC1C,IAAMC,EAAK,KAAK,MAAMD,EAAE,GAAKD,EAAK,GAAIC,EAAE,GAAKD,EAAK,EAAE,EAC1C,KAAK,MAAMC,EAAE,GAAKD,EAAK,GAAIC,EAAE,GAAKD,EAAK,EAAE,EAC7CG,EAAK,KAAK,MAAMF,EAAE,GAAKD,EAAK,GAAIC,EAAE,GAAKD,EAAK,EAAE,EAC1C,KAAK,MAAMC,EAAE,GAAKD,EAAK,GAAIC,EAAE,GAAKD,EAAK,EAAE,EACnD,OAAOE,GAAMd,EAAW,GAAKe,GAAMf,EAAW,CAChD,CAAC,GAGCW,EAAc,KAAKC,CAAI,EAI3B,eAAQ,IAAI,oBAAoBD,EAAc,MAAM,gBAAgB,EAC7DA,CACT,CC/bO,SAASK,EAAeC,EAAoBC,EAAkC,CAEnF,GAAM,CAAC,GAAAC,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,CAAE,EAAIL,EACnB,CAAC,GAAIM,EAAI,GAAIC,EAAI,GAAIC,EAAI,GAAIC,CAAE,EAAIR,EAGnCS,GAASR,EAAKE,IAAKG,EAAKE,IAAON,EAAKE,IAAKC,EAAKE,GACpD,GAAI,KAAK,IAAIE,CAAK,EAAI,KACpB,OAAO,KAIT,IAAMC,IAAeT,EAAGG,EAAKF,EAAGC,IAAKE,EAAKE,IAAON,EAAKE,IAAKE,EAAGG,EAAKF,EAAGC,IAAOE,EACvEE,IAAeV,EAAGG,EAAKF,EAAGC,IAAKG,EAAKE,IAAON,EAAKE,IAAKC,EAAGG,EAAKF,EAAGC,IAAOE,EAGvEG,EAAU,CAACC,EAAWC,EAAWC,IACpCF,GAAK,KAAK,IAAIC,EAAGC,CAAC,EAAI,MAAQF,GAAK,KAAK,IAAIC,EAAGC,CAAC,EAAI,KAEvD,OACEH,EAAQF,EAAYT,EAAIE,CAAE,GAAKS,EAAQD,EAAYT,EAAIE,CAAE,GACzDQ,EAAQF,EAAYL,EAAIE,CAAE,GAAKK,EAAQD,EAAYL,EAAIE,CAAE,EAElD,CAAE,EAAGE,EAAY,EAAGC,CAAW,EAGjC,IACT,CAQO,SAASK,GAAkBC,EAA+B,CAC/D,IAAMC,EAAyB,CAAC,EAGhC,QAASC,EAAI,EAAGA,EAAIF,EAAM,OAAQE,IAChC,QAASC,EAAID,EAAI,EAAGC,EAAIH,EAAM,OAAQG,IAAK,CACzC,IAAMC,EAAevB,EAAemB,EAAME,CAAC,EAAGF,EAAMG,CAAC,CAAC,EAClDC,IAEFA,EAAa,oBACbH,EAAc,KAAKG,CAAY,EAEnC,CAGF,eAAQ,IAAI,iBAAiBH,EAAc,MAAM,qBAAqB,EAC/DA,CACT,CASO,SAASI,GAAiBL,EAA+B,CAC9D,IAAMM,EAAqB,CAAC,EAE5B,GAAIN,EAAM,OAAS,EAEjB,QAAWO,KAAQP,EAEjBM,EAAU,KAAK,CAAE,EAAGC,EAAK,GAAI,EAAGA,EAAK,GAAI,eAAyB,CAAC,EACnED,EAAU,KAAK,CAAE,EAAGC,EAAK,GAAI,EAAGA,EAAK,GAAI,eAAyB,CAAC,EAKvE,eAAQ,IAAI,qBAAqBD,EAAU,MAAM,iBAAiB,EAC3DA,CACT,CAUO,SAASE,GACdC,EACAR,EACAK,EAAqB,CAAC,EACb,CAET,IAAMI,EAAiB,CAAC,GAAGD,EAAS,GAAGR,EAAe,GAAGK,CAAS,EAGlE,eAAQ,IAAI,oBAAoBG,EAAQ,MAAM,aAAaR,EAAc,MAAM,uBAAuBK,EAAU,MAAM,YAAY,EAE3HI,CACT,CCtGA,SAASC,EACPC,EACAC,EACAC,EACAC,EACAC,EACAC,EACM,CACN,GAAIJ,EAAI,GAAKC,EAAI,GAAKD,GAAKD,EAAU,OAASE,GAAKF,EAAU,OAAQ,OACrE,IAAMM,GAAOJ,EAAIF,EAAU,MAAQC,GAAK,EACxCD,EAAU,KAAKM,CAAG,EAAIH,EACtBH,EAAU,KAAKM,EAAM,CAAC,EAAIF,EAC1BJ,EAAU,KAAKM,EAAM,CAAC,EAAID,CAC5B,CAKA,SAASE,EACPP,EACAQ,EACAC,EAAe,EACfC,EAAkC,CAAC,IAAK,EAAG,CAAC,EACtC,CAEN,IAAIC,EAAeF,EACnB,GAAID,EAAM,KACR,OAAQA,EAAM,KAAM,CAClB,iBACA,mBACEG,EAAe,KAAK,IAAIF,EAAO,EAAG,CAAC,EACnC,MACF,eACEE,EAAe,KAAK,IAAIF,EAAO,EAAG,CAAC,EACnC,KAEJ,CAGF,IAAMG,EAAW,KAAK,MAAMD,EAAe,CAAC,EAC5C,QAASE,EAAK,CAACD,EAAUC,GAAMD,EAAUC,IACvC,QAASC,EAAK,CAACF,EAAUE,GAAMF,EAAUE,IAAM,CAE7C,IAAMC,EAAaD,IAAO,GAAKD,IAAO,EAAK,IAAM,IAC3C,CAACV,EAAGC,EAAGC,CAAC,EAAIK,EAAM,IAAIM,GAAK,KAAK,IAAI,IAAMA,EAAID,EAAa,GAAG,CAAC,EACrEhB,EAAcC,EAAWQ,EAAM,EAAIM,EAAIN,EAAM,EAAIK,EAAIV,EAAGC,EAAGC,CAAC,CAC9D,CAEJ,CAKA,SAASY,EACPjB,EACAkB,EACAC,EACAC,EACAC,EACAX,EAAkC,CAAC,EAAG,EAAG,GAAG,EACtC,CACN,GAAM,CAAC,EAAGN,EAAGC,CAAC,EAAIK,EACZI,EAAK,KAAK,IAAIM,EAAKF,CAAE,EACrBL,EAAK,KAAK,IAAIQ,EAAKF,CAAE,EACrBG,EAAKJ,EAAKE,EAAK,EAAI,GACnBG,EAAKJ,EAAKE,EAAK,EAAI,GACrBG,EAAMV,EAAKD,EAEXZ,EAAIiB,EACJhB,EAAIiB,EAER,KACEpB,EAAcC,EAAWC,EAAGC,EAAG,EAAGE,EAAGC,CAAC,EAElC,EAAAJ,IAAMmB,GAAMlB,IAAMmB,IAHX,CAKX,IAAMI,EAAK,EAAID,EACXC,EAAK,CAACZ,IACRW,GAAOX,EACPZ,GAAKqB,GAEHG,EAAKX,IACPU,GAAOV,EACPZ,GAAKqB,EAET,CACF,CAQA,SAASG,EAAkBC,EAAiD,CAC1E,OAAQA,EAAW,CACjB,aACE,MAAO,CAAC,IAAK,EAAG,CAAC,EACnB,iBACE,MAAO,CAAC,IAAK,IAAK,CAAC,EACrB,eACE,MAAO,CAAC,IAAK,IAAK,GAAG,EACvB,mBACE,MAAO,CAAC,IAAK,IAAK,CAAC,EACrB,mBACA,QACE,MAAO,CAAC,IAAK,IAAK,CAAC,CACvB,CACF,CAWA,SAASC,EACP5B,EACAC,EACAC,EACA2B,EACAnB,EAAkC,CAAC,IAAK,IAAK,GAAG,EAC1C,CAGN,GAAM,CAACP,EAAGC,EAAGC,CAAC,EAAIK,EAClB,QAASG,EAAK,EAAGA,EAAK,EAAGA,IACvB,QAASC,EAAK,EAAGA,EAAK,EAAGA,IACvBf,EAAcC,EAAWC,EAAIa,EAAIZ,EAAIW,EAAIV,EAAGC,EAAGC,CAAC,CAGtD,CAUO,SAASyB,EACd9B,EACA+B,EACAC,EAAuB,GACZ,CAEX,IAAMC,EAASD,EACbhC,EACA,IAAI,UAAU,IAAI,kBAAkBA,EAAU,IAAI,EAAGA,EAAU,MAAOA,EAAU,MAAM,EAGxF,QAAWkC,KAAUH,EAAS,CAC5B,IAAMrB,EAAkCgB,EAAkBQ,EAAO,IAAI,EACrE3B,EAAU0B,EAAQC,EAAQ,EAAGxB,CAAK,CACpC,CAEA,OAAOuB,CACT,CAWO,SAASE,EACdnC,EACAoC,EACAJ,EAAuB,GACvBK,EAAsB,GACX,CAEX,IAAMJ,EAASD,EACbhC,EACA,IAAI,UAAU,IAAI,kBAAkBA,EAAU,IAAI,EAAGA,EAAU,MAAOA,EAAU,MAAM,EAGxF,QAAWQ,KAAS4B,EAAU,CAE5B,IAAM1B,EAAQgB,EAAkBlB,EAAM,IAAI,EAGpCC,EAAOD,EAAM,MAAQ,KAAK,IAAI,EAAI,KAAK,MAAMA,EAAM,MAAQ,CAAC,EAAG,EAAE,EAAI,EAC3ED,EAAU0B,EAAQzB,EAAOC,EAAMC,CAAK,EAEhC2B,GAAc7B,EAAM,MACtBoB,EAAUK,EAAQzB,EAAM,EAAI,EAAGA,EAAM,EAAI,EAAGA,EAAM,IAAI,CAE1D,CAEA,OAAOyB,CACT,CAUO,SAASK,EACdtC,EACAuC,EACAP,EAAuB,GACZ,CAEX,IAAMC,EAASD,EACbhC,EACA,IAAI,UAAU,IAAI,kBAAkBA,EAAU,IAAI,EAAGA,EAAU,MAAOA,EAAU,MAAM,EAGxF,OAAW,CAAE,GAAAkB,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,CAAG,IAAKkB,EAC/BtB,EACEgB,EACA,KAAK,MAAMf,CAAE,EACb,KAAK,MAAMC,CAAE,EACb,KAAK,MAAMC,CAAE,EACb,KAAK,MAAMC,CAAE,EACb,CAAC,EAAG,IAAK,GAAG,CACd,EAGF,OAAOY,CACT,CAWO,SAASO,GACdxC,EACAyC,EAMAT,EAAuB,GACvBU,EAAoC,CAAC,EAC1B,CACX,IAAMT,EAASD,EACbhC,EACA,IAAI,UAAU,IAAI,kBAAkBA,EAAU,IAAI,EAAGA,EAAU,MAAOA,EAAU,MAAM,EAWxF,GARIyC,EAAS,OACXH,EAAUL,EAAQQ,EAAS,MAAO,EAAI,EAGpCA,EAAS,SACXX,EAAYG,EAAQQ,EAAS,QAAS,EAAI,EAGxCA,EAAS,cAEX,QAAWjC,KAASiC,EAAS,cAC3BlC,EAAU0B,EAAQzB,EAAO,EAAGkB,gBAAwC,CAAC,EAIrEe,EAAS,UACXN,EAAoBF,EAAQQ,EAAS,SAAU,GAAMC,EAAQ,UAAU,EAIzE,IAAMC,EAAU,GACZC,EAAU,GACRC,EAAgB,GAGtB,OAAIJ,EAAS,UAAYA,EAAS,SAAS,OAAS,IAElDlC,EAAU0B,EAAQ,CAAC,EAAGU,EAAS,EAAGC,CAAO,EAAG,EAAGlB,UAAkC,CAAC,EAClFE,EAAUK,EAAQU,EAAU,GAAIC,EAAS,aAAc,CAAC,IAAK,IAAK,GAAG,CAAC,EACtEA,GAAWC,EAGXtC,EAAU0B,EAAQ,CAAC,EAAGU,EAAS,EAAGC,CAAO,EAAG,EAAGlB,cAAsC,CAAC,EACtFE,EAAUK,EAAQU,EAAU,GAAIC,EAAS,aAAc,CAAC,IAAK,IAAK,GAAG,CAAC,EACtEA,GAAWC,EAGXtC,EAAU0B,EAAQ,CAAC,EAAGU,EAAS,EAAGC,CAAO,EAAG,EAAGlB,YAAoC,CAAC,EACpFE,EAAUK,EAAQU,EAAU,GAAIC,EAAS,WAAY,CAAC,IAAK,IAAK,GAAG,CAAC,EACpEA,GAAWC,EAGXtC,EAAU0B,EAAQ,CAAC,EAAGU,EAAS,EAAGC,CAAO,EAAG,EAAGlB,gBAAwC,CAAC,EACxFE,EAAUK,EAAQU,EAAU,GAAIC,EAAS,eAAgB,CAAC,IAAK,IAAK,GAAG,CAAC,GAGnEX,CACT",
  "names": ["PointType", "imageToImageData", "img", "canvas", "ctx", "loadImage", "src", "resolve", "reject", "convertToGrayscale", "imageData", "width", "height", "data", "grayImageData", "grayData", "i", "gray", "thresholdImage", "threshold", "inverse", "binImageData", "binData", "val", "renderImageDataToCanvas", "preprocessImage", "options", "zhangSuenThinning", "imageData", "maxIterations", "width", "height", "data", "input", "getPixel", "x", "y", "idx", "setPixel", "value", "val", "pixelsRemoved", "iterations", "toRemove1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "neighbors", "neighborSum", "sum", "transitions", "i", "toRemove2", "result", "skeletonizeImage", "imageSource", "options", "img", "loadImage", "originalWidth", "originalHeight", "imageToImageData", "threshold", "inverse", "binaryImageData", "preprocessImage", "skelImageData", "classifyJunctionType", "neighborhood", "neighbors", "sum", "val", "transitions", "i", "patternString", "p", "getNeighborhood", "imageData", "x", "y", "width", "height", "data", "offsets", "dx", "dy", "nx", "idx", "detectCorners", "options", "corners", "endpointMap", "minNeighbors", "minTransitions", "includeTypes", "neighborCount", "pointType", "key", "clusterPoints", "points", "maxDistance", "distanceThreshold", "minClusterSize", "preserveTypes", "pointsByType", "point", "type", "allClusters", "clusters", "mergeOccurred", "j", "p1", "p2", "cluster", "typeClusters", "sumX", "sumY", "typeCounts", "mostCommonType", "maxCount", "detectStraightLines", "lines", "threshold", "minLineLength", "maxLineGap", "angleStep", "angleIdx", "theta", "cosTheta", "sinTheta", "potentialLinePoints", "a", "b", "first", "last", "filteredLines", "line", "l", "d1", "d2", "intersectLines", "line1", "line2", "x1", "y1", "x2", "y2", "x3", "y3", "x4", "y4", "denom", "intersectX", "intersectY", "between", "a", "b", "c", "findIntersections", "lines", "intersections", "i", "j", "intersection", "extractEndpoints", "endpoints", "line", "combineFeaturePoints", "corners", "combinedPoints", "setPixelColor", "imageData", "x", "y", "r", "g", "b", "idx", "drawPoint", "point", "size", "color", "adjustedSize", "halfSize", "dy", "dx", "intensity", "c", "drawLine", "x1", "y1", "x2", "y2", "sx", "sy", "err", "e2", "getPointTypeColor", "pointType", "drawLabel", "label", "drawCorners", "corners", "useOriginal", "result", "corner", "drawClusteredPoints", "clusters", "showLabels", "drawLines", "lines", "visualizeFeatures", "features", "options", "legendX", "legendY", "legendSpacing"]
}
