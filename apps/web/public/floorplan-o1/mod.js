// Floorplan O1 Library - Built with esbuild
var S=(r=>(r.CORNER="corner",r.ENDPOINT="endpoint",r.T_JUNCTION="t_junction",r.INTERSECTION="intersection",r.UNCLASSIFIED="unclassified",r))(S||{});function R(n){let t=document.createElement("canvas");t.width=n.width,t.height=n.height;let o=t.getContext("2d");if(!o)throw new Error("Could not get canvas context");return o.drawImage(n,0,0),o.getImageData(0,0,t.width,t.height)}function v(n){return new Promise((t,o)=>{let a=new Image;a.crossOrigin="Anonymous",a.onload=()=>t(a),a.onerror=()=>o(new Error("Failed to load image")),typeof n=="string"?a.src=n:a.src=URL.createObjectURL(n)})}function q(n){let{width:t,height:o,data:a}=n,c=document.createElement("canvas");c.width=t,c.height=o;let s=c.getContext("2d").createImageData(t,o),g=s.data;for(let m=0;m<a.length;m+=4){let f=.299*a[m]+.587*a[m+1]+.114*a[m+2];g[m]=f,g[m+1]=f,g[m+2]=f,g[m+3]=a[m+3]}return s}function A(n,t=128,o=!0){let{width:a,height:c,data:r}=n,s=document.createElement("canvas");s.width=a,s.height=c;let m=s.getContext("2d").createImageData(a,c),f=m.data;for(let u=0;u<r.length;u+=4){let l=r[u]===r[u+1]&&r[u]===r[u+2]?r[u]:.299*r[u]+.587*r[u+1]+.114*r[u+2],d=o?l<t?255:0:l>t?255:0;f[u]=d,f[u+1]=d,f[u+2]=d,f[u+3]=255}return m}function W(n,t){t.width=n.width,t.height=n.height;let o=t.getContext("2d");if(!o)throw new Error("Could not get canvas context");o.putImageData(n,0,0)}function $(n,t){let o=t?.threshold||128,a=t?.inverse!==void 0?t.inverse:!0;return A(n,o,a)}function G(n,t=100){let{width:o,height:a,data:c}=n,r=new Uint8ClampedArray(c),s=(l,d)=>{if(l<0||d<0||l>=o||d>=a)return 0;let i=(d*o+l)*4;return r[i]>0?1:0},g=(l,d,i)=>{let e=(d*o+l)*4,h=i>0?255:0;r[e]=r[e+1]=r[e+2]=h},m=!0,f=0;for(;m&&f<t;){m=!1,f++;let l=[];for(let i=1;i<a-1;i++)for(let e=1;e<o-1;e++){if(s(e,i)===0)continue;let h=s(e,i-1),I=s(e+1,i-1),p=s(e+1,i),T=s(e+1,i+1),b=s(e,i+1),x=s(e-1,i+1),y=s(e-1,i),P=s(e-1,i-1),N=[h,I,p,T,b,x,y,P],C=N.reduce((D,M)=>D+M,0);if(C<2||C>6)continue;let E=0;for(let D=0;D<N.length;D++)N[D]===0&&N[(D+1)%N.length]===1&&E++;E===1&&h*p*b===0&&p*b*y===0&&l.push([e,i])}for(let[i,e]of l)g(i,e,0),m=!0;let d=[];for(let i=1;i<a-1;i++)for(let e=1;e<o-1;e++){if(s(e,i)===0)continue;let h=s(e,i-1),I=s(e+1,i-1),p=s(e+1,i),T=s(e+1,i+1),b=s(e,i+1),x=s(e-1,i+1),y=s(e-1,i),P=s(e-1,i-1),N=[h,I,p,T,b,x,y,P],C=N.reduce((D,M)=>D+M,0);if(C<2||C>6)continue;let E=0;for(let D=0;D<N.length;D++)N[D]===0&&N[(D+1)%N.length]===1&&E++;E===1&&h*p*y===0&&h*b*y===0&&d.push([e,i])}for(let[i,e]of d)g(i,e,0),m=!0}console.log(`[DEBUG] Thinning completed after ${f} iterations`);let u=new Uint8ClampedArray(r);return new ImageData(u,o,a)}async function Y(n,t){let o=n instanceof HTMLImageElement?n:await v(n),a=o.width,c=o.height;console.log(`[DEBUG] Original (H\xD7W): ${c} \xD7 ${a}`);let r=R(o),s=t?.threshold??128,g=t?.inverse??!0,m=$(r,{threshold:s,inverse:g});console.log("[DEBUG] After preprocessing (grayscale + threshold)");let f=t?.maxIterations??100,u=G(m,f);return console.log("[DEBUG] After thinning with Zhang-Suen algorithm"),{skeleton:u,originalWidth:a,originalHeight:c,debugInfo:{thresholdValue:s,algorithm:"Zhang-Suen thinning algorithm"}}}function F(n){let t=n.reduce((c,r)=>c+r,0),o=0;for(let c=0;c<n.length;c++)n[c]===0&&n[(c+1)%n.length]===1&&o++;let a=n.join("")+n[0];if(t===1||t===2&&o>=2){if(t===1)return"endpoint";for(let c=0;c<n.length;c++)if(n[c]===1&&n[(c+1)%8]===1)return"endpoint"}if(t===2){if(o===2){for(let r=0;r<n.length;r++)if(n[r]===1&&n[(r+1)%8]===1)return"unclassified";return"corner"}if(["10000100","01000010","00100001","00010001"].some(r=>a.includes(r)))return"corner"}if(t===3){if(o===2)return"t_junction";if(["10001000","01000100","00100010","00010001"].some(r=>a.includes(r)))return"t_junction"}return t>=4&&o>=2?"intersection":"unclassified"}function B(n,t,o){let{width:a,height:c,data:r}=n;if(t<1||o<1||t>=a-1||o>=c-1)return[];let s=[],g=[[-1,-1],[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0]];for(let[m,f]of g){let u=t+m,d=((o+f)*a+u)*4;s.push(r[d]>0?1:0)}return s}function rt(n,t={}){let{width:o,height:a,data:c}=n,r=[],s=new Map,g=t.minNeighbors??1,m=t.minTransitions??1,f=t.includeTypes??["corner","t_junction","endpoint","intersection"];for(let u=1;u<a-1;u++)for(let l=1;l<o-1;l++){let d=(u*o+l)*4;if(c[d]===0)continue;let i=B(n,l,u);if(i.length===0)continue;let e=i.reduce((p,T)=>p+T,0),h=F(i);if(h==="endpoint"){if(f.includes("endpoint")){let p=`${l},${u}`;s.set(p,{x:l,y:u,type:"endpoint"})}continue}if(e<g)continue;let I=0;for(let p=0;p<i.length;p++)i[p]===0&&i[(p+1)%8]===1&&I++;I<m||f.includes(h)&&r.push({x:l,y:u,type:h})}return r.push(...s.values()),console.log(`[DEBUG] Detected ${r.length} corner candidates (including endpoints: ${s.size})`),r}function it(n,t={}){if(n.length===0)return[];let o=t.maxDistance??10,a=t.distanceThreshold??30,c=t.minClusterSize??1,r=t.preserveTypes??!0,s={};if(r){for(let f of n){let u=f.type||"unclassified";s[u]||(s[u]=[]),s[u].push(f)}s.endpoint||(s.endpoint=[])}else s.all=n;let g=[];for(let f in s){let l=s[f].map(e=>[e]),d=!0;for(;d;){d=!1;for(let e=0;e<l.length;e++)if(l[e])for(let h=e+1;h<l.length;h++){if(!l[h])continue;l[e].some(p=>l[h].some(T=>{let b=p.x-T.x,x=p.y-T.y;return Math.sqrt(b*b+x*x)<=o}))&&(l[e]=l[e].concat(l[h]),l[h]=null,d=!0)}d&&(l=l.filter(e=>e!==null))}let i=l.filter(e=>e.length>=c).map(e=>{let h=e.reduce((x,y)=>x+y.x,0),I=e.reduce((x,y)=>x+y.y,0),p={};for(let x of e){let y=x.type||"unclassified";p[y]=(p[y]||0)+1}let T="unclassified",b=0;for(let x in p)p[x]>b&&(b=p[x],T=x);return{x:Math.round(h/e.length),y:Math.round(I/e.length),type:T,count:e.length}});g.push(...i)}let m={};for(let f of g){let u=f.type||"unclassified";m[u]=(m[u]||0)+1}return console.log(`[DEBUG] Clustered into ${g.length} points`),console.log("[DEBUG] Point types after clustering:"),console.log(`Endpoints: ${m.endpoint||0}`),console.log(`T-Junctions: ${m.t_junction||0}`),console.log(`Corners: ${m.corner||0}`),console.log(`Intersections: ${m.intersection||0}`),console.log(`Unclassified: ${m.unclassified||0}`),g}function st(n,t,o={}){if(t.length<2)return[];let{width:a,height:c,data:r}=n,s=[],g=o.maxLineGap??5,m=o.maxDistance??100,f=(l,d)=>{let i=d.x-l.x,e=d.y-l.y,h=Math.sqrt(i*i+e*e);if(h>m)return!1;let I=Math.max(10,Math.floor(h/2)),p=0;for(let b=0;b<=I;b++){let x=b/I,y=Math.round(l.x+i*x),P=Math.round(l.y+e*x);if(y>=0&&y<a&&P>=0&&P<c){let N=(P*a+y)*4;r[N]>0&&p++}}let T=h<20?.9:.7;return p/I>=T};for(let l=0;l<t.length;l++){let d=t[l];for(let i=l+1;i<t.length;i++){let e=t[i];f(d,e)&&s.push({x1:d.x,y1:d.y,x2:e.x,y2:e.y})}}let u=[];for(let l of s)u.some(i=>{let e=Math.hypot(i.x1-l.x1,i.y1-l.y1)+Math.hypot(i.x2-l.x2,i.y2-l.y2),h=Math.hypot(i.x1-l.x2,i.y1-l.y2)+Math.hypot(i.x2-l.x1,i.y2-l.y1);return e<=g*2||h<=g*2})||u.push(l);return console.log(`[DEBUG] Created ${u.length} wall lines by connecting junctions`),u}function ct(n,t={}){let{width:o,height:a,data:c}=n,r=[],s=t.threshold??30,g=t.minLineLength??20,m=t.maxLineGap??5,f=t.maxDistance??5,u=[];for(let i=0;i<a;i++)for(let e=0;e<o;e++){let h=(i*o+e)*4;c[h]>0&&u.push({x:e,y:i})}let l=Math.PI/180;for(let i=0;i<u.length;i++){let e=u[i];for(let h=0;h<180;h++){let I=h*l,p=Math.cos(I),T=Math.sin(I),b=[];b.push(e);for(let x=0;x<u.length;x++){if(i===x)continue;let y=u[x],P=y.x-e.x,N=y.y-e.y;Math.abs(-T*y.x+p*y.y-(-T*e.x+p*e.y))<=f&&b.push(y)}if(b.length>=s){b.sort((E,D)=>(E.x-e.x)*p+(E.y-e.y)*T-((D.x-e.x)*p+(D.y-e.y)*T));let x=b[0],y=b[b.length-1],P=y.x-x.x,N=y.y-x.y;Math.sqrt(P*P+N*N)>=g&&r.push({x1:x.x,y1:x.y,x2:y.x,y2:y.y})}}}let d=[];for(let i of r)d.some(h=>{let I=Math.hypot(h.x1-i.x1,h.y1-i.y1)+Math.hypot(h.x2-i.x2,h.y2-i.y2),p=Math.hypot(h.x1-i.x2,h.y1-i.y2)+Math.hypot(h.x2-i.x1,h.y2-i.y1);return I<=m*2||p<=m*2})||d.push(i);return console.log(`[DEBUG] Detected ${d.length} line segments`),d}function J(n,t){let{x1:o,y1:a,x2:c,y2:r}=n,{x1:s,y1:g,x2:m,y2:f}=t,u=(o-c)*(g-f)-(a-r)*(s-m);if(Math.abs(u)<1e-6)return null;let l=((o*r-a*c)*(s-m)-(o-c)*(s*f-g*m))/u,d=((o*r-a*c)*(g-f)-(a-r)*(s*f-g*m))/u,i=(e,h,I)=>e>=Math.min(h,I)-1e-6&&e<=Math.max(h,I)+1e-6;return i(l,o,c)&&i(d,a,r)&&i(l,s,m)&&i(d,g,f)?{x:l,y:d}:null}function ht(n){let t=[];for(let o=0;o<n.length;o++)for(let a=o+1;a<n.length;a++){let c=J(n[o],n[a]);c&&(c.type="intersection",t.push(c))}return console.log(`[DEBUG] Found ${t.length} line intersections`),t}function gt(n){let t=[];if(n.length>0)for(let o of n)t.push({x:o.x1,y:o.y1,type:"endpoint"}),t.push({x:o.x2,y:o.y2,type:"endpoint"});return console.log(`[DEBUG] Extracted ${t.length} line endpoints`),t}function ft(n,t,o=[]){let a=[...n,...t,...o];return console.log(`[DEBUG] Combined ${n.length} corners, ${t.length} intersections, and ${o.length} endpoints`),a}function U(n,t,o,a,c,r){if(t<0||o<0||t>=n.width||o>=n.height)return;let s=(o*n.width+t)*4;n.data[s]=a,n.data[s+1]=c,n.data[s+2]=r}function L(n,t,o=3,a=[255,0,0]){let c=o;if(t.type)switch(t.type){case"t_junction":case"intersection":c=Math.max(o*3,9);break;case"endpoint":c=Math.max(o*2,6);break}let r=Math.floor(c/2);for(let s=-r;s<=r;s++)for(let g=-r;g<=r;g++){let m=g===0&&s===0?255:180,[f,u,l]=a.map(d=>Math.min(255,d*m/255));U(n,t.x+g,t.y+s,f,u,l)}}function k(n,t,o,a,c,r=[0,0,255]){let[s,g,m]=r,f=Math.abs(a-t),u=Math.abs(c-o),l=t<a?1:-1,d=o<c?1:-1,i=f-u,e=t,h=o;for(;U(n,e,h,s,g,m),!(e===a&&h===c);){let I=2*i;I>-u&&(i-=u,e+=l),I<f&&(i+=f,h+=d)}}function w(n){switch(n){case"corner":return[255,0,0];case"t_junction":return[255,255,0];case"endpoint":return[173,216,230];case"intersection":return[255,255,0];case"unclassified":default:return[255,165,0]}}function O(n,t,o,a,c=[255,255,255]){let[r,s,g]=c;for(let m=0;m<5;m++)for(let f=0;f<5;f++)U(n,t+f,o+m,r,s,g)}function j(n,t,o=!1){let a=o?n:new ImageData(new Uint8ClampedArray(n.data),n.width,n.height);for(let c of t){let r=w(c.type);L(a,c,3,r)}return a}function _(n,t,o=!1,a=!1){let c=o?n:new ImageData(new Uint8ClampedArray(n.data),n.width,n.height);for(let r of t){let s=w(r.type),g=r.count?Math.min(5+Math.floor(r.count/3),10):5;L(c,r,g,s),a&&r.type&&O(c,r.x+6,r.y-6,r.type)}return c}function z(n,t,o=!1){let a=o?n:new ImageData(new Uint8ClampedArray(n.data),n.width,n.height);for(let{x1:c,y1:r,x2:s,y2:g}of t)k(a,Math.round(c),Math.round(r),Math.round(s),Math.round(g),[0,255,255]);return a}function It(n,t,o=!1,a={}){let c=o?n:new ImageData(new Uint8ClampedArray(n.data),n.width,n.height);if(t.lines&&z(c,t.lines,!0),t.corners&&j(c,t.corners,!0),t.intersections)for(let m of t.intersections)L(c,m,3,w("intersection"));t.clusters&&_(c,t.clusters,!0,a.showLabels);let r=10,s=10,g=15;return t.clusters&&t.clusters.length>0&&(L(c,{x:r,y:s},5,w("corner")),O(c,r+10,s,"Corner (L)",[255,255,255]),s+=g,L(c,{x:r,y:s},5,w("t_junction")),O(c,r+10,s,"T-Junction",[255,255,255]),s+=g,L(c,{x:r,y:s},5,w("endpoint")),O(c,r+10,s,"Endpoint",[255,255,255]),s+=g,L(c,{x:r,y:s},5,w("intersection")),O(c,r+10,s,"Intersection",[255,255,255])),c}export{S as PointType,F as classifyJunctionType,it as clusterPoints,ft as combineFeaturePoints,st as connectJunctionsToLines,q as convertToGrayscale,rt as detectCorners,ct as detectStraightLines,_ as drawClusteredPoints,j as drawCorners,z as drawLines,gt as extractEndpoints,ht as findIntersections,R as imageToImageData,J as intersectLines,v as loadImage,$ as preprocessImage,W as renderImageDataToCanvas,Y as skeletonizeImage,A as thresholdImage,It as visualizeFeatures,G as zhangSuenThinning};
//# sourceMappingURL=mod.js.map
