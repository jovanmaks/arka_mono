// Floorplan O1 Library - Built with esbuild
var B=(o=>(o.CORNER="corner",o.ENDPOINT="endpoint",o.T_JUNCTION="t_junction",o.INTERSECTION="intersection",o.UNCLASSIFIED="unclassified",o))(B||{});function J(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height;let n=e.getContext("2d");if(!n)throw new Error("Could not get canvas context");return n.drawImage(t,0,0),n.getImageData(0,0,e.width,e.height)}function k(t){return new Promise((e,n)=>{let i=new Image;i.crossOrigin="Anonymous",i.onload=()=>e(i),i.onerror=()=>n(new Error("Failed to load image")),typeof t=="string"?i.src=t:i.src=URL.createObjectURL(t)})}function et(t){let{width:e,height:n,data:i}=t,s=document.createElement("canvas");s.width=e,s.height=n;let r=s.getContext("2d").createImageData(e,n),m=r.data;for(let u=0;u<i.length;u+=4){let x=.299*i[u]+.587*i[u+1]+.114*i[u+2];m[u]=x,m[u+1]=x,m[u+2]=x,m[u+3]=i[u+3]}return r}function H(t,e=128,n=!0){let{width:i,height:s,data:o}=t,r=document.createElement("canvas");r.width=i,r.height=s;let u=r.getContext("2d").createImageData(i,s),x=u.data;for(let a=0;a<o.length;a+=4){let g=o[a]===o[a+1]&&o[a]===o[a+2]?o[a]:.299*o[a]+.587*o[a+1]+.114*o[a+2],y=n?g<e?255:0:g>e?255:0;x[a]=y,x[a+1]=y,x[a+2]=y,x[a+3]=255}return u}function nt(t,e){e.width=t.width,e.height=t.height;let n=e.getContext("2d");if(!n)throw new Error("Could not get canvas context");n.putImageData(t,0,0)}function _(t,e){let n=e?.threshold||128,i=e?.inverse!==void 0?e.inverse:!0;return H(t,n,i)}function q(t,e=100){let{width:n,height:i,data:s}=t,o=new Uint8ClampedArray(s),r=(g,y)=>{if(g<0||y<0||g>=n||y>=i)return 0;let c=(y*n+g)*4;return o[c]>0?1:0},m=(g,y,c)=>{let h=(y*n+g)*4,b=c>0?255:0;o[h]=o[h+1]=o[h+2]=b},u=!0,x=0;for(;u&&x<e;){u=!1,x++;let g=[];for(let c=1;c<i-1;c++)for(let h=1;h<n-1;h++){if(r(h,c)===0)continue;let b=r(h,c-1),l=r(h+1,c-1),f=r(h+1,c),T=r(h+1,c+1),N=r(h,c+1),P=r(h-1,c+1),p=r(h-1,c),d=r(h-1,c-1),I=[b,l,f,T,N,P,p,d],E=I.reduce((C,S)=>C+S,0);if(E<2||E>6)continue;let L=0;for(let C=0;C<I.length;C++)I[C]===0&&I[(C+1)%I.length]===1&&L++;L===1&&b*f*N===0&&f*N*p===0&&g.push([h,c])}for(let[c,h]of g)m(c,h,0),u=!0;let y=[];for(let c=1;c<i-1;c++)for(let h=1;h<n-1;h++){if(r(h,c)===0)continue;let b=r(h,c-1),l=r(h+1,c-1),f=r(h+1,c),T=r(h+1,c+1),N=r(h,c+1),P=r(h-1,c+1),p=r(h-1,c),d=r(h-1,c-1),I=[b,l,f,T,N,P,p,d],E=I.reduce((C,S)=>C+S,0);if(E<2||E>6)continue;let L=0;for(let C=0;C<I.length;C++)I[C]===0&&I[(C+1)%I.length]===1&&L++;L===1&&b*f*p===0&&b*N*p===0&&y.push([h,c])}for(let[c,h]of y)m(c,h,0),u=!0}console.log(`[DEBUG] Thinning completed after ${x} iterations`);let a=new Uint8ClampedArray(o);return new ImageData(a,n,i)}async function st(t,e){let n=t instanceof HTMLImageElement?t:await k(t),i=n.width,s=n.height;console.log(`[DEBUG] Original (H\xD7W): ${s} \xD7 ${i}`);let o=J(n),r=e?.threshold??128,m=e?.inverse??!0,u=_(o,{threshold:r,inverse:m});console.log("[DEBUG] After preprocessing (grayscale + threshold)");let x=e?.maxIterations??100,a=q(u,x);return console.log("[DEBUG] After thinning with Zhang-Suen algorithm"),{skeleton:a,originalWidth:i,originalHeight:s,debugInfo:{thresholdValue:r,algorithm:"Zhang-Suen thinning algorithm"}}}function z(t){let e=t.reduce((s,o)=>s+o,0),n=0;for(let s=0;s<t.length;s++)t[s]===0&&t[(s+1)%t.length]===1&&n++;let i=t.join("")+t[0];if(e===1||e===2&&n>=2){if(e===1)return"endpoint";for(let s=0;s<t.length;s++)if(t[s]===1&&t[(s+1)%8]===1)return"endpoint"}if(e===2){if(n===2){for(let m=0;m<t.length;m++)if(t[m]===1&&t[(m+1)%8]===1)return"unclassified";return[[1,0,0,0,0,1,0,0],[0,1,0,0,0,0,1,0],[0,0,1,0,0,0,0,1],[0,0,0,1,1,0,0,0]].some(m=>{for(let u=0;u<8;u++)if(m[u]!==t[u])return!1;return!0})?"corner":"unclassified"}if(["10000100","01000010","00100001","00010001"].includes(t.join("")))return"corner"}if(e===3){if(n===2)return"t_junction";if(["10001000","01000100","00100010","00010001"].some(o=>i.includes(o)))return"t_junction"}return e>=4&&n>=2?"intersection":"unclassified"}function W(t,e,n){let{width:i,height:s,data:o}=t;if(e<1||n<1||e>=i-1||n>=s-1)return[];let r=[],m=[[-1,-1],[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0]];for(let[u,x]of m){let a=e+u,y=((n+x)*i+a)*4;r.push(o[y]>0?1:0)}return r}function mt(t,e={}){let{width:n,height:i,data:s}=t,o=[],r=new Map,m=e.minNeighbors??1,u=e.minTransitions??1,x=e.includeTypes??["corner","t_junction","endpoint","intersection"];for(let a=1;a<i-1;a++)for(let g=1;g<n-1;g++){let y=(a*n+g)*4;if(s[y]===0)continue;let c=W(t,g,a);if(c.length===0)continue;let h=c.reduce((f,T)=>f+T,0),b=z(c);if(b==="endpoint"){if(x.includes("endpoint")){let f=`${g},${a}`;r.set(f,{x:g,y:a,type:"endpoint"})}continue}if(h<m)continue;let l=0;for(let f=0;f<c.length;f++)c[f]===0&&c[(f+1)%8]===1&&l++;l<u||x.includes(b)&&o.push({x:g,y:a,type:b})}return o.push(...r.values()),console.log(`[DEBUG] Detected ${o.length} corner candidates (including endpoints: ${r.size})`),o}function ft(t,e={}){if(t.length===0)return[];let n=e.maxDistance??10,i=e.distanceThreshold??30,s=e.minClusterSize??1,o=e.preserveTypes??!1;console.log(`[DEBUG] Clustering with maxDistance=${n}, preserveTypes=${o}`);let r=Math.max(8,n/2);console.log(`[DEBUG] Initial tight clustering with radius=${r}`);let m=[];for(let l=0;l<t.length;l++){m[l]=[];for(let f=0;f<t.length;f++){let T=t[l].x-t[f].x,N=t[l].y-t[f].y;m[l][f]=Math.sqrt(T*T+N*N)}}let u=[],x=new Set;for(let l=0;l<t.length;l++){if(x.has(l))continue;let f=[l];x.add(l);for(let T=0;T<t.length;T++)l===T||x.has(T)||m[l][T]<=r&&(f.push(T),x.add(T));u.push(f)}console.log(`[DEBUG] Initial clustering: ${u.length} clusters from ${t.length} points`);let a=[];if(o){let l={};for(let f of u){let T={};for(let d of f){let I=t[d].type||"unclassified";T[I]=(T[I]||0)+1}let N="unclassified",P=0;for(let d in T)T[d]>P&&(P=T[d],N=d);let p=f.map(d=>t[d]);l[N]||(l[N]=[]),l[N].push(...p)}for(let f in l){let T=l[f];a.push(...T.map(N=>[N]))}}else a=u.map(l=>l.map(f=>t[f]));let g=!0,y=0,c=10;for(;g&&y<c;){g=!1,y++;for(let l=0;l<a.length;l++)if(a[l])for(let f=l+1;f<a.length;f++){if(!a[f])continue;a[l].some(N=>a[f].some(P=>{let p=N.x-P.x,d=N.y-P.y;return Math.sqrt(p*p+d*d)<=n}))&&(a[l]=a[l].concat(a[f]),a[f]=null,g=!0)}g&&(a=a.filter(l=>l!==null),console.log(`[DEBUG] Clustering iteration ${y}: ${a.length} clusters remaining`))}let h=a.filter(l=>l.length>=s).map(l=>{let f=l.reduce((I,E)=>I+E.x,0),T=l.reduce((I,E)=>I+E.y,0),N={intersection:4,t_junction:3,corner:2,endpoint:1,unclassified:0},P={};for(let I of l){let E=I.type||"unclassified";P[E]=(P[E]||0)+1}let p="unclassified",d=-1;for(let I in P){let E=N[I]||0;E>d&&P[I]>0&&(d=E,p=I)}return{x:Math.round(f/l.length),y:Math.round(T/l.length),type:p,count:l.length}}),b={};for(let l of h){let f=l.type||"unclassified";b[f]=(b[f]||0)+1}return console.log(`[DEBUG] Final result: Clustered ${t.length} points into ${h.length} points`),console.log("[DEBUG] Point types after clustering:"),console.log(`Endpoints: ${b.endpoint||0}`),console.log(`T-Junctions: ${b.t_junction||0}`),console.log(`Corners: ${b.corner||0}`),console.log(`Intersections: ${b.intersection||0}`),console.log(`Unclassified: ${b.unclassified||0}`),h}function dt(t,e,n={}){if(e.length<2)return[];let{width:i,height:s,data:o}=t,r=[],m=n.maxLineGap??5,u=n.maxDistance??100,x=(g,y)=>{let c=y.x-g.x,h=y.y-g.y,b=Math.sqrt(c*c+h*h);if(b>u)return!1;let l=Math.max(10,Math.floor(b/2)),f=0;for(let N=0;N<=l;N++){let P=N/l,p=Math.round(g.x+c*P),d=Math.round(g.y+h*P);if(p>=0&&p<i&&d>=0&&d<s){let I=(d*i+p)*4;o[I]>0&&f++}}let T=b<20?.9:.7;return f/l>=T};for(let g=0;g<e.length;g++){let y=e[g];for(let c=g+1;c<e.length;c++){let h=e[c];x(y,h)&&r.push({x1:y.x,y1:y.y,x2:h.x,y2:h.y})}}let a=[];for(let g of r)a.some(c=>{let h=Math.hypot(c.x1-g.x1,c.y1-g.y1)+Math.hypot(c.x2-g.x2,c.y2-g.y2),b=Math.hypot(c.x1-g.x2,c.y1-g.y2)+Math.hypot(c.x2-g.x1,c.y2-g.y1);return h<=m*2||b<=m*2})||a.push(g);return console.log(`[DEBUG] Created ${a.length} wall lines by connecting junctions`),a}function pt(t,e={}){let{width:n,height:i,data:s}=t,o=[],r=e.threshold??15,m=e.minLineLength??20,u=e.maxLineGap??5,x=e.maxDistance??5;console.log(`[DEBUG] Detecting lines with params: threshold=${r}, minLineLength=${m}, maxLineGap=${u}`);let a=[];for(let p=0;p<i;p++)for(let d=0;d<n;d++){let I=(p*n+d)*4;s[I]>0&&a.push({x:d,y:p})}if(console.log(`[DEBUG] Found ${a.length} foreground pixels to process`),a.length<r)return console.log("[DEBUG] Not enough foreground pixels to detect lines"),[];let g=Math.PI/Math.max(90,Math.min(180,Math.ceil(Math.sqrt(n*i)/10))),y=Math.ceil(Math.PI/g);console.log(`[DEBUG] Using ${y} angle steps for line detection`);let c=Math.ceil(Math.sqrt(n*n+i*i)),h=1,b=Math.ceil(2*c/h),l=Math.floor(b/2),f=new Int32Array(b*y),T=new Map;for(let p=0;p<a.length;p++){let d=a[p],I=d.x,E=d.y;for(let L=0;L<y;L++){let C=L*g,S=Math.cos(C),$=Math.sin(C),G=I*S+E*$,M=Math.floor(G+l);if(M<0||M>=b)continue;let D=M*y+L;f[D]++,T.has(D)||T.set(D,[]),T.get(D).push(p)}}for(let p=0;p<b;p++)for(let d=0;d<y;d++){let I=p*y+d;if(f[I]>=r){let L=d*g,C=(p-l)*h,S=T.get(I);if(!S||S.length<2)continue;let $=Math.cos(L),G=Math.sin(L),M=[];for(let D of S){let w=a[D];Math.abs(w.x*$+w.y*G-C)<=x&&M.push(w)}if(M.length>=r){M.sort((w,R)=>{let v=w.x*-G+w.y*$,j=R.x*-G+R.y*$;return v-j});let D=[M[0]];for(let w=1;w<M.length;w++){let R=D[D.length-1],v=M[w];Math.hypot(v.x-R.x,v.y-R.y)<=u?D.push(v):(Math.hypot(D[D.length-1].x-D[0].x,D[D.length-1].y-D[0].y)>=m&&o.push({x1:D[0].x,y1:D[0].y,x2:D[D.length-1].x,y2:D[D.length-1].y}),D=[v])}D.length>1&&Math.hypot(D[D.length-1].x-D[0].x,D[D.length-1].y-D[0].y)>=m&&o.push({x1:D[0].x,y1:D[0].y,x2:D[D.length-1].x,y2:D[D.length-1].y})}}}let N=[],P=new Set;o.sort((p,d)=>{let I=Math.hypot(p.x2-p.x1,p.y2-p.y1);return Math.hypot(d.x2-d.x1,d.y2-d.y1)-I});for(let p=0;p<o.length;p++){if(P.has(p))continue;let d=o[p];N.push(d),P.add(p);for(let I=p+1;I<o.length;I++){if(P.has(I))continue;let E=o[I],L=Math.hypot(d.x1-E.x1,d.y1-E.y1)+Math.hypot(d.x2-E.x2,d.y2-E.y2),C=Math.hypot(d.x1-E.x2,d.y1-E.y2)+Math.hypot(d.x2-E.x1,d.y2-E.y1),S=u*3;(L<=S||C<=S)&&P.add(I)}}return console.log(`[DEBUG] Detected ${o.length} line candidates, filtered to ${N.length} line segments`),N}function X(t,e){let{x1:n,y1:i,x2:s,y2:o}=t,{x1:r,y1:m,x2:u,y2:x}=e,a=(n-s)*(m-x)-(i-o)*(r-u);if(Math.abs(a)<1e-6)return null;let g=((n*o-i*s)*(r-u)-(n-s)*(r*x-m*u))/a,y=((n*o-i*s)*(m-x)-(i-o)*(r*x-m*u))/a,c=(h,b,l)=>h>=Math.min(b,l)-1e-6&&h<=Math.max(b,l)+1e-6;return c(g,n,s)&&c(y,i,o)&&c(g,r,u)&&c(y,m,x)?{x:g,y}:null}function Tt(t){let e=[];for(let n=0;n<t.length;n++)for(let i=n+1;i<t.length;i++){let s=X(t[n],t[i]);s&&(s.type="intersection",e.push(s))}return console.log(`[DEBUG] Found ${e.length} line intersections`),e}function Dt(t){let e=[];if(t.length>0)for(let n of t)e.push({x:n.x1,y:n.y1,type:"endpoint"}),e.push({x:n.x2,y:n.y2,type:"endpoint"});return console.log(`[DEBUG] Extracted ${e.length} line endpoints`),e}function Nt(t,e,n=[]){let i=[...t,...e,...n];return console.log(`[DEBUG] Combined ${t.length} corners, ${e.length} intersections, and ${n.length} endpoints`),i}function F(t,e,n,i,s,o){if(e<0||n<0||e>=t.width||n>=t.height)return;let r=(n*t.width+e)*4;t.data[r]=i,t.data[r+1]=s,t.data[r+2]=o}function O(t,e,n=6,i=[255,0,0],s=!0){let o=n;if(s&&e.type)switch(e.type){case"t_junction":case"intersection":o=Math.max(n*2,12);break;case"endpoint":o=Math.max(n*1.5,8);break;case"corner":o=Math.max(n*1.5,8);break}let r=Math.floor(o/2);for(let m=-r;m<=r;m++)for(let u=-r;u<=r;u++){let x=u===0&&m===0?255:180,[a,g,y]=i.map(c=>Math.min(255,c*x/255));F(t,e.x+u,e.y+m,a,g,y)}}function Y(t,e,n,i,s,o=[0,0,255]){let[r,m,u]=o,x=Math.abs(i-e),a=Math.abs(s-n),g=e<i?1:-1,y=n<s?1:-1,c=x-a,h=e,b=n;for(;;){for(let f=-1;f<=1;f++)for(let T=-1;T<=1;T++)F(t,h+T,b+f,r,m,u);if(h===i&&b===s)break;let l=2*c;l>-a&&(c-=a,h+=g),l<x&&(c+=x,b+=y)}}function U(t){switch(t){case"corner":return[0,0,139];case"t_junction":return[0,255,0];case"endpoint":return[173,216,230];case"intersection":return[255,0,255];case"unclassified":default:return[255,165,0]}}function A(t,e,n,i,s=[255,255,255]){let[o,r,m]=s;for(let u=0;u<5;u++)for(let x=0;x<5;x++)F(t,e+x,n+u,o,r,m)}function V(t,e,n=!1){let i=n?t:new ImageData(new Uint8ClampedArray(t.data),t.width,t.height);for(let s of e){let o=U(s.type);O(i,s,3,o,!0)}return i}function Z(t,e,n=!1,i=!1){let s=n?t:new ImageData(new Uint8ClampedArray(t.data),t.width,t.height);for(let o of e){let r=U(o.type);O(s,o,6,r,!0),i&&o.type&&A(s,o.x+8,o.y-8,o.type)}return s}function K(t,e,n=!1){let i=n?t:new ImageData(new Uint8ClampedArray(t.data),t.width,t.height);for(let{x1:s,y1:o,x2:r,y2:m}of e)Y(i,Math.round(s),Math.round(o),Math.round(r),Math.round(m),[255,69,0]);return i}function St(t,e,n=!1,i={}){let s=n?t:new ImageData(new Uint8ClampedArray(t.data),t.width,t.height);if(e.lines&&K(s,e.lines,!0),e.corners&&V(s,e.corners,!0),e.intersections)for(let u of e.intersections)O(s,u,6,U("intersection"),!0);e.clusters&&Z(s,e.clusters,!0,i.showLabels);let o=10,r=10,m=20;return e.clusters&&e.clusters.length>0&&(O(s,{x:o,y:r},6,U("corner"),!0),A(s,o+12,r,"Corner (L)",[255,255,255]),r+=m,O(s,{x:o,y:r},6,U("t_junction"),!0),A(s,o+12,r,"T-Junction",[255,255,255]),r+=m,O(s,{x:o,y:r},6,U("endpoint"),!0),A(s,o+12,r,"Endpoint",[255,255,255]),r+=m,O(s,{x:o,y:r},6,U("intersection"),!0),A(s,o+12,r,"Intersection",[255,255,255])),s}export{B as PointType,z as classifyJunctionType,ft as clusterPoints,Nt as combineFeaturePoints,dt as connectJunctionsToLines,et as convertToGrayscale,mt as detectCorners,pt as detectStraightLines,Z as drawClusteredPoints,V as drawCorners,K as drawLines,Dt as extractEndpoints,Tt as findIntersections,J as imageToImageData,X as intersectLines,k as loadImage,_ as preprocessImage,nt as renderImageDataToCanvas,st as skeletonizeImage,H as thresholdImage,St as visualizeFeatures,q as zhangSuenThinning};
//# sourceMappingURL=mod.js.map
