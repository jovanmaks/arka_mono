// Floorplan O1 Library - Built with esbuild
var O=(r=>(r.CORNER="corner",r.ENDPOINT="endpoint",r.T_JUNCTION="t_junction",r.INTERSECTION="intersection",r.UNCLASSIFIED="unclassified",r))(O||{});function R(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height;let n=e.getContext("2d");if(!n)throw new Error("Could not get canvas context");return n.drawImage(t,0,0),n.getImageData(0,0,e.width,e.height)}function v(t){return new Promise((e,n)=>{let a=new Image;a.crossOrigin="Anonymous",a.onload=()=>e(a),a.onerror=()=>n(new Error("Failed to load image")),typeof t=="string"?a.src=t:a.src=URL.createObjectURL(t)})}function q(t){let{width:e,height:n,data:a}=t,i=document.createElement("canvas");i.width=e,i.height=n;let s=i.getContext("2d").createImageData(e,n),f=s.data;for(let m=0;m<a.length;m+=4){let p=.299*a[m]+.587*a[m+1]+.114*a[m+2];f[m]=p,f[m+1]=p,f[m+2]=p,f[m+3]=a[m+3]}return s}function G(t,e=128,n=!0){let{width:a,height:i,data:r}=t,s=document.createElement("canvas");s.width=a,s.height=i;let m=s.getContext("2d").createImageData(a,i),p=m.data;for(let l=0;l<r.length;l+=4){let g=r[l]===r[l+1]&&r[l]===r[l+2]?r[l]:.299*r[l]+.587*r[l+1]+.114*r[l+2],x=n?g<e?255:0:g>e?255:0;p[l]=x,p[l+1]=x,p[l+2]=x,p[l+3]=255}return m}function W(t,e){e.width=t.width,e.height=t.height;let n=e.getContext("2d");if(!n)throw new Error("Could not get canvas context");n.putImageData(t,0,0)}function $(t,e){let n=e?.threshold||128,a=e?.inverse!==void 0?e.inverse:!0;return G(t,n,a)}function A(t,e=100){let{width:n,height:a,data:i}=t,r=new Uint8ClampedArray(i),s=(g,x)=>{if(g<0||x<0||g>=n||x>=a)return 0;let o=(x*n+g)*4;return r[o]>0?1:0},f=(g,x,o)=>{let c=(x*n+g)*4,d=o>0?255:0;r[c]=r[c+1]=r[c+2]=d},m=!0,p=0;for(;m&&p<e;){m=!1,p++;let g=[];for(let o=1;o<a-1;o++)for(let c=1;c<n-1;c++){if(s(c,o)===0)continue;let d=s(c,o-1),u=s(c+1,o-1),h=s(c+1,o),y=s(c+1,o+1),I=s(c,o+1),N=s(c-1,o+1),T=s(c-1,o),D=s(c-1,o-1),b=[d,u,h,y,I,N,T,D],E=b.reduce((C,M)=>C+M,0);if(E<2||E>6)continue;let P=0;for(let C=0;C<b.length;C++)b[C]===0&&b[(C+1)%b.length]===1&&P++;P===1&&d*h*I===0&&h*I*T===0&&g.push([c,o])}for(let[o,c]of g)f(o,c,0),m=!0;let x=[];for(let o=1;o<a-1;o++)for(let c=1;c<n-1;c++){if(s(c,o)===0)continue;let d=s(c,o-1),u=s(c+1,o-1),h=s(c+1,o),y=s(c+1,o+1),I=s(c,o+1),N=s(c-1,o+1),T=s(c-1,o),D=s(c-1,o-1),b=[d,u,h,y,I,N,T,D],E=b.reduce((C,M)=>C+M,0);if(E<2||E>6)continue;let P=0;for(let C=0;C<b.length;C++)b[C]===0&&b[(C+1)%b.length]===1&&P++;P===1&&d*h*T===0&&d*I*T===0&&x.push([c,o])}for(let[o,c]of x)f(o,c,0),m=!0}console.log(`[DEBUG] Thinning completed after ${p} iterations`);let l=new Uint8ClampedArray(r);return new ImageData(l,n,a)}async function V(t,e){let n=t instanceof HTMLImageElement?t:await v(t),a=n.width,i=n.height;console.log(`[DEBUG] Original (H\xD7W): ${i} \xD7 ${a}`);let r=R(n),s=e?.threshold??128,f=e?.inverse??!0,m=$(r,{threshold:s,inverse:f});console.log("[DEBUG] After preprocessing (grayscale + threshold)");let p=e?.maxIterations??100,l=A(m,p);return console.log("[DEBUG] After thinning with Zhang-Suen algorithm"),{skeleton:l,originalWidth:a,originalHeight:i,debugInfo:{thresholdValue:s,algorithm:"Zhang-Suen thinning algorithm"}}}function F(t){let e=t.reduce((i,r)=>i+r,0),n=0;for(let i=0;i<t.length;i++)t[i]===0&&t[(i+1)%t.length]===1&&n++;let a=t.join("")+t[0];if(e===1||e===2&&n>=2){if(e===1)return"endpoint";for(let i=0;i<t.length;i++)if(t[i]===1&&t[(i+1)%8]===1)return"endpoint"}if(e===2){if(n===2){for(let f=0;f<t.length;f++)if(t[f]===1&&t[(f+1)%8]===1)return"unclassified";return[[1,0,0,0,0,1,0,0],[0,1,0,0,0,0,1,0],[0,0,1,0,0,0,0,1],[0,0,0,1,1,0,0,0]].some(f=>{for(let m=0;m<8;m++)if(f[m]!==t[m])return!1;return!0})?"corner":"unclassified"}if(["10000100","01000010","00100001","00010001"].includes(t.join("")))return"corner"}if(e===3){if(n===2)return"t_junction";if(["10001000","01000100","00100010","00010001"].some(r=>a.includes(r)))return"t_junction"}return e>=4&&n>=2?"intersection":"unclassified"}function B(t,e,n){let{width:a,height:i,data:r}=t;if(e<1||n<1||e>=a-1||n>=i-1)return[];let s=[],f=[[-1,-1],[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0]];for(let[m,p]of f){let l=e+m,x=((n+p)*a+l)*4;s.push(r[x]>0?1:0)}return s}function rt(t,e={}){let{width:n,height:a,data:i}=t,r=[],s=new Map,f=e.minNeighbors??1,m=e.minTransitions??1,p=e.includeTypes??["corner","t_junction","endpoint","intersection"];for(let l=1;l<a-1;l++)for(let g=1;g<n-1;g++){let x=(l*n+g)*4;if(i[x]===0)continue;let o=B(t,g,l);if(o.length===0)continue;let c=o.reduce((h,y)=>h+y,0),d=F(o);if(d==="endpoint"){if(p.includes("endpoint")){let h=`${g},${l}`;s.set(h,{x:g,y:l,type:"endpoint"})}continue}if(c<f)continue;let u=0;for(let h=0;h<o.length;h++)o[h]===0&&o[(h+1)%8]===1&&u++;u<m||p.includes(d)&&r.push({x:g,y:l,type:d})}return r.push(...s.values()),console.log(`[DEBUG] Detected ${r.length} corner candidates (including endpoints: ${s.size})`),r}function st(t,e={}){if(t.length===0)return[];let n=e.maxDistance??10,a=e.distanceThreshold??30,i=e.minClusterSize??1,r=e.preserveTypes??!1;console.log(`[DEBUG] Clustering with maxDistance=${n}, preserveTypes=${r}`);let s=Math.max(8,n/2);console.log(`[DEBUG] Initial tight clustering with radius=${s}`);let f=[];for(let u=0;u<t.length;u++){f[u]=[];for(let h=0;h<t.length;h++){let y=t[u].x-t[h].x,I=t[u].y-t[h].y;f[u][h]=Math.sqrt(y*y+I*I)}}let m=[],p=new Set;for(let u=0;u<t.length;u++){if(p.has(u))continue;let h=[u];p.add(u);for(let y=0;y<t.length;y++)u===y||p.has(y)||f[u][y]<=s&&(h.push(y),p.add(y));m.push(h)}console.log(`[DEBUG] Initial clustering: ${m.length} clusters from ${t.length} points`);let l=[];if(r){let u={};for(let h of m){let y={};for(let D of h){let b=t[D].type||"unclassified";y[b]=(y[b]||0)+1}let I="unclassified",N=0;for(let D in y)y[D]>N&&(N=y[D],I=D);let T=h.map(D=>t[D]);u[I]||(u[I]=[]),u[I].push(...T)}for(let h in u){let y=u[h];l.push(...y.map(I=>[I]))}}else l=m.map(u=>u.map(h=>t[h]));let g=!0,x=0,o=10;for(;g&&x<o;){g=!1,x++;for(let u=0;u<l.length;u++)if(l[u])for(let h=u+1;h<l.length;h++){if(!l[h])continue;l[u].some(I=>l[h].some(N=>{let T=I.x-N.x,D=I.y-N.y;return Math.sqrt(T*T+D*D)<=n}))&&(l[u]=l[u].concat(l[h]),l[h]=null,g=!0)}g&&(l=l.filter(u=>u!==null),console.log(`[DEBUG] Clustering iteration ${x}: ${l.length} clusters remaining`))}let c=l.filter(u=>u.length>=i).map(u=>{let h=u.reduce((b,E)=>b+E.x,0),y=u.reduce((b,E)=>b+E.y,0),I={intersection:4,t_junction:3,corner:2,endpoint:1,unclassified:0},N={};for(let b of u){let E=b.type||"unclassified";N[E]=(N[E]||0)+1}let T="unclassified",D=-1;for(let b in N){let E=I[b]||0;E>D&&N[b]>0&&(D=E,T=b)}return{x:Math.round(h/u.length),y:Math.round(y/u.length),type:T,count:u.length}}),d={};for(let u of c){let h=u.type||"unclassified";d[h]=(d[h]||0)+1}return console.log(`[DEBUG] Final result: Clustered ${t.length} points into ${c.length} points`),console.log("[DEBUG] Point types after clustering:"),console.log(`Endpoints: ${d.endpoint||0}`),console.log(`T-Junctions: ${d.t_junction||0}`),console.log(`Corners: ${d.corner||0}`),console.log(`Intersections: ${d.intersection||0}`),console.log(`Unclassified: ${d.unclassified||0}`),c}function it(t,e,n={}){if(e.length<2)return[];let{width:a,height:i,data:r}=t,s=[],f=n.maxLineGap??5,m=n.maxDistance??100,p=(g,x)=>{let o=x.x-g.x,c=x.y-g.y,d=Math.sqrt(o*o+c*c);if(d>m)return!1;let u=Math.max(10,Math.floor(d/2)),h=0;for(let I=0;I<=u;I++){let N=I/u,T=Math.round(g.x+o*N),D=Math.round(g.y+c*N);if(T>=0&&T<a&&D>=0&&D<i){let b=(D*a+T)*4;r[b]>0&&h++}}let y=d<20?.9:.7;return h/u>=y};for(let g=0;g<e.length;g++){let x=e[g];for(let o=g+1;o<e.length;o++){let c=e[o];p(x,c)&&s.push({x1:x.x,y1:x.y,x2:c.x,y2:c.y})}}let l=[];for(let g of s)l.some(o=>{let c=Math.hypot(o.x1-g.x1,o.y1-g.y1)+Math.hypot(o.x2-g.x2,o.y2-g.y2),d=Math.hypot(o.x1-g.x2,o.y1-g.y2)+Math.hypot(o.x2-g.x1,o.y2-g.y1);return c<=f*2||d<=f*2})||l.push(g);return console.log(`[DEBUG] Created ${l.length} wall lines by connecting junctions`),l}function ct(t,e={}){let{width:n,height:a,data:i}=t,r=[],s=e.threshold??30,f=e.minLineLength??20,m=e.maxLineGap??5,p=e.maxDistance??5,l=[];for(let o=0;o<a;o++)for(let c=0;c<n;c++){let d=(o*n+c)*4;i[d]>0&&l.push({x:c,y:o})}let g=Math.PI/180;for(let o=0;o<l.length;o++){let c=l[o];for(let d=0;d<180;d++){let u=d*g,h=Math.cos(u),y=Math.sin(u),I=[];I.push(c);for(let N=0;N<l.length;N++){if(o===N)continue;let T=l[N],D=T.x-c.x,b=T.y-c.y;Math.abs(-y*T.x+h*T.y-(-y*c.x+h*c.y))<=p&&I.push(T)}if(I.length>=s){I.sort((P,C)=>(P.x-c.x)*h+(P.y-c.y)*y-((C.x-c.x)*h+(C.y-c.y)*y));let N=I[0],T=I[I.length-1],D=T.x-N.x,b=T.y-N.y;Math.sqrt(D*D+b*b)>=f&&r.push({x1:N.x,y1:N.y,x2:T.x,y2:T.y})}}}let x=[];for(let o of r)x.some(d=>{let u=Math.hypot(d.x1-o.x1,d.y1-o.y1)+Math.hypot(d.x2-o.x2,d.y2-o.y2),h=Math.hypot(d.x1-o.x2,d.y1-o.y2)+Math.hypot(d.x2-o.x1,d.y2-o.y1);return u<=m*2||h<=m*2})||x.push(o);return console.log(`[DEBUG] Detected ${x.length} line segments`),x}function J(t,e){let{x1:n,y1:a,x2:i,y2:r}=t,{x1:s,y1:f,x2:m,y2:p}=e,l=(n-i)*(f-p)-(a-r)*(s-m);if(Math.abs(l)<1e-6)return null;let g=((n*r-a*i)*(s-m)-(n-i)*(s*p-f*m))/l,x=((n*r-a*i)*(f-p)-(a-r)*(s*p-f*m))/l,o=(c,d,u)=>c>=Math.min(d,u)-1e-6&&c<=Math.max(d,u)+1e-6;return o(g,n,i)&&o(x,a,r)&&o(g,s,m)&&o(x,f,p)?{x:g,y:x}:null}function ht(t){let e=[];for(let n=0;n<t.length;n++)for(let a=n+1;a<t.length;a++){let i=J(t[n],t[a]);i&&(i.type="intersection",e.push(i))}return console.log(`[DEBUG] Found ${e.length} line intersections`),e}function gt(t){let e=[];if(t.length>0)for(let n of t)e.push({x:n.x1,y:n.y1,type:"endpoint"}),e.push({x:n.x2,y:n.y2,type:"endpoint"});return console.log(`[DEBUG] Extracted ${e.length} line endpoints`),e}function ft(t,e,n=[]){let a=[...t,...e,...n];return console.log(`[DEBUG] Combined ${t.length} corners, ${e.length} intersections, and ${n.length} endpoints`),a}function U(t,e,n,a,i,r){if(e<0||n<0||e>=t.width||n>=t.height)return;let s=(n*t.width+e)*4;t.data[s]=a,t.data[s+1]=i,t.data[s+2]=r}function S(t,e,n=6,a=[255,0,0],i=!0){let r=n;if(i&&e.type)switch(e.type){case"t_junction":case"intersection":r=Math.max(n*2,12);break;case"endpoint":r=Math.max(n*1.5,8);break;case"corner":r=Math.max(n*1.5,8);break}let s=Math.floor(r/2);for(let f=-s;f<=s;f++)for(let m=-s;m<=s;m++){let p=m===0&&f===0?255:180,[l,g,x]=a.map(o=>Math.min(255,o*p/255));U(t,e.x+m,e.y+f,l,g,x)}}function j(t,e,n,a,i,r=[0,0,255]){let[s,f,m]=r,p=Math.abs(a-e),l=Math.abs(i-n),g=e<a?1:-1,x=n<i?1:-1,o=p-l,c=e,d=n;for(;;){for(let h=-1;h<=1;h++)for(let y=-1;y<=1;y++)U(t,c+y,d+h,s,f,m);if(c===a&&d===i)break;let u=2*o;u>-l&&(o-=l,c+=g),u<p&&(o+=p,d+=x)}}function L(t){switch(t){case"corner":return[0,0,139];case"t_junction":return[0,255,0];case"endpoint":return[173,216,230];case"intersection":return[255,0,255];case"unclassified":default:return[255,165,0]}}function w(t,e,n,a,i=[255,255,255]){let[r,s,f]=i;for(let m=0;m<5;m++)for(let p=0;p<5;p++)U(t,e+p,n+m,r,s,f)}function k(t,e,n=!1){let a=n?t:new ImageData(new Uint8ClampedArray(t.data),t.width,t.height);for(let i of e){let r=L(i.type);S(a,i,3,r,!0)}return a}function _(t,e,n=!1,a=!1){let i=n?t:new ImageData(new Uint8ClampedArray(t.data),t.width,t.height);for(let r of e){let s=L(r.type);S(i,r,6,s,!0),a&&r.type&&w(i,r.x+8,r.y-8,r.type)}return i}function H(t,e,n=!1){let a=n?t:new ImageData(new Uint8ClampedArray(t.data),t.width,t.height);for(let{x1:i,y1:r,x2:s,y2:f}of e)j(a,Math.round(i),Math.round(r),Math.round(s),Math.round(f),[255,69,0]);return a}function It(t,e,n=!1,a={}){let i=n?t:new ImageData(new Uint8ClampedArray(t.data),t.width,t.height);if(e.lines&&H(i,e.lines,!0),e.corners&&k(i,e.corners,!0),e.intersections)for(let m of e.intersections)S(i,m,6,L("intersection"),!0);e.clusters&&_(i,e.clusters,!0,a.showLabels);let r=10,s=10,f=20;return e.clusters&&e.clusters.length>0&&(S(i,{x:r,y:s},6,L("corner"),!0),w(i,r+12,s,"Corner (L)",[255,255,255]),s+=f,S(i,{x:r,y:s},6,L("t_junction"),!0),w(i,r+12,s,"T-Junction",[255,255,255]),s+=f,S(i,{x:r,y:s},6,L("endpoint"),!0),w(i,r+12,s,"Endpoint",[255,255,255]),s+=f,S(i,{x:r,y:s},6,L("intersection"),!0),w(i,r+12,s,"Intersection",[255,255,255])),i}export{O as PointType,F as classifyJunctionType,st as clusterPoints,ft as combineFeaturePoints,it as connectJunctionsToLines,q as convertToGrayscale,rt as detectCorners,ct as detectStraightLines,_ as drawClusteredPoints,k as drawCorners,H as drawLines,gt as extractEndpoints,ht as findIntersections,R as imageToImageData,J as intersectLines,v as loadImage,$ as preprocessImage,W as renderImageDataToCanvas,V as skeletonizeImage,G as thresholdImage,It as visualizeFeatures,A as zhangSuenThinning};
//# sourceMappingURL=mod.js.map
