// Floorplan O1 Library - Built with esbuild
var w=(s=>(s.CORNER="corner",s.ENDPOINT="endpoint",s.T_JUNCTION="t_junction",s.INTERSECTION="intersection",s.UNCLASSIFIED="unclassified",s))(w||{});function R(e){let t=document.createElement("canvas");t.width=e.width,t.height=e.height;let r=t.getContext("2d");if(!r)throw new Error("Could not get canvas context");return r.drawImage(e,0,0),r.getImageData(0,0,t.width,t.height)}function v(e){return new Promise((t,r)=>{let a=new Image;a.crossOrigin="Anonymous",a.onload=()=>t(a),a.onerror=()=>r(new Error("Failed to load image")),typeof e=="string"?a.src=e:a.src=URL.createObjectURL(e)})}function q(e){let{width:t,height:r,data:a}=e,c=document.createElement("canvas");c.width=t,c.height=r;let i=c.getContext("2d").createImageData(t,r),f=i.data;for(let u=0;u<a.length;u+=4){let g=.299*a[u]+.587*a[u+1]+.114*a[u+2];f[u]=g,f[u+1]=g,f[u+2]=g,f[u+3]=a[u+3]}return i}function A(e,t=128,r=!0){let{width:a,height:c,data:s}=e,i=document.createElement("canvas");i.width=a,i.height=c;let u=i.getContext("2d").createImageData(a,c),g=u.data;for(let m=0;m<s.length;m+=4){let l=s[m]===s[m+1]&&s[m]===s[m+2]?s[m]:.299*s[m]+.587*s[m+1]+.114*s[m+2],d=r?l<t?255:0:l>t?255:0;g[m]=d,g[m+1]=d,g[m+2]=d,g[m+3]=255}return u}function W(e,t){t.width=e.width,t.height=e.height;let r=t.getContext("2d");if(!r)throw new Error("Could not get canvas context");r.putImageData(e,0,0)}function $(e,t){let r=t?.threshold||128,a=t?.inverse!==void 0?t.inverse:!0;return A(e,r,a)}function G(e,t=100){let{width:r,height:a,data:c}=e,s=new Uint8ClampedArray(c),i=(l,d)=>{if(l<0||d<0||l>=r||d>=a)return 0;let n=(d*r+l)*4;return s[n]>0?1:0},f=(l,d,n)=>{let o=(d*r+l)*4,h=n>0?255:0;s[o]=s[o+1]=s[o+2]=h},u=!0,g=0;for(;u&&g<t;){u=!1,g++;let l=[];for(let n=1;n<a-1;n++)for(let o=1;o<r-1;o++){if(i(o,n)===0)continue;let h=i(o,n-1),I=i(o+1,n-1),p=i(o+1,n),T=i(o+1,n+1),b=i(o,n+1),x=i(o-1,n+1),y=i(o-1,n),E=i(o-1,n-1),N=[h,I,p,T,b,x,y,E],C=N.reduce((D,M)=>D+M,0);if(C<2||C>6)continue;let P=0;for(let D=0;D<N.length;D++)N[D]===0&&N[(D+1)%N.length]===1&&P++;P===1&&h*p*b===0&&p*b*y===0&&l.push([o,n])}for(let[n,o]of l)f(n,o,0),u=!0;let d=[];for(let n=1;n<a-1;n++)for(let o=1;o<r-1;o++){if(i(o,n)===0)continue;let h=i(o,n-1),I=i(o+1,n-1),p=i(o+1,n),T=i(o+1,n+1),b=i(o,n+1),x=i(o-1,n+1),y=i(o-1,n),E=i(o-1,n-1),N=[h,I,p,T,b,x,y,E],C=N.reduce((D,M)=>D+M,0);if(C<2||C>6)continue;let P=0;for(let D=0;D<N.length;D++)N[D]===0&&N[(D+1)%N.length]===1&&P++;P===1&&h*p*y===0&&h*b*y===0&&d.push([o,n])}for(let[n,o]of d)f(n,o,0),u=!0}console.log(`[DEBUG] Thinning completed after ${g} iterations`);let m=new Uint8ClampedArray(s);return new ImageData(m,r,a)}async function Y(e,t){let r=e instanceof HTMLImageElement?e:await v(e),a=r.width,c=r.height;console.log(`[DEBUG] Original (H\xD7W): ${c} \xD7 ${a}`);let s=R(r),i=t?.threshold??128,f=t?.inverse??!0,u=$(s,{threshold:i,inverse:f});console.log("[DEBUG] After preprocessing (grayscale + threshold)");let g=t?.maxIterations??100,m=G(u,g);return console.log("[DEBUG] After thinning with Zhang-Suen algorithm"),{skeleton:m,originalWidth:a,originalHeight:c,debugInfo:{thresholdValue:i,algorithm:"Zhang-Suen thinning algorithm"}}}function F(e){let t=e.reduce((c,s)=>c+s,0),r=0;for(let c=0;c<e.length;c++)e[c]===0&&e[(c+1)%e.length]===1&&r++;let a=e.join("")+e[0];if(t===1||t===2&&r>=2){if(t===1)return"endpoint";for(let c=0;c<e.length;c++)if(e[c]===1&&e[(c+1)%8]===1)return"endpoint"}if(t===2){if(r===2){for(let s=0;s<e.length;s++)if(e[s]===1&&e[(s+1)%8]===1)return"unclassified";return"corner"}if(["10000100","01000010","00100001","00010001"].some(s=>a.includes(s)))return"corner"}if(t===3){if(r===2)return"t_junction";if(["10001000","01000100","00100010","00010001"].some(s=>a.includes(s)))return"t_junction"}return t>=4&&r>=2?"intersection":"unclassified"}function B(e,t,r){let{width:a,height:c,data:s}=e;if(t<1||r<1||t>=a-1||r>=c-1)return[];let i=[],f=[[-1,-1],[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0]];for(let[u,g]of f){let m=t+u,d=((r+g)*a+m)*4;i.push(s[d]>0?1:0)}return i}function rt(e,t={}){let{width:r,height:a,data:c}=e,s=[],i=new Map,f=t.minNeighbors??1,u=t.minTransitions??1,g=t.includeTypes??["corner","t_junction","endpoint","intersection"];for(let m=1;m<a-1;m++)for(let l=1;l<r-1;l++){let d=(m*r+l)*4;if(c[d]===0)continue;let n=B(e,l,m);if(n.length===0)continue;let o=n.reduce((p,T)=>p+T,0),h=F(n);if(h==="endpoint"){if(g.includes("endpoint")){let p=`${l},${m}`;i.set(p,{x:l,y:m,type:"endpoint"})}continue}if(o<f)continue;let I=0;for(let p=0;p<n.length;p++)n[p]===0&&n[(p+1)%8]===1&&I++;I<u||g.includes(h)&&s.push({x:l,y:m,type:h})}return s.push(...i.values()),console.log(`[DEBUG] Detected ${s.length} corner candidates (including endpoints: ${i.size})`),s}function st(e,t={}){if(e.length===0)return[];let r=t.maxDistance??10,a=t.distanceThreshold??30,c=t.minClusterSize??1,s=t.preserveTypes??!0,i={};if(s){for(let g of e){let m=g.type||"unclassified";i[m]||(i[m]=[]),i[m].push(g)}i.endpoint||(i.endpoint=[])}else i.all=e;let f=[];for(let g in i){let l=i[g].map(o=>[o]),d=!0;for(;d;){d=!1;for(let o=0;o<l.length;o++)if(l[o])for(let h=o+1;h<l.length;h++){if(!l[h])continue;l[o].some(p=>l[h].some(T=>{let b=p.x-T.x,x=p.y-T.y;return Math.sqrt(b*b+x*x)<=r}))&&(l[o]=l[o].concat(l[h]),l[h]=null,d=!0)}d&&(l=l.filter(o=>o!==null))}let n=l.filter(o=>o.length>=c).map(o=>{let h=o.reduce((x,y)=>x+y.x,0),I=o.reduce((x,y)=>x+y.y,0),p={};for(let x of o){let y=x.type||"unclassified";p[y]=(p[y]||0)+1}let T="unclassified",b=0;for(let x in p)p[x]>b&&(b=p[x],T=x);return{x:Math.round(h/o.length),y:Math.round(I/o.length),type:T,count:o.length}});f.push(...n)}let u={};for(let g of f){let m=g.type||"unclassified";u[m]=(u[m]||0)+1}return console.log(`[DEBUG] Clustered into ${f.length} points`),console.log("[DEBUG] Point types after clustering:"),console.log(`Endpoints: ${u.endpoint||0}`),console.log(`T-Junctions: ${u.t_junction||0}`),console.log(`Corners: ${u.corner||0}`),console.log(`Intersections: ${u.intersection||0}`),console.log(`Unclassified: ${u.unclassified||0}`),console.log("[DEBUG] Point types after clustering:"),console.log(`L-Corners: ${u.corner||0}`),console.log(`T-Junctions: ${u.t_junction||0}`),console.log(`X-Intersections: ${u.intersection||0}`),console.log(`Endpoints: ${u.endpoint||0}`),console.log(`Unclassified: ${u.unclassified||0}`),f}function it(e,t,r={}){if(t.length<2)return[];let{width:a,height:c,data:s}=e,i=[],f=r.maxLineGap??5,u=r.maxDistance??100,g=(l,d)=>{let n=d.x-l.x,o=d.y-l.y,h=Math.sqrt(n*n+o*o);if(h>u)return!1;let I=Math.max(10,Math.floor(h/2)),p=0;for(let b=0;b<=I;b++){let x=b/I,y=Math.round(l.x+n*x),E=Math.round(l.y+o*x);if(y>=0&&y<a&&E>=0&&E<c){let N=(E*a+y)*4;s[N]>0&&p++}}let T=h<20?.9:.7;return p/I>=T};for(let l=0;l<t.length;l++){let d=t[l];for(let n=l+1;n<t.length;n++){let o=t[n];g(d,o)&&i.push({x1:d.x,y1:d.y,x2:o.x,y2:o.y})}}let m=[];for(let l of i)m.some(n=>{let o=Math.hypot(n.x1-l.x1,n.y1-l.y1)+Math.hypot(n.x2-l.x2,n.y2-l.y2),h=Math.hypot(n.x1-l.x2,n.y1-l.y2)+Math.hypot(n.x2-l.x1,n.y2-l.y1);return o<=f*2||h<=f*2})||m.push(l);return console.log(`[DEBUG] Created ${m.length} wall lines by connecting junctions`),m}function ct(e,t={}){let{width:r,height:a,data:c}=e,s=[],i=t.threshold??30,f=t.minLineLength??20,u=t.maxLineGap??5,g=t.maxDistance??5,m=[];for(let n=0;n<a;n++)for(let o=0;o<r;o++){let h=(n*r+o)*4;c[h]>0&&m.push({x:o,y:n})}let l=Math.PI/180;for(let n=0;n<m.length;n++){let o=m[n];for(let h=0;h<180;h++){let I=h*l,p=Math.cos(I),T=Math.sin(I),b=[];b.push(o);for(let x=0;x<m.length;x++){if(n===x)continue;let y=m[x],E=y.x-o.x,N=y.y-o.y;Math.abs(-T*y.x+p*y.y-(-T*o.x+p*o.y))<=g&&b.push(y)}if(b.length>=i){b.sort((P,D)=>(P.x-o.x)*p+(P.y-o.y)*T-((D.x-o.x)*p+(D.y-o.y)*T));let x=b[0],y=b[b.length-1],E=y.x-x.x,N=y.y-x.y;Math.sqrt(E*E+N*N)>=f&&s.push({x1:x.x,y1:x.y,x2:y.x,y2:y.y})}}}let d=[];for(let n of s)d.some(h=>{let I=Math.hypot(h.x1-n.x1,h.y1-n.y1)+Math.hypot(h.x2-n.x2,h.y2-n.y2),p=Math.hypot(h.x1-n.x2,h.y1-n.y2)+Math.hypot(h.x2-n.x1,h.y2-n.y1);return I<=u*2||p<=u*2})||d.push(n);return console.log(`[DEBUG] Detected ${d.length} line segments`),d}function J(e,t){let{x1:r,y1:a,x2:c,y2:s}=e,{x1:i,y1:f,x2:u,y2:g}=t,m=(r-c)*(f-g)-(a-s)*(i-u);if(Math.abs(m)<1e-6)return null;let l=((r*s-a*c)*(i-u)-(r-c)*(i*g-f*u))/m,d=((r*s-a*c)*(f-g)-(a-s)*(i*g-f*u))/m,n=(o,h,I)=>o>=Math.min(h,I)-1e-6&&o<=Math.max(h,I)+1e-6;return n(l,r,c)&&n(d,a,s)&&n(l,i,u)&&n(d,f,g)?{x:l,y:d}:null}function ht(e){let t=[];for(let r=0;r<e.length;r++)for(let a=r+1;a<e.length;a++){let c=J(e[r],e[a]);c&&(c.type="intersection",t.push(c))}return console.log(`[DEBUG] Found ${t.length} line intersections`),t}function gt(e){let t=[];if(e.length>0)for(let r of e)t.push({x:r.x1,y:r.y1,type:"endpoint"}),t.push({x:r.x2,y:r.y2,type:"endpoint"});return console.log(`[DEBUG] Extracted ${t.length} line endpoints`),t}function ft(e,t,r=[]){let a=[...e,...t,...r];return console.log(`[DEBUG] Combined ${e.length} corners, ${t.length} intersections, and ${r.length} endpoints`),a}function U(e,t,r,a,c,s){if(t<0||r<0||t>=e.width||r>=e.height)return;let i=(r*e.width+t)*4;e.data[i]=a,e.data[i+1]=c,e.data[i+2]=s}function L(e,t,r=3,a=[255,0,0],c=!0){let s=r;if(c&&t.type)switch(t.type){case"t_junction":case"intersection":s=Math.max(r*2,6);break;case"endpoint":s=Math.max(r*1.5,4);break}let i=Math.floor(s/2);for(let f=-i;f<=i;f++)for(let u=-i;u<=i;u++){let g=u===0&&f===0?255:180,[m,l,d]=a.map(n=>Math.min(255,n*g/255));U(e,t.x+u,t.y+f,m,l,d)}}function k(e,t,r,a,c,s=[0,0,255]){let[i,f,u]=s,g=Math.abs(a-t),m=Math.abs(c-r),l=t<a?1:-1,d=r<c?1:-1,n=g-m,o=t,h=r;for(;U(e,o,h,i,f,u),!(o===a&&h===c);){let I=2*n;I>-m&&(n-=m,o+=l),I<g&&(n+=g,h+=d)}}function O(e){switch(e){case"corner":return[255,0,0];case"t_junction":return[255,255,0];case"endpoint":return[173,216,230];case"intersection":return[255,255,0];case"unclassified":default:return[255,165,0]}}function S(e,t,r,a,c=[255,255,255]){let[s,i,f]=c;for(let u=0;u<5;u++)for(let g=0;g<5;g++)U(e,t+g,r+u,s,i,f)}function _(e,t,r=!1){let a=r?e:new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);for(let c of t){let s=O(c.type);L(a,c,3,s,!0)}return a}function j(e,t,r=!1,a=!1){let c=r?e:new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);for(let s of t){let i=O(s.type);L(c,s,3,i,!1),a&&s.type&&S(c,s.x+6,s.y-6,s.type)}return c}function H(e,t,r=!1){let a=r?e:new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);for(let{x1:c,y1:s,x2:i,y2:f}of t)k(a,Math.round(c),Math.round(s),Math.round(i),Math.round(f),[0,255,255]);return a}function It(e,t,r=!1,a={}){let c=r?e:new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);if(t.lines&&H(c,t.lines,!0),t.corners&&_(c,t.corners,!0),t.intersections)for(let u of t.intersections)L(c,u,3,O("intersection"),!0);t.clusters&&j(c,t.clusters,!0,a.showLabels);let s=10,i=10,f=15;return t.clusters&&t.clusters.length>0&&(L(c,{x:s,y:i},5,O("corner"),!0),S(c,s+10,i,"Corner (L)",[255,255,255]),i+=f,L(c,{x:s,y:i},5,O("t_junction"),!0),S(c,s+10,i,"T-Junction",[255,255,255]),i+=f,L(c,{x:s,y:i},5,O("endpoint"),!0),S(c,s+10,i,"Endpoint",[255,255,255]),i+=f,L(c,{x:s,y:i},5,O("intersection"),!0),S(c,s+10,i,"Intersection",[255,255,255])),c}export{w as PointType,F as classifyJunctionType,st as clusterPoints,ft as combineFeaturePoints,it as connectJunctionsToLines,q as convertToGrayscale,rt as detectCorners,ct as detectStraightLines,j as drawClusteredPoints,_ as drawCorners,H as drawLines,gt as extractEndpoints,ht as findIntersections,R as imageToImageData,J as intersectLines,v as loadImage,$ as preprocessImage,W as renderImageDataToCanvas,Y as skeletonizeImage,A as thresholdImage,It as visualizeFeatures,G as zhangSuenThinning};
//# sourceMappingURL=mod.js.map
