// Floorplan O1 Library - Built with esbuild
var L=(n=>(n.CORNER="corner",n.ENDPOINT="endpoint",n.T_JUNCTION="t_junction",n.INTERSECTION="intersection",n.UNCLASSIFIED="unclassified",n))(L||{});function R(e){let t=document.createElement("canvas");t.width=e.width,t.height=e.height;let o=t.getContext("2d");if(!o)throw new Error("Could not get canvas context");return o.drawImage(e,0,0),o.getImageData(0,0,t.width,t.height)}function v(e){return new Promise((t,o)=>{let a=new Image;a.crossOrigin="Anonymous",a.onload=()=>t(a),a.onerror=()=>o(new Error("Failed to load image")),typeof e=="string"?a.src=e:a.src=URL.createObjectURL(e)})}function W(e){let{width:t,height:o,data:a}=e,s=document.createElement("canvas");s.width=t,s.height=o;let r=s.getContext("2d").createImageData(t,o),m=r.data;for(let u=0;u<a.length;u+=4){let h=.299*a[u]+.587*a[u+1]+.114*a[u+2];m[u]=h,m[u+1]=h,m[u+2]=h,m[u+3]=a[u+3]}return r}function A(e,t=128,o=!0){let{width:a,height:s,data:n}=e,r=document.createElement("canvas");r.width=a,r.height=s;let u=r.getContext("2d").createImageData(a,s),h=u.data;for(let l=0;l<n.length;l+=4){let g=n[l]===n[l+1]&&n[l]===n[l+2]?n[l]:.299*n[l]+.587*n[l+1]+.114*n[l+2],d=o?g<t?255:0:g>t?255:0;h[l]=d,h[l+1]=d,h[l+2]=d,h[l+3]=255}return u}function X(e,t){t.width=e.width,t.height=e.height;let o=t.getContext("2d");if(!o)throw new Error("Could not get canvas context");o.putImageData(e,0,0)}function $(e,t){let o=t?.threshold||128,a=t?.inverse!==void 0?t.inverse:!0;return A(e,o,a)}function F(e,t=100){let{width:o,height:a,data:s}=e,n=new Uint8ClampedArray(s),r=(g,d)=>{if(g<0||d<0||g>=o||d>=a)return 0;let c=(d*o+g)*4;return n[c]>0?1:0},m=(g,d,c)=>{let i=(d*o+g)*4,f=c>0?255:0;n[i]=n[i+1]=n[i+2]=f},u=!0,h=0;for(;u&&h<t;){u=!1,h++;let g=[];for(let c=1;c<a-1;c++)for(let i=1;i<o-1;i++){if(r(i,c)===0)continue;let f=r(i,c-1),I=r(i+1,c-1),p=r(i+1,c),T=r(i+1,c+1),b=r(i,c+1),x=r(i-1,c+1),y=r(i-1,c),P=r(i-1,c-1),D=[f,I,p,T,b,x,y,P],C=D.reduce((N,U)=>N+U,0);if(C<2||C>6)continue;let E=0;for(let N=0;N<D.length;N++)D[N]===0&&D[(N+1)%D.length]===1&&E++;E===1&&f*p*b===0&&p*b*y===0&&g.push([i,c])}for(let[c,i]of g)m(c,i,0),u=!0;let d=[];for(let c=1;c<a-1;c++)for(let i=1;i<o-1;i++){if(r(i,c)===0)continue;let f=r(i,c-1),I=r(i+1,c-1),p=r(i+1,c),T=r(i+1,c+1),b=r(i,c+1),x=r(i-1,c+1),y=r(i-1,c),P=r(i-1,c-1),D=[f,I,p,T,b,x,y,P],C=D.reduce((N,U)=>N+U,0);if(C<2||C>6)continue;let E=0;for(let N=0;N<D.length;N++)D[N]===0&&D[(N+1)%D.length]===1&&E++;E===1&&f*p*y===0&&f*b*y===0&&d.push([i,c])}for(let[c,i]of d)m(c,i,0),u=!0}console.log(`[DEBUG] Thinning completed after ${h} iterations`);let l=new Uint8ClampedArray(n);return new ImageData(l,o,a)}async function V(e,t){let o=e instanceof HTMLImageElement?e:await v(e),a=o.width,s=o.height;console.log(`[DEBUG] Original (H\xD7W): ${s} \xD7 ${a}`);let n=R(o),r=t?.threshold??128,m=t?.inverse??!0,u=$(n,{threshold:r,inverse:m});console.log("[DEBUG] After preprocessing (grayscale + threshold)");let h=t?.maxIterations??100,l=F(u,h);return console.log("[DEBUG] After thinning with Zhang-Suen algorithm"),{skeleton:l,originalWidth:a,originalHeight:s,debugInfo:{thresholdValue:r,algorithm:"Zhang-Suen thinning algorithm"}}}function G(e){let t=e.reduce((s,n)=>s+n,0),o=0;for(let s=0;s<e.length;s++)e[s]===0&&e[(s+1)%e.length]===1&&o++;let a=e.join("")+e[0];if(t===1||t===2&&o>=2){if(t===1)return"endpoint";for(let s=0;s<e.length;s++)if(e[s]===1&&e[(s+1)%8]===1)return"endpoint"}if(t===2){if(o===2){for(let n=0;n<e.length;n++)if(e[n]===1&&e[(n+1)%8]===1)return"unclassified";return"corner"}if(["10000100","01000010","00100001","00010001"].some(n=>a.includes(n)))return"corner"}if(t===3){if(o===2)return"t_junction";if(["10001000","01000100","00100010","00010001"].some(n=>a.includes(n)))return"t_junction"}return t>=4&&o>=2?"intersection":"unclassified"}function B(e,t,o){let{width:a,height:s,data:n}=e;if(t<1||o<1||t>=a-1||o>=s-1)return[];let r=[],m=[[-1,-1],[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0]];for(let[u,h]of m){let l=t+u,d=((o+h)*a+l)*4;r.push(n[d]>0?1:0)}return r}function rt(e,t={}){let{width:o,height:a,data:s}=e,n=[],r=new Map,m=t.minNeighbors??1,u=t.minTransitions??1,h=t.includeTypes??["corner","t_junction","endpoint","intersection"];for(let l=1;l<a-1;l++)for(let g=1;g<o-1;g++){let d=(l*o+g)*4;if(s[d]===0)continue;let c=B(e,g,l);if(c.length===0)continue;let i=c.reduce((p,T)=>p+T,0),f=G(c);if(f==="endpoint"){if(h.includes("endpoint")){let p=`${g},${l}`;r.set(p,{x:g,y:l,type:"endpoint"})}continue}if(i<m)continue;let I=0;for(let p=0;p<c.length;p++)c[p]===0&&c[(p+1)%8]===1&&I++;I<u||h.includes(f)&&n.push({x:g,y:l,type:f})}return n.push(...r.values()),console.log(`[DEBUG] Detected ${n.length} corner candidates (including endpoints: ${r.size})`),n}function it(e,t={}){if(e.length===0)return[];let o=t.maxDistance??10,a=t.distanceThreshold??30,s=t.minClusterSize??1,n=t.preserveTypes??!0,r={};if(n){for(let h of e){let l=h.type||"unclassified";r[l]||(r[l]=[]),r[l].push(h)}r.endpoint||(r.endpoint=[])}else r.all=e;let m=[];for(let h in r){let g=r[h].map(i=>[i]),d=!0;for(;d;){d=!1;for(let i=0;i<g.length;i++)if(g[i])for(let f=i+1;f<g.length;f++){if(!g[f])continue;g[i].some(p=>g[f].some(T=>{let b=p.x-T.x,x=p.y-T.y;return Math.sqrt(b*b+x*x)<=o}))&&(g[i]=g[i].concat(g[f]),g[f]=null,d=!0)}d&&(g=g.filter(i=>i!==null))}let c=g.filter(i=>i.length>=s).map(i=>{let f=i.reduce((x,y)=>x+y.x,0),I=i.reduce((x,y)=>x+y.y,0),p={};for(let x of i){let y=x.type||"unclassified";p[y]=(p[y]||0)+1}let T="unclassified",b=0;for(let x in p)p[x]>b&&(b=p[x],T=x);return{x:Math.round(f/i.length),y:Math.round(I/i.length),type:T,count:i.length}});m.push(...c)}let u={};for(let h of m){let l=h.type||"unclassified";u[l]=(u[l]||0)+1}return console.log(`[DEBUG] Clustered into ${m.length} points`),console.log("[DEBUG] Point types after clustering:"),console.log(`Endpoints: ${u.endpoint||0}`),console.log(`T-Junctions: ${u.t_junction||0}`),console.log(`Corners: ${u.corner||0}`),console.log(`Intersections: ${u.intersection||0}`),console.log(`Unclassified: ${u.unclassified||0}`),m}function st(e,t={}){let{width:o,height:a,data:s}=e,n=[],r=t.threshold??30,m=t.minLineLength??20,u=t.maxLineGap??5,h=t.maxDistance??5,l=[];for(let c=0;c<a;c++)for(let i=0;i<o;i++){let f=(c*o+i)*4;s[f]>0&&l.push({x:i,y:c})}let g=Math.PI/180;for(let c=0;c<l.length;c++){let i=l[c];for(let f=0;f<180;f++){let I=f*g,p=Math.cos(I),T=Math.sin(I),b=[];b.push(i);for(let x=0;x<l.length;x++){if(c===x)continue;let y=l[x],P=y.x-i.x,D=y.y-i.y;Math.abs(-T*y.x+p*y.y-(-T*i.x+p*i.y))<=h&&b.push(y)}if(b.length>=r){b.sort((E,N)=>(E.x-i.x)*p+(E.y-i.y)*T-((N.x-i.x)*p+(N.y-i.y)*T));let x=b[0],y=b[b.length-1],P=y.x-x.x,D=y.y-x.y;Math.sqrt(P*P+D*D)>=m&&n.push({x1:x.x,y1:x.y,x2:y.x,y2:y.y})}}}let d=[];for(let c of n)d.some(f=>{let I=Math.hypot(f.x1-c.x1,f.y1-c.y1)+Math.hypot(f.x2-c.x2,f.y2-c.y2),p=Math.hypot(f.x1-c.x2,f.y1-c.y2)+Math.hypot(f.x2-c.x1,f.y2-c.y1);return I<=u*2||p<=u*2})||d.push(c);return console.log(`[DEBUG] Detected ${d.length} line segments`),d}function k(e,t){let{x1:o,y1:a,x2:s,y2:n}=e,{x1:r,y1:m,x2:u,y2:h}=t,l=(o-s)*(m-h)-(a-n)*(r-u);if(Math.abs(l)<1e-6)return null;let g=((o*n-a*s)*(r-u)-(o-s)*(r*h-m*u))/l,d=((o*n-a*s)*(m-h)-(a-n)*(r*h-m*u))/l,c=(i,f,I)=>i>=Math.min(f,I)-1e-6&&i<=Math.max(f,I)+1e-6;return c(g,o,s)&&c(d,a,n)&&c(g,r,u)&&c(d,m,h)?{x:g,y:d}:null}function mt(e){let t=[];for(let o=0;o<e.length;o++)for(let a=o+1;a<e.length;a++){let s=k(e[o],e[a]);s&&(s.type="intersection",t.push(s))}return console.log(`[DEBUG] Found ${t.length} line intersections`),t}function ht(e){let t=[];if(e.length>0)for(let o of e)t.push({x:o.x1,y:o.y1,type:"endpoint"}),t.push({x:o.x2,y:o.y2,type:"endpoint"});return console.log(`[DEBUG] Extracted ${t.length} line endpoints`),t}function gt(e,t,o=[]){let a=[...e,...t,...o];return console.log(`[DEBUG] Combined ${e.length} corners, ${t.length} intersections, and ${o.length} endpoints`),a}function M(e,t,o,a,s,n){if(t<0||o<0||t>=e.width||o>=e.height)return;let r=(o*e.width+t)*4;e.data[r]=a,e.data[r+1]=s,e.data[r+2]=n}function O(e,t,o=3,a=[255,0,0]){let s=o;if(t.type)switch(t.type){case"t_junction":case"intersection":s=Math.max(o*3,9);break;case"endpoint":s=Math.max(o*2,6);break}let n=Math.floor(s/2);for(let r=-n;r<=n;r++)for(let m=-n;m<=n;m++){let u=m===0&&r===0?255:180,[h,l,g]=a.map(d=>Math.min(255,d*u/255));M(e,t.x+m,t.y+r,h,l,g)}}function J(e,t,o,a,s,n=[0,0,255]){let[r,m,u]=n,h=Math.abs(a-t),l=Math.abs(s-o),g=t<a?1:-1,d=o<s?1:-1,c=h-l,i=t,f=o;for(;M(e,i,f,r,m,u),!(i===a&&f===s);){let I=2*c;I>-l&&(c-=l,i+=g),I<h&&(c+=h,f+=d)}}function w(e){switch(e){case"corner":return[255,0,0];case"t_junction":return[255,255,0];case"endpoint":return[173,216,230];case"intersection":return[255,255,0];case"unclassified":default:return[255,165,0]}}function S(e,t,o,a,s=[255,255,255]){let[n,r,m]=s;for(let u=0;u<5;u++)for(let h=0;h<5;h++)M(e,t+h,o+u,n,r,m)}function _(e,t,o=!1){let a=o?e:new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);for(let s of t){let n=w(s.type);O(a,s,3,n)}return a}function z(e,t,o=!1,a=!1){let s=o?e:new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);for(let n of t){let r=w(n.type),m=n.count?Math.min(5+Math.floor(n.count/3),10):5;O(s,n,m,r),a&&n.type&&S(s,n.x+6,n.y-6,n.type)}return s}function H(e,t,o=!1){let a=o?e:new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);for(let{x1:s,y1:n,x2:r,y2:m}of t)J(a,Math.round(s),Math.round(n),Math.round(r),Math.round(m),[0,255,255]);return a}function yt(e,t,o=!1,a={}){let s=o?e:new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);if(t.lines&&H(s,t.lines,!0),t.corners&&_(s,t.corners,!0),t.intersections)for(let u of t.intersections)O(s,u,3,w("intersection"));t.clusters&&z(s,t.clusters,!0,a.showLabels);let n=10,r=10,m=15;return t.clusters&&t.clusters.length>0&&(O(s,{x:n,y:r},5,w("corner")),S(s,n+10,r,"Corner (L)",[255,255,255]),r+=m,O(s,{x:n,y:r},5,w("t_junction")),S(s,n+10,r,"T-Junction",[255,255,255]),r+=m,O(s,{x:n,y:r},5,w("endpoint")),S(s,n+10,r,"Endpoint",[255,255,255]),r+=m,O(s,{x:n,y:r},5,w("intersection")),S(s,n+10,r,"Intersection",[255,255,255])),s}export{L as PointType,G as classifyJunctionType,it as clusterPoints,gt as combineFeaturePoints,W as convertToGrayscale,rt as detectCorners,st as detectStraightLines,z as drawClusteredPoints,_ as drawCorners,H as drawLines,ht as extractEndpoints,mt as findIntersections,R as imageToImageData,k as intersectLines,v as loadImage,$ as preprocessImage,X as renderImageDataToCanvas,V as skeletonizeImage,A as thresholdImage,yt as visualizeFeatures,F as zhangSuenThinning};
//# sourceMappingURL=mod.js.map
