// Floorplan O1 Library - Built with esbuild
var S=(i=>(i.CORNER="corner",i.ENDPOINT="endpoint",i.T_JUNCTION="t_junction",i.INTERSECTION="intersection",i.UNCLASSIFIED="unclassified",i))(S||{});function R(e){let t=document.createElement("canvas");t.width=e.width,t.height=e.height;let r=t.getContext("2d");if(!r)throw new Error("Could not get canvas context");return r.drawImage(e,0,0),r.getImageData(0,0,t.width,t.height)}function v(e){return new Promise((t,r)=>{let a=new Image;a.crossOrigin="Anonymous",a.onload=()=>t(a),a.onerror=()=>r(new Error("Failed to load image")),typeof e=="string"?a.src=e:a.src=URL.createObjectURL(e)})}function q(e){let{width:t,height:r,data:a}=e,c=document.createElement("canvas");c.width=t,c.height=r;let s=c.getContext("2d").createImageData(t,r),f=s.data;for(let m=0;m<a.length;m+=4){let g=.299*a[m]+.587*a[m+1]+.114*a[m+2];f[m]=g,f[m+1]=g,f[m+2]=g,f[m+3]=a[m+3]}return s}function A(e,t=128,r=!0){let{width:a,height:c,data:i}=e,s=document.createElement("canvas");s.width=a,s.height=c;let m=s.getContext("2d").createImageData(a,c),g=m.data;for(let u=0;u<i.length;u+=4){let l=i[u]===i[u+1]&&i[u]===i[u+2]?i[u]:.299*i[u]+.587*i[u+1]+.114*i[u+2],d=r?l<t?255:0:l>t?255:0;g[u]=d,g[u+1]=d,g[u+2]=d,g[u+3]=255}return m}function W(e,t){t.width=e.width,t.height=e.height;let r=t.getContext("2d");if(!r)throw new Error("Could not get canvas context");r.putImageData(e,0,0)}function $(e,t){let r=t?.threshold||128,a=t?.inverse!==void 0?t.inverse:!0;return A(e,r,a)}function G(e,t=100){let{width:r,height:a,data:c}=e,i=new Uint8ClampedArray(c),s=(l,d)=>{if(l<0||d<0||l>=r||d>=a)return 0;let n=(d*r+l)*4;return i[n]>0?1:0},f=(l,d,n)=>{let o=(d*r+l)*4,h=n>0?255:0;i[o]=i[o+1]=i[o+2]=h},m=!0,g=0;for(;m&&g<t;){m=!1,g++;let l=[];for(let n=1;n<a-1;n++)for(let o=1;o<r-1;o++){if(s(o,n)===0)continue;let h=s(o,n-1),I=s(o+1,n-1),p=s(o+1,n),T=s(o+1,n+1),b=s(o,n+1),x=s(o-1,n+1),y=s(o-1,n),P=s(o-1,n-1),N=[h,I,p,T,b,x,y,P],C=N.reduce((D,M)=>D+M,0);if(C<2||C>6)continue;let E=0;for(let D=0;D<N.length;D++)N[D]===0&&N[(D+1)%N.length]===1&&E++;E===1&&h*p*b===0&&p*b*y===0&&l.push([o,n])}for(let[n,o]of l)f(n,o,0),m=!0;let d=[];for(let n=1;n<a-1;n++)for(let o=1;o<r-1;o++){if(s(o,n)===0)continue;let h=s(o,n-1),I=s(o+1,n-1),p=s(o+1,n),T=s(o+1,n+1),b=s(o,n+1),x=s(o-1,n+1),y=s(o-1,n),P=s(o-1,n-1),N=[h,I,p,T,b,x,y,P],C=N.reduce((D,M)=>D+M,0);if(C<2||C>6)continue;let E=0;for(let D=0;D<N.length;D++)N[D]===0&&N[(D+1)%N.length]===1&&E++;E===1&&h*p*y===0&&h*b*y===0&&d.push([o,n])}for(let[n,o]of d)f(n,o,0),m=!0}console.log(`[DEBUG] Thinning completed after ${g} iterations`);let u=new Uint8ClampedArray(i);return new ImageData(u,r,a)}async function Y(e,t){let r=e instanceof HTMLImageElement?e:await v(e),a=r.width,c=r.height;console.log(`[DEBUG] Original (H\xD7W): ${c} \xD7 ${a}`);let i=R(r),s=t?.threshold??128,f=t?.inverse??!0,m=$(i,{threshold:s,inverse:f});console.log("[DEBUG] After preprocessing (grayscale + threshold)");let g=t?.maxIterations??100,u=G(m,g);return console.log("[DEBUG] After thinning with Zhang-Suen algorithm"),{skeleton:u,originalWidth:a,originalHeight:c,debugInfo:{thresholdValue:s,algorithm:"Zhang-Suen thinning algorithm"}}}function F(e){let t=e.reduce((c,i)=>c+i,0),r=0;for(let c=0;c<e.length;c++)e[c]===0&&e[(c+1)%e.length]===1&&r++;let a=e.join("")+e[0];if(t===1||t===2&&r>=2){if(t===1)return"endpoint";for(let c=0;c<e.length;c++)if(e[c]===1&&e[(c+1)%8]===1)return"endpoint"}if(t===2){if(r===2){for(let i=0;i<e.length;i++)if(e[i]===1&&e[(i+1)%8]===1)return"unclassified";return"corner"}if(["10000100","01000010","00100001","00010001"].some(i=>a.includes(i)))return"corner"}if(t===3){if(r===2)return"t_junction";if(["10001000","01000100","00100010","00010001"].some(i=>a.includes(i)))return"t_junction"}return t>=4&&r>=2?"intersection":"unclassified"}function B(e,t,r){let{width:a,height:c,data:i}=e;if(t<1||r<1||t>=a-1||r>=c-1)return[];let s=[],f=[[-1,-1],[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0]];for(let[m,g]of f){let u=t+m,d=((r+g)*a+u)*4;s.push(i[d]>0?1:0)}return s}function rt(e,t={}){let{width:r,height:a,data:c}=e,i=[],s=new Map,f=t.minNeighbors??1,m=t.minTransitions??1,g=t.includeTypes??["corner","t_junction","endpoint","intersection"];for(let u=1;u<a-1;u++)for(let l=1;l<r-1;l++){let d=(u*r+l)*4;if(c[d]===0)continue;let n=B(e,l,u);if(n.length===0)continue;let o=n.reduce((p,T)=>p+T,0),h=F(n);if(h==="endpoint"){if(g.includes("endpoint")){let p=`${l},${u}`;s.set(p,{x:l,y:u,type:"endpoint"})}continue}if(o<f)continue;let I=0;for(let p=0;p<n.length;p++)n[p]===0&&n[(p+1)%8]===1&&I++;I<m||g.includes(h)&&i.push({x:l,y:u,type:h})}return i.push(...s.values()),console.log(`[DEBUG] Detected ${i.length} corner candidates (including endpoints: ${s.size})`),i}function it(e,t={}){if(e.length===0)return[];let r=t.maxDistance??10,a=t.distanceThreshold??30,c=t.minClusterSize??1,i=t.preserveTypes??!0,s={};if(i){for(let g of e){let u=g.type||"unclassified";s[u]||(s[u]=[]),s[u].push(g)}s.endpoint||(s.endpoint=[])}else s.all=e;let f=[];for(let g in s){let l=s[g].map(o=>[o]),d=!0;for(;d;){d=!1;for(let o=0;o<l.length;o++)if(l[o])for(let h=o+1;h<l.length;h++){if(!l[h])continue;l[o].some(p=>l[h].some(T=>{let b=p.x-T.x,x=p.y-T.y;return Math.sqrt(b*b+x*x)<=r}))&&(l[o]=l[o].concat(l[h]),l[h]=null,d=!0)}d&&(l=l.filter(o=>o!==null))}let n=l.filter(o=>o.length>=c).map(o=>{let h=o.reduce((x,y)=>x+y.x,0),I=o.reduce((x,y)=>x+y.y,0),p={};for(let x of o){let y=x.type||"unclassified";p[y]=(p[y]||0)+1}let T="unclassified",b=0;for(let x in p)p[x]>b&&(b=p[x],T=x);return{x:Math.round(h/o.length),y:Math.round(I/o.length),type:T,count:o.length}});f.push(...n)}let m={};for(let g of f){let u=g.type||"unclassified";m[u]=(m[u]||0)+1}return console.log(`[DEBUG] Clustered into ${f.length} points`),console.log("[DEBUG] Point types after clustering:"),console.log(`Endpoints: ${m.endpoint||0}`),console.log(`T-Junctions: ${m.t_junction||0}`),console.log(`Corners: ${m.corner||0}`),console.log(`Intersections: ${m.intersection||0}`),console.log(`Unclassified: ${m.unclassified||0}`),f}function st(e,t,r={}){if(t.length<2)return[];let{width:a,height:c,data:i}=e,s=[],f=r.maxLineGap??5,m=r.maxDistance??100,g=(l,d)=>{let n=d.x-l.x,o=d.y-l.y,h=Math.sqrt(n*n+o*o);if(h>m)return!1;let I=Math.max(10,Math.floor(h/2)),p=0;for(let b=0;b<=I;b++){let x=b/I,y=Math.round(l.x+n*x),P=Math.round(l.y+o*x);if(y>=0&&y<a&&P>=0&&P<c){let N=(P*a+y)*4;i[N]>0&&p++}}let T=h<20?.9:.7;return p/I>=T};for(let l=0;l<t.length;l++){let d=t[l];for(let n=l+1;n<t.length;n++){let o=t[n];g(d,o)&&s.push({x1:d.x,y1:d.y,x2:o.x,y2:o.y})}}let u=[];for(let l of s)u.some(n=>{let o=Math.hypot(n.x1-l.x1,n.y1-l.y1)+Math.hypot(n.x2-l.x2,n.y2-l.y2),h=Math.hypot(n.x1-l.x2,n.y1-l.y2)+Math.hypot(n.x2-l.x1,n.y2-l.y1);return o<=f*2||h<=f*2})||u.push(l);return console.log(`[DEBUG] Created ${u.length} wall lines by connecting junctions`),u}function ct(e,t={}){let{width:r,height:a,data:c}=e,i=[],s=t.threshold??30,f=t.minLineLength??20,m=t.maxLineGap??5,g=t.maxDistance??5,u=[];for(let n=0;n<a;n++)for(let o=0;o<r;o++){let h=(n*r+o)*4;c[h]>0&&u.push({x:o,y:n})}let l=Math.PI/180;for(let n=0;n<u.length;n++){let o=u[n];for(let h=0;h<180;h++){let I=h*l,p=Math.cos(I),T=Math.sin(I),b=[];b.push(o);for(let x=0;x<u.length;x++){if(n===x)continue;let y=u[x],P=y.x-o.x,N=y.y-o.y;Math.abs(-T*y.x+p*y.y-(-T*o.x+p*o.y))<=g&&b.push(y)}if(b.length>=s){b.sort((E,D)=>(E.x-o.x)*p+(E.y-o.y)*T-((D.x-o.x)*p+(D.y-o.y)*T));let x=b[0],y=b[b.length-1],P=y.x-x.x,N=y.y-x.y;Math.sqrt(P*P+N*N)>=f&&i.push({x1:x.x,y1:x.y,x2:y.x,y2:y.y})}}}let d=[];for(let n of i)d.some(h=>{let I=Math.hypot(h.x1-n.x1,h.y1-n.y1)+Math.hypot(h.x2-n.x2,h.y2-n.y2),p=Math.hypot(h.x1-n.x2,h.y1-n.y2)+Math.hypot(h.x2-n.x1,h.y2-n.y1);return I<=m*2||p<=m*2})||d.push(n);return console.log(`[DEBUG] Detected ${d.length} line segments`),d}function J(e,t){let{x1:r,y1:a,x2:c,y2:i}=e,{x1:s,y1:f,x2:m,y2:g}=t,u=(r-c)*(f-g)-(a-i)*(s-m);if(Math.abs(u)<1e-6)return null;let l=((r*i-a*c)*(s-m)-(r-c)*(s*g-f*m))/u,d=((r*i-a*c)*(f-g)-(a-i)*(s*g-f*m))/u,n=(o,h,I)=>o>=Math.min(h,I)-1e-6&&o<=Math.max(h,I)+1e-6;return n(l,r,c)&&n(d,a,i)&&n(l,s,m)&&n(d,f,g)?{x:l,y:d}:null}function ht(e){let t=[];for(let r=0;r<e.length;r++)for(let a=r+1;a<e.length;a++){let c=J(e[r],e[a]);c&&(c.type="intersection",t.push(c))}return console.log(`[DEBUG] Found ${t.length} line intersections`),t}function gt(e){let t=[];if(e.length>0)for(let r of e)t.push({x:r.x1,y:r.y1,type:"endpoint"}),t.push({x:r.x2,y:r.y2,type:"endpoint"});return console.log(`[DEBUG] Extracted ${t.length} line endpoints`),t}function ft(e,t,r=[]){let a=[...e,...t,...r];return console.log(`[DEBUG] Combined ${e.length} corners, ${t.length} intersections, and ${r.length} endpoints`),a}function U(e,t,r,a,c,i){if(t<0||r<0||t>=e.width||r>=e.height)return;let s=(r*e.width+t)*4;e.data[s]=a,e.data[s+1]=c,e.data[s+2]=i}function L(e,t,r=3,a=[255,0,0],c=!0){let i=r;if(c&&t.type)switch(t.type){case"t_junction":case"intersection":i=Math.max(r*2,6);break;case"endpoint":i=Math.max(r*1.5,4);break}let s=Math.floor(i/2);for(let f=-s;f<=s;f++)for(let m=-s;m<=s;m++){let g=m===0&&f===0?255:180,[u,l,d]=a.map(n=>Math.min(255,n*g/255));U(e,t.x+m,t.y+f,u,l,d)}}function k(e,t,r,a,c,i=[0,0,255]){let[s,f,m]=i,g=Math.abs(a-t),u=Math.abs(c-r),l=t<a?1:-1,d=r<c?1:-1,n=g-u,o=t,h=r;for(;U(e,o,h,s,f,m),!(o===a&&h===c);){let I=2*n;I>-u&&(n-=u,o+=l),I<g&&(n+=g,h+=d)}}function w(e){switch(e){case"corner":return[255,0,0];case"t_junction":return[255,255,0];case"endpoint":return[173,216,230];case"intersection":return[255,255,0];case"unclassified":default:return[255,165,0]}}function O(e,t,r,a,c=[255,255,255]){let[i,s,f]=c;for(let m=0;m<5;m++)for(let g=0;g<5;g++)U(e,t+g,r+m,i,s,f)}function j(e,t,r=!1){let a=r?e:new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);for(let c of t){let i=w(c.type);L(a,c,3,i,!0)}return a}function _(e,t,r=!1,a=!1){let c=r?e:new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);for(let i of t){let s=w(i.type);L(c,i,3,s,!1),a&&i.type&&O(c,i.x+6,i.y-6,i.type)}return c}function H(e,t,r=!1){let a=r?e:new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);for(let{x1:c,y1:i,x2:s,y2:f}of t)k(a,Math.round(c),Math.round(i),Math.round(s),Math.round(f),[0,255,255]);return a}function It(e,t,r=!1,a={}){let c=r?e:new ImageData(new Uint8ClampedArray(e.data),e.width,e.height);if(t.lines&&H(c,t.lines,!0),t.corners&&j(c,t.corners,!0),t.intersections)for(let m of t.intersections)L(c,m,3,w("intersection"),!0);t.clusters&&_(c,t.clusters,!0,a.showLabels);let i=10,s=10,f=15;return t.clusters&&t.clusters.length>0&&(L(c,{x:i,y:s},5,w("corner"),!0),O(c,i+10,s,"Corner (L)",[255,255,255]),s+=f,L(c,{x:i,y:s},5,w("t_junction"),!0),O(c,i+10,s,"T-Junction",[255,255,255]),s+=f,L(c,{x:i,y:s},5,w("endpoint"),!0),O(c,i+10,s,"Endpoint",[255,255,255]),s+=f,L(c,{x:i,y:s},5,w("intersection"),!0),O(c,i+10,s,"Intersection",[255,255,255])),c}export{S as PointType,F as classifyJunctionType,it as clusterPoints,ft as combineFeaturePoints,st as connectJunctionsToLines,q as convertToGrayscale,rt as detectCorners,ct as detectStraightLines,_ as drawClusteredPoints,j as drawCorners,H as drawLines,gt as extractEndpoints,ht as findIntersections,R as imageToImageData,J as intersectLines,v as loadImage,$ as preprocessImage,W as renderImageDataToCanvas,Y as skeletonizeImage,A as thresholdImage,It as visualizeFeatures,G as zhangSuenThinning};
//# sourceMappingURL=mod.js.map
